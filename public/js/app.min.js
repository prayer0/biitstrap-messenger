define('organizator/config',{
    "localization": {
        "availableLocales" : ["en"],
        "defaultLocale" : "en"
    }
});
define('organizator/Component/Globals/Globals',[],function () {
    class Organizator_Globals {
        constructor() {
            this.globals = {};
        }

        set(key, value){
            this.globals[key] = value;

            return this.globals[key];
        }

        get(key){
            return typeof this.globals[key] !== 'undefined' ? this.globals[key] : typeof window.globals[key] !== 'undefined' ? window.globals[key] : undefined;
        }
    }

    return Organizator_Globals;
});
/*
 * Locator is a part of Routing component.
 * It responses History API-related requests into actions.
 */
define('organizator/Component/Routing/Locator',[],function () {
    class Organizator_Routing_Locator {
        constructor ( options = {} ) {
            this.requestOptions = options.requestOptions !== undefined ? Object.assign({
                mode: 'push',
                popstatable: true,
                absolute: false,
                load: true
            }, options.requestOptions) : {
                mode: 'push',
                popstatable: true,
                absolute: false,
                load: true
            }

            this.state = 'loaded';
            this.window = window;

            this.bindEvents();
        }

        bindEvents() {
//        this.Interface.window.addEventListener('popstate', () => this.popstate());
            // this.Interface.window.addEventListener('organizator:routing:request', (event) => this.listenRequests(event));
        }

        /*
         * Listens routing:request events and pass request details to request().
         */
        listenRequests() {
            this.request(event.detail.request);
        }

        /*
         * Accepts a (hashchange, pushState, replaceState, popstate) request.
         * 
         * @param {Object} request
         * @param {String} request.mode - Defines the mode of the request. Default is 'push'.
         * @param {String} request.popstatable - Defines whether the state is popstatable or not. Default is true.
         * @param {String} request.url - Defines the new url of the window.
         * @param {String} request.absolute - Defines whether the url is absolute or not. Default is false.
         * @param {String} request.data - Extra data.
         * @param {Boolean} request.load - Defines whether resource to be loaded or not. Default is true.
         * @param {Function} request.callback - Function name or function itself.
         */
        request(request) {
            /*
             * Write the request over the default one. Default value is used if an option is missing.
             */
            request = Object.assign(this.requestOptions, request);

            /*
             * We prepend the defined base value to url if passed url is not involve it already.
             */
            var url = (request.url && request.absolute) ? request.url : Organizator.Routing.base + request.url;

            if (url == window.location) {
                request.mode = 'replace';
            }

            switch (request.mode) {
                case 'push':
                    history.pushState(request, null, url);
                    break;

                case 'replace':
                    history.replaceState(request, null, url);
                    break;

                case 'reload':
                    this.window.location.reload();
                    break;

                case 'popstate':
                    break;
            }

            return true;
        }
    }

    return Organizator_Routing_Locator;
});
/*
 * Matcher is a part of Routing component.
 * It matches a path with a CompiledRoute.
 */
define(
    'organizator/Component/Routing/Matcher',[],function () {
        class Organizator_Routing_Matcher {
            constructor() {
                this.state = 'loaded';
                this.window = window;

                this.bindEvents();
            }

            bindEvents() {
                // this.Interface.window.addEventListener('organizator:routing:request:load', (event) => this.request(event));
            }

            /*
             * @param {String} request.resource - Defines the source of the content would be loaded.
             * @return {Route} route.
             */
            request(event) {
                var path = event.detail.resource;
                var route = this.checkAll(path);

                if (route !== false) {
                    var customEvent = new CustomEvent('router:matched', {'detail': route});
                    this.window.dispatchEvent(customEvent);
                }

                return route;
            }

            check(path, route) {
//    	if(!route.isRegex){
//            return path == route.path ? true : false;
//    	}else{
;
                return new RegExp(route.regex).test(path);
//    	}

//    	return false;
            }

            checkAll(path) {
                var path = Organizator.Routing._getFragment(path);
                var routesKeys = Object.keys(Organizator.Routing.routes);
                
                for (var i = 0; i < routesKeys.length; i++) {
                    for (var t = 0; t < Organizator.Routing.routes[routesKeys[i]].subroutes.length; t++) {
                        if (!Organizator.Routing.routes[routesKeys[i]].subroutes[t].isRegex) {
                            if (path == Organizator.Routing.routes[routesKeys[i]].subroutes[t].path) {
                                var matchedRoute = {
                                    route: Organizator.Routing.routes[routesKeys[i]],
                                    subroute: Organizator.Routing.routes[routesKeys[i]].subroutes[t]
                                };

                                return matchedRoute;
                            }
                        } else {
                            if (this.check(path, Organizator.Routing.routes[routesKeys[i]].subroutes[t])) {
                                var matches = this.getParameters(path, Organizator.Routing.routes[routesKeys[i]].subroutes[t].regex);
                                var matchedRoute = {
                                    route: Organizator.Routing.routes[routesKeys[i]],
                                    subroute: Organizator.Routing.routes[routesKeys[i]].subroutes[t],
                                    matches: matches
                                };

                                return matchedRoute;
                            }
                        }
                    }
                }

                return false;
            }

            getName(path) {
                var matchedRoute = this.checkAll(path);

                return matchedRoute.route.name || false;
            }

            getParameters(path, regex) {
                var matches = path.match(regex);

                if (matches) {
                    matches.shift();
                }

                return matches;
            }

            extractParameters(path, pattern) {
                var parameters = [], match;
                var pattern = pattern || /(?:\{)([^}:]+)(?:\})/g
                // very important to reset lastIndex since RegExp can have "g" flag
                // and multiple runs might affect the result, specially if matching
                // same string multiple times on IE 7-8
                pattern.lastIndex = 0;

                while (match = pattern.exec(path)) {
                    parameters.push(match[0]);
                }

                return parameters;
            }
        }

        return Organizator_Routing_Matcher;
    }
);

/*
 * Generator is a part of Routing component.
 * It generates a relative path or absolute url for a given route.
 */
define('organizator/Component/Routing/Generator',[],function () {
    class Organizator_Routing_Generator {
        constructor() {}

        generateUrl(routeName, parameters = {}, options = {checkRequirements: false, absolute: true}){
            var route = Organizator.Routing.routes[routeName];
            var queryStringParameters = {};

            if (!route) {
                return false;
            }

            if (route.placeholders.length) {
                parameters = Object.assign({}, Object.assign({}, route.defaults), parameters);
                var filledPath = route.path;

                for (var parameter in parameters) {
                    if (options.checkRequirements
                        && route.requirements[parameter] !== undefined
                        && !route.requirements[parameter].test(parameters[parameterKeys[i]])
                    ){
                        return false;
                    }

                    if(route.placeholders.indexOf('{' + parameter + '}') !== -1){
                        filledPath = filledPath.replace('{' + parameter + '}', parameters[parameter]);
                    }else{
                        queryStringParameters[parameter] = parameters[parameter];
                    }
                }

                return Organizator.Routing._clearSlashes(!options.absolute ? filledPath : Organizator.Routing.base + filledPath) + (Object.keys(queryStringParameters).length ? '?' + this._buildQueryString(queryStringParameters) : '');
            } else {
                if(Object.keys(parameters).length){
                    queryStringParameters = JSON.parse(JSON.stringify(parameters));
                }

                return Organizator.Routing._clearSlashes(!options.absolute ? route.path : Organizator.Routing.base + route.path) + (Object.keys(queryStringParameters).length ? '?' + this._buildQueryString(queryStringParameters) : '');
            }
        }

        _buildQueryString(obj, urlEncode) {
            //
            // Helper function that flattens an object, retaining key structer as a path array:
            //
            // Input: { prop1: 'x', prop2: { y: 1, z: 2 } }
            // Example output: [
            //     { path: [ 'prop1' ],      val: 'x' },
            //     { path: [ 'prop2', 'y' ], val: '1' },
            //     { path: [ 'prop2', 'z' ], val: '2' }
            // ]
            //
            function flattenObj(x, path) {
                var result = [];

                path = path || [];
                Object.keys(x).forEach(function (key) {
                    if (!x.hasOwnProperty(key)) return;

                    var newPath = path.slice();
                    newPath.push(key);

                    var vals = [];
                    if (typeof x[key] == 'object') {
                        vals = flattenObj(x[key], newPath);
                    } else {
                        vals.push({ path: newPath, val: x[key] });
                    }
                    vals.forEach(function (obj) {
                        return result.push(obj);
                    });
                });

                return result;
            } // flattenObj

            // start with  flattening `obj`
            var parts = flattenObj(obj); // [ { path: [ ...parts ], val: ... }, ... ]

            // convert to array notation:
            parts = parts.map(function (varInfo) {
                if (varInfo.path.length == 1) varInfo.path = varInfo.path[0];else {
                    var first = varInfo.path[0];
                    var rest = varInfo.path.slice(1);
                    varInfo.path = first + '[' + rest.join('][') + ']';
                }
                return varInfo;
            }); // parts.map

            // join the parts to a query-string url-component
            var queryString = parts.map(function (varInfo) {
                return varInfo.path + '=' + varInfo.val;
            }).join('&');
            if (urlEncode) return encodeURIComponent(queryString);else return queryString;
        }
    }

    return Organizator_Routing_Generator;
});
/*
 * Route is a part of Routing component.
 * Routes are compiled by RouteCompiler and registered to the application.
 */
define('organizator/Component/Routing/Route',[],function () {
    class Organizator_Routing_Route {
        constructor(options) {
            this.name = options.name;
            this.path = options.path;
            this.paths = options.paths;
            this.isRegex = options.isRegex;
            this.regex = options.regex;
            this.regexes = options.regexes;
            this.subroutes = options.subroutes;
            this.alternativeRegexes = options.alternativeRegexes;
            this.placeholders = options.placeholders;
            this.controller = options.controller;
            this.defaults = options.defaults;
            this.requirements = options.requirements;
        }
    }

    return Organizator_Routing_Route;
});
/*
 * RouteCompiler is a part of Routing component.
 * It compiles a Route and register it to the application.
 */
define(
    'organizator/Component/Routing/RouteCompiler',[
        'organizator/Component/Routing/Route'
    ], 
    function(
        Organizator_Routing_Route
    ){
    class Organizator_Routing_RouteCompiler {
        constructor() {
            this.parameterPattern = /(?:\{)([^}]+)(?:\})/g,

            this.emptyRoute = {
                name: '',
                path: '',
                paths: [],
                regexes: [],
                subroutes: [],
                controller: undefined,
                defaults: {},
                requirements: {},
                placeholders: {}
            };

            this.route = this.emptyRoute;
        }

        resetRoute() {
            this.route = {};
            
            this.emptyRoute = {
                name: '',
                path: '',
                paths: [],
                regexes: [],
                subroutes: [],
                controller: undefined,
                defaults: {},
                requirements: {},
                placeholders: {}
            };
        }

        setRoute(route) {
            this.resetRoute();
            this.route = Object.assign({}, Object.assign({}, this.emptyRoute), route);

            this.configure();
            this.extractPlaceholders();
            this.buildPaths();
            this.buildRegexes();
        }

        configure() {
            this.route.path = Organizator.Routing._clearQueryString(Organizator.Routing._clearSlashes(this.route.path));
        }

        compile(route) {
            this.setRoute(route);

            var CompiledRoute = new Organizator_Routing_Route({
                name: this.route.name,
                path: this.route.path,
                paths: this.route.paths,
                isRegex: this.route.isRegex,
                regex: this.route.regex,
                regexes: this.route.regexes,
                subroutes: this.route.subroutes,
                placeholders: this.route.placeholders,
                controller: this.route.controller,
                defaults: this.route.defaults,
                requirements: this.route.requirements
            });

            return CompiledRoute;
        }

        extractPlaceholders() {
            var pattern = this.parameterPattern;
            var path = this.route.path;

            var placeholders = [], match;
            // very important to reset lastIndex since RegExp can have "g" flag
            // and multiple runs might affect the result, specially if matching
            // same string multiple times on IE 7-8
            pattern.lastIndex = 0;

            while (match = pattern.exec(path)) {
                placeholders.push(match[0]);
            }

            if (!placeholders) {
                this.route.isRegex = false;
            } else {
                this.route.isRegex = true;
                this.route.placeholders = placeholders;
            }
        }

        isRegex(path) {
            var pattern = this.parameterPattern;
            return new RegExp(pattern).test(path);
        }

        buildRegexes() {
            var subroutesLength = this.route.subroutes.length;

            if (!subroutesLength || !this.route.isRegex) {
                return;
            }

            for (var i = 0; i < subroutesLength; i++) {
                var regexedPath = this.buildRegexFromPath(this.route.subroutes[i].path);

                if (this.isRegex(this.route.subroutes[i].path)) {
                    this.route.subroutes[i].isRegex = true;
                    this.route.subroutes[i].regex = regexedPath;
                } else {
                    this.route.subroutes[i].isRegex = false;
                }

                if (i == 0) {
                    this.route.regex = regexedPath;
                }

                this.route.regexes.push(regexedPath);
            }
        }

        buildRegexFromPath(regexedPath) {
            for (var t = 0; t < this.route.placeholders.length; t++) {

                if (this.route.requirements[Organizator.Routing._clearBrackets(this.route.placeholders[t])] !== undefined) {
                    if (this.route.requirements[Organizator.Routing._clearBrackets(this.route.placeholders[t])] instanceof RegExp) {
                        var placeholderPattern = Organizator.Routing._clearRegexDelimiters(this.route.requirements[Organizator.Routing._clearBrackets(this.route.placeholders[t])].toString());
                    } else {
                        var placeholderPattern = this.route.requirements[Organizator.Routing._clearBrackets(this.route.placeholders[t])];
                    }
                } else {
                    var placeholderPattern = '.[^/]*';
                }

                regexedPath = regexedPath.replace(this.route.placeholders[t], '(' + placeholderPattern + ')');
            }

            return new RegExp('^' + regexedPath + '$');
        }

        buildPaths() {
            this.route.paths.push(this.route.path);
            this.route.subroutes.push({
                path: this.route.path,
                regex: this.buildRegexFromPath(this.route.path)
            });
            this.buildPathsWithDefaultValues();
        }

        /*
         * Build alternative paths if default values exist
         */
        buildPathsWithDefaultValues() {
            var defaults = this.route.defaults;
            var keysDefaults = Object.keys(defaults);
            var newPath = this.route.path;
            var defaultsBag = [];

            for (var i = 0; i < keysDefaults.length; i++) {
                var t = keysDefaults.length - (i + 1);
                var placeholder = '{' + keysDefaults[t] + '}';
                var placeholderValue = defaults[keysDefaults[t]];

                if (newPath.lastIndexOf(placeholder) + placeholder.length == newPath.length) {
                    var newPath = Organizator.Routing._clearSlashes(newPath.replace(placeholder, ''));

                    if (this.route.paths.indexOf(newPath) == -1) {
                        var subroute = {
                            path: newPath,
                            defaults: []
                        };

                        defaultsBag.push({
                            placeholder: keysDefaults[t],
                            value: placeholderValue
                        });

                        subroute.defaults = defaultsBag;

                        this.route.paths.push(newPath);
                        this.route.subroutes.push(subroute);
                    }
                }
            }
        }

//    buildPathsWithDefaultValuesRecursively(path, defaults){
//        var keysDefaults = Object.keys(defaults);
//        
//        for(var i = 0; i  < keysDefaults.length; i++){
//            var newPath = path.replace('{' + keysDefaults[i] + '}', defaults[keysDefaults[i]]);
//            
//            if(this.route.paths.indexOf(newPath) == -1){
//                this.route.paths.push(newPath);
//                this.route.subroutes
//            }                
//            
//            var restOf = Object.assign({}, defaults);
//            delete restOf[keysDefaults[i]];
//            
//            if(!Object.keys(restOf).length){continue;}
//            
//            this.buildPathsWithDefaultValuesRecursively(newPath, restOf);
//        }
//    }
    }
    
    return Organizator_Routing_RouteCompiler;
});
/*! https://mths.be/punycode v1.4.0 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', [],function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

define("urijs/src/punycode", function(){});

/*!
 * URI.js - Mutating URLs
 * IPv6 Support
 *
 * Version: 1.19.1
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */

(function (root, factory) {
  'use strict';
  // https://github.com/umdjs/umd/blob/master/returnExports.js
  if (typeof module === 'object' && module.exports) {
    // Node
    module.exports = factory();
  } else if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define('urijs/src/IPv6',factory);
  } else {
    // Browser globals (root is window)
    root.IPv6 = factory(root);
  }
}(this, function (root) {
  'use strict';

  /*
  var _in = "fe80:0000:0000:0000:0204:61ff:fe9d:f156";
  var _out = IPv6.best(_in);
  var _expected = "fe80::204:61ff:fe9d:f156";

  console.log(_in, _out, _expected, _out === _expected);
  */

  // save current IPv6 variable, if any
  var _IPv6 = root && root.IPv6;

  function bestPresentation(address) {
    // based on:
    // Javascript to test an IPv6 address for proper format, and to
    // present the "best text representation" according to IETF Draft RFC at
    // http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04
    // 8 Feb 2010 Rich Brown, Dartware, LLC
    // Please feel free to use this code as long as you provide a link to
    // http://www.intermapper.com
    // http://intermapper.com/support/tools/IPV6-Validator.aspx
    // http://download.dartware.com/thirdparty/ipv6validator.js

    var _address = address.toLowerCase();
    var segments = _address.split(':');
    var length = segments.length;
    var total = 8;

    // trim colons (:: or ::a:b:c… or …a:b:c::)
    if (segments[0] === '' && segments[1] === '' && segments[2] === '') {
      // must have been ::
      // remove first two items
      segments.shift();
      segments.shift();
    } else if (segments[0] === '' && segments[1] === '') {
      // must have been ::xxxx
      // remove the first item
      segments.shift();
    } else if (segments[length - 1] === '' && segments[length - 2] === '') {
      // must have been xxxx::
      segments.pop();
    }

    length = segments.length;

    // adjust total segments for IPv4 trailer
    if (segments[length - 1].indexOf('.') !== -1) {
      // found a "." which means IPv4
      total = 7;
    }

    // fill empty segments them with "0000"
    var pos;
    for (pos = 0; pos < length; pos++) {
      if (segments[pos] === '') {
        break;
      }
    }

    if (pos < total) {
      segments.splice(pos, 1, '0000');
      while (segments.length < total) {
        segments.splice(pos, 0, '0000');
      }
    }

    // strip leading zeros
    var _segments;
    for (var i = 0; i < total; i++) {
      _segments = segments[i].split('');
      for (var j = 0; j < 3 ; j++) {
        if (_segments[0] === '0' && _segments.length > 1) {
          _segments.splice(0,1);
        } else {
          break;
        }
      }

      segments[i] = _segments.join('');
    }

    // find longest sequence of zeroes and coalesce them into one segment
    var best = -1;
    var _best = 0;
    var _current = 0;
    var current = -1;
    var inzeroes = false;
    // i; already declared

    for (i = 0; i < total; i++) {
      if (inzeroes) {
        if (segments[i] === '0') {
          _current += 1;
        } else {
          inzeroes = false;
          if (_current > _best) {
            best = current;
            _best = _current;
          }
        }
      } else {
        if (segments[i] === '0') {
          inzeroes = true;
          current = i;
          _current = 1;
        }
      }
    }

    if (_current > _best) {
      best = current;
      _best = _current;
    }

    if (_best > 1) {
      segments.splice(best, _best, '');
    }

    length = segments.length;

    // assemble remaining segments
    var result = '';
    if (segments[0] === '')  {
      result = ':';
    }

    for (i = 0; i < length; i++) {
      result += segments[i];
      if (i === length - 1) {
        break;
      }

      result += ':';
    }

    if (segments[length - 1] === '') {
      result += ':';
    }

    return result;
  }

  function noConflict() {
    /*jshint validthis: true */
    if (root.IPv6 === this) {
      root.IPv6 = _IPv6;
    }

    return this;
  }

  return {
    best: bestPresentation,
    noConflict: noConflict
  };
}));

/*!
 * URI.js - Mutating URLs
 * Second Level Domain (SLD) Support
 *
 * Version: 1.19.1
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */

(function (root, factory) {
  'use strict';
  // https://github.com/umdjs/umd/blob/master/returnExports.js
  if (typeof module === 'object' && module.exports) {
    // Node
    module.exports = factory();
  } else if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define('urijs/src/SecondLevelDomains',factory);
  } else {
    // Browser globals (root is window)
    root.SecondLevelDomains = factory(root);
  }
}(this, function (root) {
  'use strict';

  // save current SecondLevelDomains variable, if any
  var _SecondLevelDomains = root && root.SecondLevelDomains;

  var SLD = {
    // list of known Second Level Domains
    // converted list of SLDs from https://github.com/gavingmiller/second-level-domains
    // ----
    // publicsuffix.org is more current and actually used by a couple of browsers internally.
    // downside is it also contains domains like "dyndns.org" - which is fine for the security
    // issues browser have to deal with (SOP for cookies, etc) - but is way overboard for URI.js
    // ----
    list: {
      'ac':' com gov mil net org ',
      'ae':' ac co gov mil name net org pro sch ',
      'af':' com edu gov net org ',
      'al':' com edu gov mil net org ',
      'ao':' co ed gv it og pb ',
      'ar':' com edu gob gov int mil net org tur ',
      'at':' ac co gv or ',
      'au':' asn com csiro edu gov id net org ',
      'ba':' co com edu gov mil net org rs unbi unmo unsa untz unze ',
      'bb':' biz co com edu gov info net org store tv ',
      'bh':' biz cc com edu gov info net org ',
      'bn':' com edu gov net org ',
      'bo':' com edu gob gov int mil net org tv ',
      'br':' adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ',
      'bs':' com edu gov net org ',
      'bz':' du et om ov rg ',
      'ca':' ab bc mb nb nf nl ns nt nu on pe qc sk yk ',
      'ck':' biz co edu gen gov info net org ',
      'cn':' ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ',
      'co':' com edu gov mil net nom org ',
      'cr':' ac c co ed fi go or sa ',
      'cy':' ac biz com ekloges gov ltd name net org parliament press pro tm ',
      'do':' art com edu gob gov mil net org sld web ',
      'dz':' art asso com edu gov net org pol ',
      'ec':' com edu fin gov info med mil net org pro ',
      'eg':' com edu eun gov mil name net org sci ',
      'er':' com edu gov ind mil net org rochest w ',
      'es':' com edu gob nom org ',
      'et':' biz com edu gov info name net org ',
      'fj':' ac biz com info mil name net org pro ',
      'fk':' ac co gov net nom org ',
      'fr':' asso com f gouv nom prd presse tm ',
      'gg':' co net org ',
      'gh':' com edu gov mil org ',
      'gn':' ac com gov net org ',
      'gr':' com edu gov mil net org ',
      'gt':' com edu gob ind mil net org ',
      'gu':' com edu gov net org ',
      'hk':' com edu gov idv net org ',
      'hu':' 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ',
      'id':' ac co go mil net or sch web ',
      'il':' ac co gov idf k12 muni net org ',
      'in':' ac co edu ernet firm gen gov i ind mil net nic org res ',
      'iq':' com edu gov i mil net org ',
      'ir':' ac co dnssec gov i id net org sch ',
      'it':' edu gov ',
      'je':' co net org ',
      'jo':' com edu gov mil name net org sch ',
      'jp':' ac ad co ed go gr lg ne or ',
      'ke':' ac co go info me mobi ne or sc ',
      'kh':' com edu gov mil net org per ',
      'ki':' biz com de edu gov info mob net org tel ',
      'km':' asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ',
      'kn':' edu gov net org ',
      'kr':' ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ',
      'kw':' com edu gov net org ',
      'ky':' com edu gov net org ',
      'kz':' com edu gov mil net org ',
      'lb':' com edu gov net org ',
      'lk':' assn com edu gov grp hotel int ltd net ngo org sch soc web ',
      'lr':' com edu gov net org ',
      'lv':' asn com conf edu gov id mil net org ',
      'ly':' com edu gov id med net org plc sch ',
      'ma':' ac co gov m net org press ',
      'mc':' asso tm ',
      'me':' ac co edu gov its net org priv ',
      'mg':' com edu gov mil nom org prd tm ',
      'mk':' com edu gov inf name net org pro ',
      'ml':' com edu gov net org presse ',
      'mn':' edu gov org ',
      'mo':' com edu gov net org ',
      'mt':' com edu gov net org ',
      'mv':' aero biz com coop edu gov info int mil museum name net org pro ',
      'mw':' ac co com coop edu gov int museum net org ',
      'mx':' com edu gob net org ',
      'my':' com edu gov mil name net org sch ',
      'nf':' arts com firm info net other per rec store web ',
      'ng':' biz com edu gov mil mobi name net org sch ',
      'ni':' ac co com edu gob mil net nom org ',
      'np':' com edu gov mil net org ',
      'nr':' biz com edu gov info net org ',
      'om':' ac biz co com edu gov med mil museum net org pro sch ',
      'pe':' com edu gob mil net nom org sld ',
      'ph':' com edu gov i mil net ngo org ',
      'pk':' biz com edu fam gob gok gon gop gos gov net org web ',
      'pl':' art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ',
      'pr':' ac biz com edu est gov info isla name net org pro prof ',
      'ps':' com edu gov net org plo sec ',
      'pw':' belau co ed go ne or ',
      'ro':' arts com firm info nom nt org rec store tm www ',
      'rs':' ac co edu gov in org ',
      'sb':' com edu gov net org ',
      'sc':' com edu gov net org ',
      'sh':' co com edu gov net nom org ',
      'sl':' com edu gov net org ',
      'st':' co com consulado edu embaixada gov mil net org principe saotome store ',
      'sv':' com edu gob org red ',
      'sz':' ac co org ',
      'tr':' av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ',
      'tt':' aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ',
      'tw':' club com ebiz edu game gov idv mil net org ',
      'mu':' ac co com gov net or org ',
      'mz':' ac co edu gov org ',
      'na':' co com ',
      'nz':' ac co cri geek gen govt health iwi maori mil net org parliament school ',
      'pa':' abo ac com edu gob ing med net nom org sld ',
      'pt':' com edu gov int net nome org publ ',
      'py':' com edu gov mil net org ',
      'qa':' com edu gov mil net org ',
      're':' asso com nom ',
      'ru':' ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ',
      'rw':' ac co com edu gouv gov int mil net ',
      'sa':' com edu gov med net org pub sch ',
      'sd':' com edu gov info med net org tv ',
      'se':' a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ',
      'sg':' com edu gov idn net org per ',
      'sn':' art com edu gouv org perso univ ',
      'sy':' com edu gov mil net news org ',
      'th':' ac co go in mi net or ',
      'tj':' ac biz co com edu go gov info int mil name net nic org test web ',
      'tn':' agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ',
      'tz':' ac co go ne or ',
      'ua':' biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ',
      'ug':' ac co go ne or org sc ',
      'uk':' ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ',
      'us':' dni fed isa kids nsn ',
      'uy':' com edu gub mil net org ',
      've':' co com edu gob info mil net org web ',
      'vi':' co com k12 net org ',
      'vn':' ac biz com edu gov health info int name net org pro ',
      'ye':' co com gov ltd me net org plc ',
      'yu':' ac co edu gov org ',
      'za':' ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ',
      'zm':' ac co com edu gov net org sch ',
      // https://en.wikipedia.org/wiki/CentralNic#Second-level_domains
      'com': 'ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ',
      'net': 'gb jp se uk ',
      'org': 'ae',
      'de': 'com '
    },
    // gorhill 2013-10-25: Using indexOf() instead Regexp(). Significant boost
    // in both performance and memory footprint. No initialization required.
    // http://jsperf.com/uri-js-sld-regex-vs-binary-search/4
    // Following methods use lastIndexOf() rather than array.split() in order
    // to avoid any memory allocations.
    has: function(domain) {
      var tldOffset = domain.lastIndexOf('.');
      if (tldOffset <= 0 || tldOffset >= (domain.length-1)) {
        return false;
      }
      var sldOffset = domain.lastIndexOf('.', tldOffset-1);
      if (sldOffset <= 0 || sldOffset >= (tldOffset-1)) {
        return false;
      }
      var sldList = SLD.list[domain.slice(tldOffset+1)];
      if (!sldList) {
        return false;
      }
      return sldList.indexOf(' ' + domain.slice(sldOffset+1, tldOffset) + ' ') >= 0;
    },
    is: function(domain) {
      var tldOffset = domain.lastIndexOf('.');
      if (tldOffset <= 0 || tldOffset >= (domain.length-1)) {
        return false;
      }
      var sldOffset = domain.lastIndexOf('.', tldOffset-1);
      if (sldOffset >= 0) {
        return false;
      }
      var sldList = SLD.list[domain.slice(tldOffset+1)];
      if (!sldList) {
        return false;
      }
      return sldList.indexOf(' ' + domain.slice(0, tldOffset) + ' ') >= 0;
    },
    get: function(domain) {
      var tldOffset = domain.lastIndexOf('.');
      if (tldOffset <= 0 || tldOffset >= (domain.length-1)) {
        return null;
      }
      var sldOffset = domain.lastIndexOf('.', tldOffset-1);
      if (sldOffset <= 0 || sldOffset >= (tldOffset-1)) {
        return null;
      }
      var sldList = SLD.list[domain.slice(tldOffset+1)];
      if (!sldList) {
        return null;
      }
      if (sldList.indexOf(' ' + domain.slice(sldOffset+1, tldOffset) + ' ') < 0) {
        return null;
      }
      return domain.slice(sldOffset+1);
    },
    noConflict: function(){
      if (root.SecondLevelDomains === this) {
        root.SecondLevelDomains = _SecondLevelDomains;
      }
      return this;
    }
  };

  return SLD;
}));

/*!
 * URI.js - Mutating URLs
 *
 * Version: 1.19.1
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *
 */
(function (root, factory) {
  'use strict';
  // https://github.com/umdjs/umd/blob/master/returnExports.js
  if (typeof module === 'object' && module.exports) {
    // Node
    module.exports = factory(require('./punycode'), require('./IPv6'), require('./SecondLevelDomains'));
  } else if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define('urijs/src/URI',['./punycode', './IPv6', './SecondLevelDomains'], factory);
  } else {
    // Browser globals (root is window)
    root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
  }
}(this, function (punycode, IPv6, SLD, root) {
  'use strict';
  /*global location, escape, unescape */
  // FIXME: v2.0.0 renamce non-camelCase properties to uppercase
  /*jshint camelcase: false */

  // save current URI variable, if any
  var _URI = root && root.URI;

  function URI(url, base) {
    var _urlSupplied = arguments.length >= 1;
    var _baseSupplied = arguments.length >= 2;

    // Allow instantiation without the 'new' keyword
    if (!(this instanceof URI)) {
      if (_urlSupplied) {
        if (_baseSupplied) {
          return new URI(url, base);
        }

        return new URI(url);
      }

      return new URI();
    }

    if (url === undefined) {
      if (_urlSupplied) {
        throw new TypeError('undefined is not a valid argument for URI');
      }

      if (typeof location !== 'undefined') {
        url = location.href + '';
      } else {
        url = '';
      }
    }

    if (url === null) {
      if (_urlSupplied) {
        throw new TypeError('null is not a valid argument for URI');
      }
    }

    this.href(url);

    // resolve to base according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#constructor
    if (base !== undefined) {
      return this.absoluteTo(base);
    }

    return this;
  }

  function isInteger(value) {
    return /^[0-9]+$/.test(value);
  }

  URI.version = '1.19.1';

  var p = URI.prototype;
  var hasOwn = Object.prototype.hasOwnProperty;

  function escapeRegEx(string) {
    // https://github.com/medialize/URI.js/commit/85ac21783c11f8ccab06106dba9735a31a86924d#commitcomment-821963
    return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
  }

  function getType(value) {
    // IE8 doesn't return [Object Undefined] but [Object Object] for undefined value
    if (value === undefined) {
      return 'Undefined';
    }

    return String(Object.prototype.toString.call(value)).slice(8, -1);
  }

  function isArray(obj) {
    return getType(obj) === 'Array';
  }

  function filterArrayValues(data, value) {
    var lookup = {};
    var i, length;

    if (getType(value) === 'RegExp') {
      lookup = null;
    } else if (isArray(value)) {
      for (i = 0, length = value.length; i < length; i++) {
        lookup[value[i]] = true;
      }
    } else {
      lookup[value] = true;
    }

    for (i = 0, length = data.length; i < length; i++) {
      /*jshint laxbreak: true */
      var _match = lookup && lookup[data[i]] !== undefined
        || !lookup && value.test(data[i]);
      /*jshint laxbreak: false */
      if (_match) {
        data.splice(i, 1);
        length--;
        i--;
      }
    }

    return data;
  }

  function arrayContains(list, value) {
    var i, length;

    // value may be string, number, array, regexp
    if (isArray(value)) {
      // Note: this can be optimized to O(n) (instead of current O(m * n))
      for (i = 0, length = value.length; i < length; i++) {
        if (!arrayContains(list, value[i])) {
          return false;
        }
      }

      return true;
    }

    var _type = getType(value);
    for (i = 0, length = list.length; i < length; i++) {
      if (_type === 'RegExp') {
        if (typeof list[i] === 'string' && list[i].match(value)) {
          return true;
        }
      } else if (list[i] === value) {
        return true;
      }
    }

    return false;
  }

  function arraysEqual(one, two) {
    if (!isArray(one) || !isArray(two)) {
      return false;
    }

    // arrays can't be equal if they have different amount of content
    if (one.length !== two.length) {
      return false;
    }

    one.sort();
    two.sort();

    for (var i = 0, l = one.length; i < l; i++) {
      if (one[i] !== two[i]) {
        return false;
      }
    }

    return true;
  }

  function trimSlashes(text) {
    var trim_expression = /^\/+|\/+$/g;
    return text.replace(trim_expression, '');
  }

  URI._parts = function() {
    return {
      protocol: null,
      username: null,
      password: null,
      hostname: null,
      urn: null,
      port: null,
      path: null,
      query: null,
      fragment: null,
      // state
      preventInvalidHostname: URI.preventInvalidHostname,
      duplicateQueryParameters: URI.duplicateQueryParameters,
      escapeQuerySpace: URI.escapeQuerySpace
    };
  };
  // state: throw on invalid hostname
  // see https://github.com/medialize/URI.js/pull/345
  // and https://github.com/medialize/URI.js/issues/354
  URI.preventInvalidHostname = false;
  // state: allow duplicate query parameters (a=1&a=1)
  URI.duplicateQueryParameters = false;
  // state: replaces + with %20 (space in query strings)
  URI.escapeQuerySpace = true;
  // static properties
  URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
  URI.idn_expression = /[^a-z0-9\._-]/i;
  URI.punycode_expression = /(xn--)/i;
  // well, 333.444.555.666 matches, but it sure ain't no IPv4 - do we care?
  URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
  // credits to Rich Brown
  // source: http://forums.intermapper.com/viewtopic.php?p=1096#1096
  // specification: http://www.ietf.org/rfc/rfc4291.txt
  URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
  // expression used is "gruber revised" (@gruber v2) determined to be the
  // best solution in a regex-golf we did a couple of ages ago at
  // * http://mathiasbynens.be/demo/url-regex
  // * http://rodneyrehm.de/t/url-regex.html
  URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/ig;
  URI.findUri = {
    // valid "scheme://" or "www."
    start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
    // everything up to the next whitespace
    end: /[\s\r\n]|$/,
    // trim trailing punctuation captured by end RegExp
    trim: /[`!()\[\]{};:'".,<>?«»“”„‘’]+$/,
    // balanced parens inclusion (), [], {}, <>
    parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g,
  };
  // http://www.iana.org/assignments/uri-schemes.html
  // http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports
  URI.defaultPorts = {
    http: '80',
    https: '443',
    ftp: '21',
    gopher: '70',
    ws: '80',
    wss: '443'
  };
  // list of protocols which always require a hostname
  URI.hostProtocols = [
    'http',
    'https'
  ];

  // allowed hostname characters according to RFC 3986
  // ALPHA DIGIT "-" "." "_" "~" "!" "$" "&" "'" "(" ")" "*" "+" "," ";" "=" %encoded
  // I've never seen a (non-IDN) hostname other than: ALPHA DIGIT . - _
  URI.invalid_hostname_characters = /[^a-zA-Z0-9\.\-:_]/;
  // map DOM Elements to their URI attribute
  URI.domAttributes = {
    'a': 'href',
    'blockquote': 'cite',
    'link': 'href',
    'base': 'href',
    'script': 'src',
    'form': 'action',
    'img': 'src',
    'area': 'href',
    'iframe': 'src',
    'embed': 'src',
    'source': 'src',
    'track': 'src',
    'input': 'src', // but only if type="image"
    'audio': 'src',
    'video': 'src'
  };
  URI.getDomAttribute = function(node) {
    if (!node || !node.nodeName) {
      return undefined;
    }

    var nodeName = node.nodeName.toLowerCase();
    // <input> should only expose src for type="image"
    if (nodeName === 'input' && node.type !== 'image') {
      return undefined;
    }

    return URI.domAttributes[nodeName];
  };

  function escapeForDumbFirefox36(value) {
    // https://github.com/medialize/URI.js/issues/91
    return escape(value);
  }

  // encoding / decoding according to RFC3986
  function strictEncodeURIComponent(string) {
    // see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURIComponent
    return encodeURIComponent(string)
      .replace(/[!'()*]/g, escapeForDumbFirefox36)
      .replace(/\*/g, '%2A');
  }
  URI.encode = strictEncodeURIComponent;
  URI.decode = decodeURIComponent;
  URI.iso8859 = function() {
    URI.encode = escape;
    URI.decode = unescape;
  };
  URI.unicode = function() {
    URI.encode = strictEncodeURIComponent;
    URI.decode = decodeURIComponent;
  };
  URI.characters = {
    pathname: {
      encode: {
        // RFC3986 2.1: For consistency, URI producers and normalizers should
        // use uppercase hexadecimal digits for all percent-encodings.
        expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
        map: {
          // -._~!'()*
          '%24': '$',
          '%26': '&',
          '%2B': '+',
          '%2C': ',',
          '%3B': ';',
          '%3D': '=',
          '%3A': ':',
          '%40': '@'
        }
      },
      decode: {
        expression: /[\/\?#]/g,
        map: {
          '/': '%2F',
          '?': '%3F',
          '#': '%23'
        }
      }
    },
    reserved: {
      encode: {
        // RFC3986 2.1: For consistency, URI producers and normalizers should
        // use uppercase hexadecimal digits for all percent-encodings.
        expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
        map: {
          // gen-delims
          '%3A': ':',
          '%2F': '/',
          '%3F': '?',
          '%23': '#',
          '%5B': '[',
          '%5D': ']',
          '%40': '@',
          // sub-delims
          '%21': '!',
          '%24': '$',
          '%26': '&',
          '%27': '\'',
          '%28': '(',
          '%29': ')',
          '%2A': '*',
          '%2B': '+',
          '%2C': ',',
          '%3B': ';',
          '%3D': '='
        }
      }
    },
    urnpath: {
      // The characters under `encode` are the characters called out by RFC 2141 as being acceptable
      // for usage in a URN. RFC2141 also calls out "-", ".", and "_" as acceptable characters, but
      // these aren't encoded by encodeURIComponent, so we don't have to call them out here. Also
      // note that the colon character is not featured in the encoding map; this is because URI.js
      // gives the colons in URNs semantic meaning as the delimiters of path segements, and so it
      // should not appear unencoded in a segment itself.
      // See also the note above about RFC3986 and capitalalized hex digits.
      encode: {
        expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
        map: {
          '%21': '!',
          '%24': '$',
          '%27': '\'',
          '%28': '(',
          '%29': ')',
          '%2A': '*',
          '%2B': '+',
          '%2C': ',',
          '%3B': ';',
          '%3D': '=',
          '%40': '@'
        }
      },
      // These characters are the characters called out by RFC2141 as "reserved" characters that
      // should never appear in a URN, plus the colon character (see note above).
      decode: {
        expression: /[\/\?#:]/g,
        map: {
          '/': '%2F',
          '?': '%3F',
          '#': '%23',
          ':': '%3A'
        }
      }
    }
  };
  URI.encodeQuery = function(string, escapeQuerySpace) {
    var escaped = URI.encode(string + '');
    if (escapeQuerySpace === undefined) {
      escapeQuerySpace = URI.escapeQuerySpace;
    }

    return escapeQuerySpace ? escaped.replace(/%20/g, '+') : escaped;
  };
  URI.decodeQuery = function(string, escapeQuerySpace) {
    string += '';
    if (escapeQuerySpace === undefined) {
      escapeQuerySpace = URI.escapeQuerySpace;
    }

    try {
      return URI.decode(escapeQuerySpace ? string.replace(/\+/g, '%20') : string);
    } catch(e) {
      // we're not going to mess with weird encodings,
      // give up and return the undecoded original string
      // see https://github.com/medialize/URI.js/issues/87
      // see https://github.com/medialize/URI.js/issues/92
      return string;
    }
  };
  // generate encode/decode path functions
  var _parts = {'encode':'encode', 'decode':'decode'};
  var _part;
  var generateAccessor = function(_group, _part) {
    return function(string) {
      try {
        return URI[_part](string + '').replace(URI.characters[_group][_part].expression, function(c) {
          return URI.characters[_group][_part].map[c];
        });
      } catch (e) {
        // we're not going to mess with weird encodings,
        // give up and return the undecoded original string
        // see https://github.com/medialize/URI.js/issues/87
        // see https://github.com/medialize/URI.js/issues/92
        return string;
      }
    };
  };

  for (_part in _parts) {
    URI[_part + 'PathSegment'] = generateAccessor('pathname', _parts[_part]);
    URI[_part + 'UrnPathSegment'] = generateAccessor('urnpath', _parts[_part]);
  }

  var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {
    return function(string) {
      // Why pass in names of functions, rather than the function objects themselves? The
      // definitions of some functions (but in particular, URI.decode) will occasionally change due
      // to URI.js having ISO8859 and Unicode modes. Passing in the name and getting it will ensure
      // that the functions we use here are "fresh".
      var actualCodingFunc;
      if (!_innerCodingFuncName) {
        actualCodingFunc = URI[_codingFuncName];
      } else {
        actualCodingFunc = function(string) {
          return URI[_codingFuncName](URI[_innerCodingFuncName](string));
        };
      }

      var segments = (string + '').split(_sep);

      for (var i = 0, length = segments.length; i < length; i++) {
        segments[i] = actualCodingFunc(segments[i]);
      }

      return segments.join(_sep);
    };
  };

  // This takes place outside the above loop because we don't want, e.g., encodeUrnPath functions.
  URI.decodePath = generateSegmentedPathFunction('/', 'decodePathSegment');
  URI.decodeUrnPath = generateSegmentedPathFunction(':', 'decodeUrnPathSegment');
  URI.recodePath = generateSegmentedPathFunction('/', 'encodePathSegment', 'decode');
  URI.recodeUrnPath = generateSegmentedPathFunction(':', 'encodeUrnPathSegment', 'decode');

  URI.encodeReserved = generateAccessor('reserved', 'encode');

  URI.parse = function(string, parts) {
    var pos;
    if (!parts) {
      parts = {
        preventInvalidHostname: URI.preventInvalidHostname
      };
    }
    // [protocol"://"[username[":"password]"@"]hostname[":"port]"/"?][path]["?"querystring]["#"fragment]

    // extract fragment
    pos = string.indexOf('#');
    if (pos > -1) {
      // escaping?
      parts.fragment = string.substring(pos + 1) || null;
      string = string.substring(0, pos);
    }

    // extract query
    pos = string.indexOf('?');
    if (pos > -1) {
      // escaping?
      parts.query = string.substring(pos + 1) || null;
      string = string.substring(0, pos);
    }

    // extract protocol
    if (string.substring(0, 2) === '//') {
      // relative-scheme
      parts.protocol = null;
      string = string.substring(2);
      // extract "user:pass@host:port"
      string = URI.parseAuthority(string, parts);
    } else {
      pos = string.indexOf(':');
      if (pos > -1) {
        parts.protocol = string.substring(0, pos) || null;
        if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {
          // : may be within the path
          parts.protocol = undefined;
        } else if (string.substring(pos + 1, pos + 3) === '//') {
          string = string.substring(pos + 3);

          // extract "user:pass@host:port"
          string = URI.parseAuthority(string, parts);
        } else {
          string = string.substring(pos + 1);
          parts.urn = true;
        }
      }
    }

    // what's left must be the path
    parts.path = string;

    // and we're done
    return parts;
  };
  URI.parseHost = function(string, parts) {
    if (!string) {
      string = '';
    }

    // Copy chrome, IE, opera backslash-handling behavior.
    // Back slashes before the query string get converted to forward slashes
    // See: https://github.com/joyent/node/blob/386fd24f49b0e9d1a8a076592a404168faeecc34/lib/url.js#L115-L124
    // See: https://code.google.com/p/chromium/issues/detail?id=25916
    // https://github.com/medialize/URI.js/pull/233
    string = string.replace(/\\/g, '/');

    // extract host:port
    var pos = string.indexOf('/');
    var bracketPos;
    var t;

    if (pos === -1) {
      pos = string.length;
    }

    if (string.charAt(0) === '[') {
      // IPv6 host - http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04#section-6
      // I claim most client software breaks on IPv6 anyways. To simplify things, URI only accepts
      // IPv6+port in the format [2001:db8::1]:80 (for the time being)
      bracketPos = string.indexOf(']');
      parts.hostname = string.substring(1, bracketPos) || null;
      parts.port = string.substring(bracketPos + 2, pos) || null;
      if (parts.port === '/') {
        parts.port = null;
      }
    } else {
      var firstColon = string.indexOf(':');
      var firstSlash = string.indexOf('/');
      var nextColon = string.indexOf(':', firstColon + 1);
      if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {
        // IPv6 host contains multiple colons - but no port
        // this notation is actually not allowed by RFC 3986, but we're a liberal parser
        parts.hostname = string.substring(0, pos) || null;
        parts.port = null;
      } else {
        t = string.substring(0, pos).split(':');
        parts.hostname = t[0] || null;
        parts.port = t[1] || null;
      }
    }

    if (parts.hostname && string.substring(pos).charAt(0) !== '/') {
      pos++;
      string = '/' + string;
    }

    if (parts.preventInvalidHostname) {
      URI.ensureValidHostname(parts.hostname, parts.protocol);
    }

    if (parts.port) {
      URI.ensureValidPort(parts.port);
    }

    return string.substring(pos) || '/';
  };
  URI.parseAuthority = function(string, parts) {
    string = URI.parseUserinfo(string, parts);
    return URI.parseHost(string, parts);
  };
  URI.parseUserinfo = function(string, parts) {
    // extract username:password
    var firstSlash = string.indexOf('/');
    var pos = string.lastIndexOf('@', firstSlash > -1 ? firstSlash : string.length - 1);
    var t;

    // authority@ must come before /path
    if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
      t = string.substring(0, pos).split(':');
      parts.username = t[0] ? URI.decode(t[0]) : null;
      t.shift();
      parts.password = t[0] ? URI.decode(t.join(':')) : null;
      string = string.substring(pos + 1);
    } else {
      parts.username = null;
      parts.password = null;
    }

    return string;
  };
  URI.parseQuery = function(string, escapeQuerySpace) {
    if (!string) {
      return {};
    }

    // throw out the funky business - "?"[name"="value"&"]+
    string = string.replace(/&+/g, '&').replace(/^\?*&*|&+$/g, '');

    if (!string) {
      return {};
    }

    var items = {};
    var splits = string.split('&');
    var length = splits.length;
    var v, name, value;

    for (var i = 0; i < length; i++) {
      v = splits[i].split('=');
      name = URI.decodeQuery(v.shift(), escapeQuerySpace);
      // no "=" is null according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#collect-url-parameters
      value = v.length ? URI.decodeQuery(v.join('='), escapeQuerySpace) : null;

      if (hasOwn.call(items, name)) {
        if (typeof items[name] === 'string' || items[name] === null) {
          items[name] = [items[name]];
        }

        items[name].push(value);
      } else {
        items[name] = value;
      }
    }

    return items;
  };

  URI.build = function(parts) {
    var t = '';

    if (parts.protocol) {
      t += parts.protocol + ':';
    }

    if (!parts.urn && (t || parts.hostname)) {
      t += '//';
    }

    t += (URI.buildAuthority(parts) || '');

    if (typeof parts.path === 'string') {
      if (parts.path.charAt(0) !== '/' && typeof parts.hostname === 'string') {
        t += '/';
      }

      t += parts.path;
    }

    if (typeof parts.query === 'string' && parts.query) {
      t += '?' + parts.query;
    }

    if (typeof parts.fragment === 'string' && parts.fragment) {
      t += '#' + parts.fragment;
    }
    return t;
  };
  URI.buildHost = function(parts) {
    var t = '';

    if (!parts.hostname) {
      return '';
    } else if (URI.ip6_expression.test(parts.hostname)) {
      t += '[' + parts.hostname + ']';
    } else {
      t += parts.hostname;
    }

    if (parts.port) {
      t += ':' + parts.port;
    }

    return t;
  };
  URI.buildAuthority = function(parts) {
    return URI.buildUserinfo(parts) + URI.buildHost(parts);
  };
  URI.buildUserinfo = function(parts) {
    var t = '';

    if (parts.username) {
      t += URI.encode(parts.username);
    }

    if (parts.password) {
      t += ':' + URI.encode(parts.password);
    }

    if (t) {
      t += '@';
    }

    return t;
  };
  URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
    // according to http://tools.ietf.org/html/rfc3986 or http://labs.apache.org/webarch/uri/rfc/rfc3986.html
    // being »-._~!$&'()*+,;=:@/?« %HEX and alnum are allowed
    // the RFC explicitly states ?/foo being a valid use case, no mention of parameter syntax!
    // URI.js treats the query string as being application/x-www-form-urlencoded
    // see http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type

    var t = '';
    var unique, key, i, length;
    for (key in data) {
      if (hasOwn.call(data, key) && key) {
        if (isArray(data[key])) {
          unique = {};
          for (i = 0, length = data[key].length; i < length; i++) {
            if (data[key][i] !== undefined && unique[data[key][i] + ''] === undefined) {
              t += '&' + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);
              if (duplicateQueryParameters !== true) {
                unique[data[key][i] + ''] = true;
              }
            }
          }
        } else if (data[key] !== undefined) {
          t += '&' + URI.buildQueryParameter(key, data[key], escapeQuerySpace);
        }
      }
    }

    return t.substring(1);
  };
  URI.buildQueryParameter = function(name, value, escapeQuerySpace) {
    // http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type -- application/x-www-form-urlencoded
    // don't append "=" for null values, according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#url-parameter-serialization
    return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? '=' + URI.encodeQuery(value, escapeQuerySpace) : '');
  };

  URI.addQuery = function(data, name, value) {
    if (typeof name === 'object') {
      for (var key in name) {
        if (hasOwn.call(name, key)) {
          URI.addQuery(data, key, name[key]);
        }
      }
    } else if (typeof name === 'string') {
      if (data[name] === undefined) {
        data[name] = value;
        return;
      } else if (typeof data[name] === 'string') {
        data[name] = [data[name]];
      }

      if (!isArray(value)) {
        value = [value];
      }

      data[name] = (data[name] || []).concat(value);
    } else {
      throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
    }
  };

  URI.setQuery = function(data, name, value) {
    if (typeof name === 'object') {
      for (var key in name) {
        if (hasOwn.call(name, key)) {
          URI.setQuery(data, key, name[key]);
        }
      }
    } else if (typeof name === 'string') {
      data[name] = value === undefined ? null : value;
    } else {
      throw new TypeError('URI.setQuery() accepts an object, string as the name parameter');
    }
  };

  URI.removeQuery = function(data, name, value) {
    var i, length, key;

    if (isArray(name)) {
      for (i = 0, length = name.length; i < length; i++) {
        data[name[i]] = undefined;
      }
    } else if (getType(name) === 'RegExp') {
      for (key in data) {
        if (name.test(key)) {
          data[key] = undefined;
        }
      }
    } else if (typeof name === 'object') {
      for (key in name) {
        if (hasOwn.call(name, key)) {
          URI.removeQuery(data, key, name[key]);
        }
      }
    } else if (typeof name === 'string') {
      if (value !== undefined) {
        if (getType(value) === 'RegExp') {
          if (!isArray(data[name]) && value.test(data[name])) {
            data[name] = undefined;
          } else {
            data[name] = filterArrayValues(data[name], value);
          }
        } else if (data[name] === String(value) && (!isArray(value) || value.length === 1)) {
          data[name] = undefined;
        } else if (isArray(data[name])) {
          data[name] = filterArrayValues(data[name], value);
        }
      } else {
        data[name] = undefined;
      }
    } else {
      throw new TypeError('URI.removeQuery() accepts an object, string, RegExp as the first parameter');
    }
  };
  URI.hasQuery = function(data, name, value, withinArray) {
    switch (getType(name)) {
      case 'String':
        // Nothing to do here
        break;

      case 'RegExp':
        for (var key in data) {
          if (hasOwn.call(data, key)) {
            if (name.test(key) && (value === undefined || URI.hasQuery(data, key, value))) {
              return true;
            }
          }
        }

        return false;

      case 'Object':
        for (var _key in name) {
          if (hasOwn.call(name, _key)) {
            if (!URI.hasQuery(data, _key, name[_key])) {
              return false;
            }
          }
        }

        return true;

      default:
        throw new TypeError('URI.hasQuery() accepts a string, regular expression or object as the name parameter');
    }

    switch (getType(value)) {
      case 'Undefined':
        // true if exists (but may be empty)
        return name in data; // data[name] !== undefined;

      case 'Boolean':
        // true if exists and non-empty
        var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);
        return value === _booly;

      case 'Function':
        // allow complex comparison
        return !!value(data[name], name, data);

      case 'Array':
        if (!isArray(data[name])) {
          return false;
        }

        var op = withinArray ? arrayContains : arraysEqual;
        return op(data[name], value);

      case 'RegExp':
        if (!isArray(data[name])) {
          return Boolean(data[name] && data[name].match(value));
        }

        if (!withinArray) {
          return false;
        }

        return arrayContains(data[name], value);

      case 'Number':
        value = String(value);
        /* falls through */
      case 'String':
        if (!isArray(data[name])) {
          return data[name] === value;
        }

        if (!withinArray) {
          return false;
        }

        return arrayContains(data[name], value);

      default:
        throw new TypeError('URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter');
    }
  };


  URI.joinPaths = function() {
    var input = [];
    var segments = [];
    var nonEmptySegments = 0;

    for (var i = 0; i < arguments.length; i++) {
      var url = new URI(arguments[i]);
      input.push(url);
      var _segments = url.segment();
      for (var s = 0; s < _segments.length; s++) {
        if (typeof _segments[s] === 'string') {
          segments.push(_segments[s]);
        }

        if (_segments[s]) {
          nonEmptySegments++;
        }
      }
    }

    if (!segments.length || !nonEmptySegments) {
      return new URI('');
    }

    var uri = new URI('').segment(segments);

    if (input[0].path() === '' || input[0].path().slice(0, 1) === '/') {
      uri.path('/' + uri.path());
    }

    return uri.normalize();
  };

  URI.commonPath = function(one, two) {
    var length = Math.min(one.length, two.length);
    var pos;

    // find first non-matching character
    for (pos = 0; pos < length; pos++) {
      if (one.charAt(pos) !== two.charAt(pos)) {
        pos--;
        break;
      }
    }

    if (pos < 1) {
      return one.charAt(0) === two.charAt(0) && one.charAt(0) === '/' ? '/' : '';
    }

    // revert to last /
    if (one.charAt(pos) !== '/' || two.charAt(pos) !== '/') {
      pos = one.substring(0, pos).lastIndexOf('/');
    }

    return one.substring(0, pos + 1);
  };

  URI.withinString = function(string, callback, options) {
    options || (options = {});
    var _start = options.start || URI.findUri.start;
    var _end = options.end || URI.findUri.end;
    var _trim = options.trim || URI.findUri.trim;
    var _parens = options.parens || URI.findUri.parens;
    var _attributeOpen = /[a-z0-9-]=["']?$/i;

    _start.lastIndex = 0;
    while (true) {
      var match = _start.exec(string);
      if (!match) {
        break;
      }

      var start = match.index;
      if (options.ignoreHtml) {
        // attribut(e=["']?$)
        var attributeOpen = string.slice(Math.max(start - 3, 0), start);
        if (attributeOpen && _attributeOpen.test(attributeOpen)) {
          continue;
        }
      }

      var end = start + string.slice(start).search(_end);
      var slice = string.slice(start, end);
      // make sure we include well balanced parens
      var parensEnd = -1;
      while (true) {
        var parensMatch = _parens.exec(slice);
        if (!parensMatch) {
          break;
        }

        var parensMatchEnd = parensMatch.index + parensMatch[0].length;
        parensEnd = Math.max(parensEnd, parensMatchEnd);
      }

      if (parensEnd > -1) {
        slice = slice.slice(0, parensEnd) + slice.slice(parensEnd).replace(_trim, '');
      } else {
        slice = slice.replace(_trim, '');
      }

      if (slice.length <= match[0].length) {
        // the extract only contains the starting marker of a URI,
        // e.g. "www" or "http://"
        continue;
      }

      if (options.ignore && options.ignore.test(slice)) {
        continue;
      }

      end = start + slice.length;
      var result = callback(slice, start, end, string);
      if (result === undefined) {
        _start.lastIndex = end;
        continue;
      }

      result = String(result);
      string = string.slice(0, start) + result + string.slice(end);
      _start.lastIndex = start + result.length;
    }

    _start.lastIndex = 0;
    return string;
  };

  URI.ensureValidHostname = function(v, protocol) {
    // Theoretically URIs allow percent-encoding in Hostnames (according to RFC 3986)
    // they are not part of DNS and therefore ignored by URI.js

    var hasHostname = !!v; // not null and not an empty string
    var hasProtocol = !!protocol;
    var rejectEmptyHostname = false;

    if (hasProtocol) {
      rejectEmptyHostname = arrayContains(URI.hostProtocols, protocol);
    }

    if (rejectEmptyHostname && !hasHostname) {
      throw new TypeError('Hostname cannot be empty, if protocol is ' + protocol);
    } else if (v && v.match(URI.invalid_hostname_characters)) {
      // test punycode
      if (!punycode) {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');
      }
      if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-:_]');
      }
    }
  };

  URI.ensureValidPort = function (v) {
    if (!v) {
      return;
    }

    var port = Number(v);
    if (isInteger(port) && (port > 0) && (port < 65536)) {
      return;
    }

    throw new TypeError('Port "' + v + '" is not a valid port');
  };

  // noConflict
  URI.noConflict = function(removeAll) {
    if (removeAll) {
      var unconflicted = {
        URI: this.noConflict()
      };

      if (root.URITemplate && typeof root.URITemplate.noConflict === 'function') {
        unconflicted.URITemplate = root.URITemplate.noConflict();
      }

      if (root.IPv6 && typeof root.IPv6.noConflict === 'function') {
        unconflicted.IPv6 = root.IPv6.noConflict();
      }

      if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === 'function') {
        unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();
      }

      return unconflicted;
    } else if (root.URI === this) {
      root.URI = _URI;
    }

    return this;
  };

  p.build = function(deferBuild) {
    if (deferBuild === true) {
      this._deferred_build = true;
    } else if (deferBuild === undefined || this._deferred_build) {
      this._string = URI.build(this._parts);
      this._deferred_build = false;
    }

    return this;
  };

  p.clone = function() {
    return new URI(this);
  };

  p.valueOf = p.toString = function() {
    return this.build(false)._string;
  };


  function generateSimpleAccessor(_part){
    return function(v, build) {
      if (v === undefined) {
        return this._parts[_part] || '';
      } else {
        this._parts[_part] = v || null;
        this.build(!build);
        return this;
      }
    };
  }

  function generatePrefixAccessor(_part, _key){
    return function(v, build) {
      if (v === undefined) {
        return this._parts[_part] || '';
      } else {
        if (v !== null) {
          v = v + '';
          if (v.charAt(0) === _key) {
            v = v.substring(1);
          }
        }

        this._parts[_part] = v;
        this.build(!build);
        return this;
      }
    };
  }

  p.protocol = generateSimpleAccessor('protocol');
  p.username = generateSimpleAccessor('username');
  p.password = generateSimpleAccessor('password');
  p.hostname = generateSimpleAccessor('hostname');
  p.port = generateSimpleAccessor('port');
  p.query = generatePrefixAccessor('query', '?');
  p.fragment = generatePrefixAccessor('fragment', '#');

  p.search = function(v, build) {
    var t = this.query(v, build);
    return typeof t === 'string' && t.length ? ('?' + t) : t;
  };
  p.hash = function(v, build) {
    var t = this.fragment(v, build);
    return typeof t === 'string' && t.length ? ('#' + t) : t;
  };

  p.pathname = function(v, build) {
    if (v === undefined || v === true) {
      var res = this._parts.path || (this._parts.hostname ? '/' : '');
      return v ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;
    } else {
      if (this._parts.urn) {
        this._parts.path = v ? URI.recodeUrnPath(v) : '';
      } else {
        this._parts.path = v ? URI.recodePath(v) : '/';
      }
      this.build(!build);
      return this;
    }
  };
  p.path = p.pathname;
  p.href = function(href, build) {
    var key;

    if (href === undefined) {
      return this.toString();
    }

    this._string = '';
    this._parts = URI._parts();

    var _URI = href instanceof URI;
    var _object = typeof href === 'object' && (href.hostname || href.path || href.pathname);
    if (href.nodeName) {
      var attribute = URI.getDomAttribute(href);
      href = href[attribute] || '';
      _object = false;
    }

    // window.location is reported to be an object, but it's not the sort
    // of object we're looking for:
    // * location.protocol ends with a colon
    // * location.query != object.search
    // * location.hash != object.fragment
    // simply serializing the unknown object should do the trick
    // (for location, not for everything...)
    if (!_URI && _object && href.pathname !== undefined) {
      href = href.toString();
    }

    if (typeof href === 'string' || href instanceof String) {
      this._parts = URI.parse(String(href), this._parts);
    } else if (_URI || _object) {
      var src = _URI ? href._parts : href;
      for (key in src) {
        if (key === 'query') { continue; }
        if (hasOwn.call(this._parts, key)) {
          this._parts[key] = src[key];
        }
      }
      if (src.query) {
        this.query(src.query, false);
      }
    } else {
      throw new TypeError('invalid input');
    }

    this.build(!build);
    return this;
  };

  // identification accessors
  p.is = function(what) {
    var ip = false;
    var ip4 = false;
    var ip6 = false;
    var name = false;
    var sld = false;
    var idn = false;
    var punycode = false;
    var relative = !this._parts.urn;

    if (this._parts.hostname) {
      relative = false;
      ip4 = URI.ip4_expression.test(this._parts.hostname);
      ip6 = URI.ip6_expression.test(this._parts.hostname);
      ip = ip4 || ip6;
      name = !ip;
      sld = name && SLD && SLD.has(this._parts.hostname);
      idn = name && URI.idn_expression.test(this._parts.hostname);
      punycode = name && URI.punycode_expression.test(this._parts.hostname);
    }

    switch (what.toLowerCase()) {
      case 'relative':
        return relative;

      case 'absolute':
        return !relative;

      // hostname identification
      case 'domain':
      case 'name':
        return name;

      case 'sld':
        return sld;

      case 'ip':
        return ip;

      case 'ip4':
      case 'ipv4':
      case 'inet4':
        return ip4;

      case 'ip6':
      case 'ipv6':
      case 'inet6':
        return ip6;

      case 'idn':
        return idn;

      case 'url':
        return !this._parts.urn;

      case 'urn':
        return !!this._parts.urn;

      case 'punycode':
        return punycode;
    }

    return null;
  };

  // component specific input validation
  var _protocol = p.protocol;
  var _port = p.port;
  var _hostname = p.hostname;

  p.protocol = function(v, build) {
    if (v) {
      // accept trailing ://
      v = v.replace(/:(\/\/)?$/, '');

      if (!v.match(URI.protocol_expression)) {
        throw new TypeError('Protocol "' + v + '" contains characters other than [A-Z0-9.+-] or doesn\'t start with [A-Z]');
      }
    }

    return _protocol.call(this, v, build);
  };
  p.scheme = p.protocol;
  p.port = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v !== undefined) {
      if (v === 0) {
        v = null;
      }

      if (v) {
        v += '';
        if (v.charAt(0) === ':') {
          v = v.substring(1);
        }

        URI.ensureValidPort(v);
      }
    }
    return _port.call(this, v, build);
  };
  p.hostname = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v !== undefined) {
      var x = { preventInvalidHostname: this._parts.preventInvalidHostname };
      var res = URI.parseHost(v, x);
      if (res !== '/') {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
      }

      v = x.hostname;
      if (this._parts.preventInvalidHostname) {
        URI.ensureValidHostname(v, this._parts.protocol);
      }
    }

    return _hostname.call(this, v, build);
  };

  // compound accessors
  p.origin = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined) {
      var protocol = this.protocol();
      var authority = this.authority();
      if (!authority) {
        return '';
      }

      return (protocol ? protocol + '://' : '') + this.authority();
    } else {
      var origin = URI(v);
      this
        .protocol(origin.protocol())
        .authority(origin.authority())
        .build(!build);
      return this;
    }
  };
  p.host = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined) {
      return this._parts.hostname ? URI.buildHost(this._parts) : '';
    } else {
      var res = URI.parseHost(v, this._parts);
      if (res !== '/') {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
      }

      this.build(!build);
      return this;
    }
  };
  p.authority = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined) {
      return this._parts.hostname ? URI.buildAuthority(this._parts) : '';
    } else {
      var res = URI.parseAuthority(v, this._parts);
      if (res !== '/') {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
      }

      this.build(!build);
      return this;
    }
  };
  p.userinfo = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined) {
      var t = URI.buildUserinfo(this._parts);
      return t ? t.substring(0, t.length -1) : t;
    } else {
      if (v[v.length-1] !== '@') {
        v += '@';
      }

      URI.parseUserinfo(v, this._parts);
      this.build(!build);
      return this;
    }
  };
  p.resource = function(v, build) {
    var parts;

    if (v === undefined) {
      return this.path() + this.search() + this.hash();
    }

    parts = URI.parse(v);
    this._parts.path = parts.path;
    this._parts.query = parts.query;
    this._parts.fragment = parts.fragment;
    this.build(!build);
    return this;
  };

  // fraction accessors
  p.subdomain = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    // convenience, return "www" from "www.example.org"
    if (v === undefined) {
      if (!this._parts.hostname || this.is('IP')) {
        return '';
      }

      // grab domain and add another segment
      var end = this._parts.hostname.length - this.domain().length - 1;
      return this._parts.hostname.substring(0, end) || '';
    } else {
      var e = this._parts.hostname.length - this.domain().length;
      var sub = this._parts.hostname.substring(0, e);
      var replace = new RegExp('^' + escapeRegEx(sub));

      if (v && v.charAt(v.length - 1) !== '.') {
        v += '.';
      }

      if (v.indexOf(':') !== -1) {
        throw new TypeError('Domains cannot contain colons');
      }

      if (v) {
        URI.ensureValidHostname(v, this._parts.protocol);
      }

      this._parts.hostname = this._parts.hostname.replace(replace, v);
      this.build(!build);
      return this;
    }
  };
  p.domain = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (typeof v === 'boolean') {
      build = v;
      v = undefined;
    }

    // convenience, return "example.org" from "www.example.org"
    if (v === undefined) {
      if (!this._parts.hostname || this.is('IP')) {
        return '';
      }

      // if hostname consists of 1 or 2 segments, it must be the domain
      var t = this._parts.hostname.match(/\./g);
      if (t && t.length < 2) {
        return this._parts.hostname;
      }

      // grab tld and add another segment
      var end = this._parts.hostname.length - this.tld(build).length - 1;
      end = this._parts.hostname.lastIndexOf('.', end -1) + 1;
      return this._parts.hostname.substring(end) || '';
    } else {
      if (!v) {
        throw new TypeError('cannot set domain empty');
      }

      if (v.indexOf(':') !== -1) {
        throw new TypeError('Domains cannot contain colons');
      }

      URI.ensureValidHostname(v, this._parts.protocol);

      if (!this._parts.hostname || this.is('IP')) {
        this._parts.hostname = v;
      } else {
        var replace = new RegExp(escapeRegEx(this.domain()) + '$');
        this._parts.hostname = this._parts.hostname.replace(replace, v);
      }

      this.build(!build);
      return this;
    }
  };
  p.tld = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (typeof v === 'boolean') {
      build = v;
      v = undefined;
    }

    // return "org" from "www.example.org"
    if (v === undefined) {
      if (!this._parts.hostname || this.is('IP')) {
        return '';
      }

      var pos = this._parts.hostname.lastIndexOf('.');
      var tld = this._parts.hostname.substring(pos + 1);

      if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
        return SLD.get(this._parts.hostname) || tld;
      }

      return tld;
    } else {
      var replace;

      if (!v) {
        throw new TypeError('cannot set TLD empty');
      } else if (v.match(/[^a-zA-Z0-9-]/)) {
        if (SLD && SLD.is(v)) {
          replace = new RegExp(escapeRegEx(this.tld()) + '$');
          this._parts.hostname = this._parts.hostname.replace(replace, v);
        } else {
          throw new TypeError('TLD "' + v + '" contains characters other than [A-Z0-9]');
        }
      } else if (!this._parts.hostname || this.is('IP')) {
        throw new ReferenceError('cannot set TLD on non-domain host');
      } else {
        replace = new RegExp(escapeRegEx(this.tld()) + '$');
        this._parts.hostname = this._parts.hostname.replace(replace, v);
      }

      this.build(!build);
      return this;
    }
  };
  p.directory = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined || v === true) {
      if (!this._parts.path && !this._parts.hostname) {
        return '';
      }

      if (this._parts.path === '/') {
        return '/';
      }

      var end = this._parts.path.length - this.filename().length - 1;
      var res = this._parts.path.substring(0, end) || (this._parts.hostname ? '/' : '');

      return v ? URI.decodePath(res) : res;

    } else {
      var e = this._parts.path.length - this.filename().length;
      var directory = this._parts.path.substring(0, e);
      var replace = new RegExp('^' + escapeRegEx(directory));

      // fully qualifier directories begin with a slash
      if (!this.is('relative')) {
        if (!v) {
          v = '/';
        }

        if (v.charAt(0) !== '/') {
          v = '/' + v;
        }
      }

      // directories always end with a slash
      if (v && v.charAt(v.length - 1) !== '/') {
        v += '/';
      }

      v = URI.recodePath(v);
      this._parts.path = this._parts.path.replace(replace, v);
      this.build(!build);
      return this;
    }
  };
  p.filename = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (typeof v !== 'string') {
      if (!this._parts.path || this._parts.path === '/') {
        return '';
      }

      var pos = this._parts.path.lastIndexOf('/');
      var res = this._parts.path.substring(pos+1);

      return v ? URI.decodePathSegment(res) : res;
    } else {
      var mutatedDirectory = false;

      if (v.charAt(0) === '/') {
        v = v.substring(1);
      }

      if (v.match(/\.?\//)) {
        mutatedDirectory = true;
      }

      var replace = new RegExp(escapeRegEx(this.filename()) + '$');
      v = URI.recodePath(v);
      this._parts.path = this._parts.path.replace(replace, v);

      if (mutatedDirectory) {
        this.normalizePath(build);
      } else {
        this.build(!build);
      }

      return this;
    }
  };
  p.suffix = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined || v === true) {
      if (!this._parts.path || this._parts.path === '/') {
        return '';
      }

      var filename = this.filename();
      var pos = filename.lastIndexOf('.');
      var s, res;

      if (pos === -1) {
        return '';
      }

      // suffix may only contain alnum characters (yup, I made this up.)
      s = filename.substring(pos+1);
      res = (/^[a-z0-9%]+$/i).test(s) ? s : '';
      return v ? URI.decodePathSegment(res) : res;
    } else {
      if (v.charAt(0) === '.') {
        v = v.substring(1);
      }

      var suffix = this.suffix();
      var replace;

      if (!suffix) {
        if (!v) {
          return this;
        }

        this._parts.path += '.' + URI.recodePath(v);
      } else if (!v) {
        replace = new RegExp(escapeRegEx('.' + suffix) + '$');
      } else {
        replace = new RegExp(escapeRegEx(suffix) + '$');
      }

      if (replace) {
        v = URI.recodePath(v);
        this._parts.path = this._parts.path.replace(replace, v);
      }

      this.build(!build);
      return this;
    }
  };
  p.segment = function(segment, v, build) {
    var separator = this._parts.urn ? ':' : '/';
    var path = this.path();
    var absolute = path.substring(0, 1) === '/';
    var segments = path.split(separator);

    if (segment !== undefined && typeof segment !== 'number') {
      build = v;
      v = segment;
      segment = undefined;
    }

    if (segment !== undefined && typeof segment !== 'number') {
      throw new Error('Bad segment "' + segment + '", must be 0-based integer');
    }

    if (absolute) {
      segments.shift();
    }

    if (segment < 0) {
      // allow negative indexes to address from the end
      segment = Math.max(segments.length + segment, 0);
    }

    if (v === undefined) {
      /*jshint laxbreak: true */
      return segment === undefined
        ? segments
        : segments[segment];
      /*jshint laxbreak: false */
    } else if (segment === null || segments[segment] === undefined) {
      if (isArray(v)) {
        segments = [];
        // collapse empty elements within array
        for (var i=0, l=v.length; i < l; i++) {
          if (!v[i].length && (!segments.length || !segments[segments.length -1].length)) {
            continue;
          }

          if (segments.length && !segments[segments.length -1].length) {
            segments.pop();
          }

          segments.push(trimSlashes(v[i]));
        }
      } else if (v || typeof v === 'string') {
        v = trimSlashes(v);
        if (segments[segments.length -1] === '') {
          // empty trailing elements have to be overwritten
          // to prevent results such as /foo//bar
          segments[segments.length -1] = v;
        } else {
          segments.push(v);
        }
      }
    } else {
      if (v) {
        segments[segment] = trimSlashes(v);
      } else {
        segments.splice(segment, 1);
      }
    }

    if (absolute) {
      segments.unshift('');
    }

    return this.path(segments.join(separator), build);
  };
  p.segmentCoded = function(segment, v, build) {
    var segments, i, l;

    if (typeof segment !== 'number') {
      build = v;
      v = segment;
      segment = undefined;
    }

    if (v === undefined) {
      segments = this.segment(segment, v, build);
      if (!isArray(segments)) {
        segments = segments !== undefined ? URI.decode(segments) : undefined;
      } else {
        for (i = 0, l = segments.length; i < l; i++) {
          segments[i] = URI.decode(segments[i]);
        }
      }

      return segments;
    }

    if (!isArray(v)) {
      v = (typeof v === 'string' || v instanceof String) ? URI.encode(v) : v;
    } else {
      for (i = 0, l = v.length; i < l; i++) {
        v[i] = URI.encode(v[i]);
      }
    }

    return this.segment(segment, v, build);
  };

  // mutating query string
  var q = p.query;
  p.query = function(v, build) {
    if (v === true) {
      return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    } else if (typeof v === 'function') {
      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      var result = v.call(this, data);
      this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
      this.build(!build);
      return this;
    } else if (v !== undefined && typeof v !== 'string') {
      this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
      this.build(!build);
      return this;
    } else {
      return q.call(this, v, build);
    }
  };
  p.setQuery = function(name, value, build) {
    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);

    if (typeof name === 'string' || name instanceof String) {
      data[name] = value !== undefined ? value : null;
    } else if (typeof name === 'object') {
      for (var key in name) {
        if (hasOwn.call(name, key)) {
          data[key] = name[key];
        }
      }
    } else {
      throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
    }

    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
    if (typeof name !== 'string') {
      build = value;
    }

    this.build(!build);
    return this;
  };
  p.addQuery = function(name, value, build) {
    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    URI.addQuery(data, name, value === undefined ? null : value);
    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
    if (typeof name !== 'string') {
      build = value;
    }

    this.build(!build);
    return this;
  };
  p.removeQuery = function(name, value, build) {
    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    URI.removeQuery(data, name, value);
    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
    if (typeof name !== 'string') {
      build = value;
    }

    this.build(!build);
    return this;
  };
  p.hasQuery = function(name, value, withinArray) {
    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    return URI.hasQuery(data, name, value, withinArray);
  };
  p.setSearch = p.setQuery;
  p.addSearch = p.addQuery;
  p.removeSearch = p.removeQuery;
  p.hasSearch = p.hasQuery;

  // sanitizing URLs
  p.normalize = function() {
    if (this._parts.urn) {
      return this
        .normalizeProtocol(false)
        .normalizePath(false)
        .normalizeQuery(false)
        .normalizeFragment(false)
        .build();
    }

    return this
      .normalizeProtocol(false)
      .normalizeHostname(false)
      .normalizePort(false)
      .normalizePath(false)
      .normalizeQuery(false)
      .normalizeFragment(false)
      .build();
  };
  p.normalizeProtocol = function(build) {
    if (typeof this._parts.protocol === 'string') {
      this._parts.protocol = this._parts.protocol.toLowerCase();
      this.build(!build);
    }

    return this;
  };
  p.normalizeHostname = function(build) {
    if (this._parts.hostname) {
      if (this.is('IDN') && punycode) {
        this._parts.hostname = punycode.toASCII(this._parts.hostname);
      } else if (this.is('IPv6') && IPv6) {
        this._parts.hostname = IPv6.best(this._parts.hostname);
      }

      this._parts.hostname = this._parts.hostname.toLowerCase();
      this.build(!build);
    }

    return this;
  };
  p.normalizePort = function(build) {
    // remove port of it's the protocol's default
    if (typeof this._parts.protocol === 'string' && this._parts.port === URI.defaultPorts[this._parts.protocol]) {
      this._parts.port = null;
      this.build(!build);
    }

    return this;
  };
  p.normalizePath = function(build) {
    var _path = this._parts.path;
    if (!_path) {
      return this;
    }

    if (this._parts.urn) {
      this._parts.path = URI.recodeUrnPath(this._parts.path);
      this.build(!build);
      return this;
    }

    if (this._parts.path === '/') {
      return this;
    }

    _path = URI.recodePath(_path);

    var _was_relative;
    var _leadingParents = '';
    var _parent, _pos;

    // handle relative paths
    if (_path.charAt(0) !== '/') {
      _was_relative = true;
      _path = '/' + _path;
    }

    // handle relative files (as opposed to directories)
    if (_path.slice(-3) === '/..' || _path.slice(-2) === '/.') {
      _path += '/';
    }

    // resolve simples
    _path = _path
      .replace(/(\/(\.\/)+)|(\/\.$)/g, '/')
      .replace(/\/{2,}/g, '/');

    // remember leading parents
    if (_was_relative) {
      _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || '';
      if (_leadingParents) {
        _leadingParents = _leadingParents[0];
      }
    }

    // resolve parents
    while (true) {
      _parent = _path.search(/\/\.\.(\/|$)/);
      if (_parent === -1) {
        // no more ../ to resolve
        break;
      } else if (_parent === 0) {
        // top level cannot be relative, skip it
        _path = _path.substring(3);
        continue;
      }

      _pos = _path.substring(0, _parent).lastIndexOf('/');
      if (_pos === -1) {
        _pos = _parent;
      }
      _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
    }

    // revert to relative
    if (_was_relative && this.is('relative')) {
      _path = _leadingParents + _path.substring(1);
    }

    this._parts.path = _path;
    this.build(!build);
    return this;
  };
  p.normalizePathname = p.normalizePath;
  p.normalizeQuery = function(build) {
    if (typeof this._parts.query === 'string') {
      if (!this._parts.query.length) {
        this._parts.query = null;
      } else {
        this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
      }

      this.build(!build);
    }

    return this;
  };
  p.normalizeFragment = function(build) {
    if (!this._parts.fragment) {
      this._parts.fragment = null;
      this.build(!build);
    }

    return this;
  };
  p.normalizeSearch = p.normalizeQuery;
  p.normalizeHash = p.normalizeFragment;

  p.iso8859 = function() {
    // expect unicode input, iso8859 output
    var e = URI.encode;
    var d = URI.decode;

    URI.encode = escape;
    URI.decode = decodeURIComponent;
    try {
      this.normalize();
    } finally {
      URI.encode = e;
      URI.decode = d;
    }
    return this;
  };

  p.unicode = function() {
    // expect iso8859 input, unicode output
    var e = URI.encode;
    var d = URI.decode;

    URI.encode = strictEncodeURIComponent;
    URI.decode = unescape;
    try {
      this.normalize();
    } finally {
      URI.encode = e;
      URI.decode = d;
    }
    return this;
  };

  p.readable = function() {
    var uri = this.clone();
    // removing username, password, because they shouldn't be displayed according to RFC 3986
    uri.username('').password('').normalize();
    var t = '';
    if (uri._parts.protocol) {
      t += uri._parts.protocol + '://';
    }

    if (uri._parts.hostname) {
      if (uri.is('punycode') && punycode) {
        t += punycode.toUnicode(uri._parts.hostname);
        if (uri._parts.port) {
          t += ':' + uri._parts.port;
        }
      } else {
        t += uri.host();
      }
    }

    if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== '/') {
      t += '/';
    }

    t += uri.path(true);
    if (uri._parts.query) {
      var q = '';
      for (var i = 0, qp = uri._parts.query.split('&'), l = qp.length; i < l; i++) {
        var kv = (qp[i] || '').split('=');
        q += '&' + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace)
          .replace(/&/g, '%26');

        if (kv[1] !== undefined) {
          q += '=' + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace)
            .replace(/&/g, '%26');
        }
      }
      t += '?' + q.substring(1);
    }

    t += URI.decodeQuery(uri.hash(), true);
    return t;
  };

  // resolving relative and absolute URLs
  p.absoluteTo = function(base) {
    var resolved = this.clone();
    var properties = ['protocol', 'username', 'password', 'hostname', 'port'];
    var basedir, i, p;

    if (this._parts.urn) {
      throw new Error('URNs do not have any generally defined hierarchical components');
    }

    if (!(base instanceof URI)) {
      base = new URI(base);
    }

    if (resolved._parts.protocol) {
      // Directly returns even if this._parts.hostname is empty.
      return resolved;
    } else {
      resolved._parts.protocol = base._parts.protocol;
    }

    if (this._parts.hostname) {
      return resolved;
    }

    for (i = 0; (p = properties[i]); i++) {
      resolved._parts[p] = base._parts[p];
    }

    if (!resolved._parts.path) {
      resolved._parts.path = base._parts.path;
      if (!resolved._parts.query) {
        resolved._parts.query = base._parts.query;
      }
    } else {
      if (resolved._parts.path.substring(-2) === '..') {
        resolved._parts.path += '/';
      }

      if (resolved.path().charAt(0) !== '/') {
        basedir = base.directory();
        basedir = basedir ? basedir : base.path().indexOf('/') === 0 ? '/' : '';
        resolved._parts.path = (basedir ? (basedir + '/') : '') + resolved._parts.path;
        resolved.normalizePath();
      }
    }

    resolved.build();
    return resolved;
  };
  p.relativeTo = function(base) {
    var relative = this.clone().normalize();
    var relativeParts, baseParts, common, relativePath, basePath;

    if (relative._parts.urn) {
      throw new Error('URNs do not have any generally defined hierarchical components');
    }

    base = new URI(base).normalize();
    relativeParts = relative._parts;
    baseParts = base._parts;
    relativePath = relative.path();
    basePath = base.path();

    if (relativePath.charAt(0) !== '/') {
      throw new Error('URI is already relative');
    }

    if (basePath.charAt(0) !== '/') {
      throw new Error('Cannot calculate a URI relative to another relative URI');
    }

    if (relativeParts.protocol === baseParts.protocol) {
      relativeParts.protocol = null;
    }

    if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {
      return relative.build();
    }

    if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {
      return relative.build();
    }

    if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
      relativeParts.hostname = null;
      relativeParts.port = null;
    } else {
      return relative.build();
    }

    if (relativePath === basePath) {
      relativeParts.path = '';
      return relative.build();
    }

    // determine common sub path
    common = URI.commonPath(relativePath, basePath);

    // If the paths have nothing in common, return a relative URL with the absolute path.
    if (!common) {
      return relative.build();
    }

    var parents = baseParts.path
      .substring(common.length)
      .replace(/[^\/]*$/, '')
      .replace(/.*?\//g, '../');

    relativeParts.path = (parents + relativeParts.path.substring(common.length)) || './';

    return relative.build();
  };

  // comparing URIs
  p.equals = function(uri) {
    var one = this.clone();
    var two = new URI(uri);
    var one_map = {};
    var two_map = {};
    var checked = {};
    var one_query, two_query, key;

    one.normalize();
    two.normalize();

    // exact match
    if (one.toString() === two.toString()) {
      return true;
    }

    // extract query string
    one_query = one.query();
    two_query = two.query();
    one.query('');
    two.query('');

    // definitely not equal if not even non-query parts match
    if (one.toString() !== two.toString()) {
      return false;
    }

    // query parameters have the same length, even if they're permuted
    if (one_query.length !== two_query.length) {
      return false;
    }

    one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);
    two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);

    for (key in one_map) {
      if (hasOwn.call(one_map, key)) {
        if (!isArray(one_map[key])) {
          if (one_map[key] !== two_map[key]) {
            return false;
          }
        } else if (!arraysEqual(one_map[key], two_map[key])) {
          return false;
        }

        checked[key] = true;
      }
    }

    for (key in two_map) {
      if (hasOwn.call(two_map, key)) {
        if (!checked[key]) {
          // two contains a parameter not present in one
          return false;
        }
      }
    }

    return true;
  };

  // state
  p.preventInvalidHostname = function(v) {
    this._parts.preventInvalidHostname = !!v;
    return this;
  };

  p.duplicateQueryParameters = function(v) {
    this._parts.duplicateQueryParameters = !!v;
    return this;
  };

  p.escapeQuerySpace = function(v) {
    this._parts.escapeQuerySpace = !!v;
    return this;
  };

  return URI;
}));

define(
    'organizator/Component/Routing/Routing',[
        'organizator/Component/Routing/Locator',
        'organizator/Component/Routing/Matcher',
        'organizator/Component/Routing/Generator',
        'organizator/Component/Routing/RouteCompiler',
        'urijs/src/URI'
    ],
    function (
        Organizator_Routing_Locator,
        Organizator_Routing_Matcher,
        Organizator_Routing_Generator,
        Organizator_Routing_RouteCompiler,
        URI
    ) {
        class Organizator_Routing {
            constructor(options) {
                this.base =  this._addSlash(options.base) || '/',
                this.mode =  options.mode || 'history' // history || hash || hashbang;

                this.currentUrl = new URI();

                this.requestOptions = options.requestOptions !== undefined ? Object.assign({
                    mode: 'push',
                    popstatable: true,
                    absolute: false,
                    load: true,
                    controller: true
                }, options.requestOptions) : {
                    mode: 'push',
                    popstatable: true,
                    absolute: false,
                    load: true,
                    controller: true
                }

                this.state = 'loaded';
                this.window = window

                this.Locator = new Organizator_Routing_Locator();
                this.Matcher = new Organizator_Routing_Matcher();
                this.Generator = new Organizator_Routing_Generator();
                this.RouteCompiler = new Organizator_Routing_RouteCompiler();

                this.routes = [];
                this.controllers = {};

                this.bindEvents();
            }

            bindEvents() {
                this.window.addEventListener('popstate', (event) => this.popstate(event));
                //this.Interface.window.addEventListener('organizator:routing:route:created', (event) => this.addRoute(event));
                //this.Interface.window.addEventListener('organizator:routing:request', (event) => this.listenRequests(event));
            }

            /*
             * Listens routing:request events and pass request details to request().
             */
            listenRequests() {
                this.request(event.detail.request);
            }

            /*
             * Accepts a (hashchange, pushState, replaceState, popstate) request.
             * 
             * @param {Object} request
             * @param {String} request.mode - Defines the mode of the request. Default is 'push'.
             * @param {String} request.popstatable - Defines whether the state is popstatable or not. Default is true.
             * @param {String} request.url - Defines the new url of the window.
             * @param {String} request.absolute - Defines whether the url is absolute or not. Default is false.
             */
            request(request) {
                /*
                 * Write the request over the defaults. Default values are used if an option is missing.
                 */
                request = Object.assign(Object.assign({}, this.requestOptions), request);
                request.url = this._resolveFragment(request.url);
                request.url = request.url == '/' ? '' : request.url;
                
                var matchedRoute = this.Matcher.checkAll(request.url);
                
                if (matchedRoute !== false) {
                    var parameters = matchedRoute.matches || [];

                    if (matchedRoute.subroute.defaults) {
                        for (var i = 0; i < matchedRoute.subroute.defaults.length; i++) {
                            parameters.push(matchedRoute.subroute.defaults[i].value);
                        }
                    }

                    parameters.push(request);

                    var locatorResponse = Organizator.Routing.Locator.request(request);
                    if (typeof matchedRoute.route.controller !== 'undefined' && matchedRoute.route.controller !== '' && locatorResponse) {
                        switch (typeof matchedRoute.route.controller) {
                            case 'function':
                                matchedRoute.route.controller.apply({}, parameters);
                                break;
                            case 'string':
                                this.controllers[matchedRoute.route.controller].apply({}, parameters);
                                break;
                        }
                    }else{
                        return false;
                    }

                    return true;
                }

                return false;
            }

            addRoute(name, compiledRoute) {
                this.routes[name] = compiledRoute;
            }
            
            addController(name, handler) {
                this.controllers[name] = handler;
            }

            /*
             * Window object execute this function when a popstate event fired.
             * 
             * It looks 'popstatable' flag in the state. If its value is true then send a request to request() function with 'mode':'load-only'
             * because window.location is already changed by the browser itself and there is no need to push a state again. We need only
             * load the source.
             * 
             * Window will be reloaded if it's not popstatable.
             */
            popstate(event) {
                /*
                 * Request is passed here from a History API state.
                 */
                var request = event.state;

                /*
                 * Page should be reloaded if request is not popstatable.
                 */
                if (!(request === undefined || request == null)) {
                    if (request.popstatable) {
                        request.mode = 'popstate';
                        this.request(request);
                    } else {
                        this.window.location.reload();
                        return;
                    }
                }

                return;
            }

            _getFragment(path) {
                var fragment = path.replace(/\?(.*)$/, '');

                return this._clearSlashes(fragment);
            }

            _resolveFragment(path) {
                return path.indexOf(this.base) == 0 ? path.replace(this.base, '') : path;
            }

            _clearSlashes(path) {
                return path.toString().replace(/\/\/$/, '').replace(/^\//, '');
            }

            _addSlash(path){
                return this._clearSlashes(path) + '/';
            }

            _clearQueryString(path) {
                return path.split('?')[0];
            }

            _clearBrackets(string) {
                return string.replace('{', '').replace('}', '');
            }

            _clearRegexDelimiters(string) {
                return string.toString().replace(/\/$/, '').replace(/^\//, '');
            }

            _addRegexDelimiters(string) {
                return '/' + string + '/';
            }
        }
        
        return Organizator_Routing;
    }
);
define('organizator/Component/Nearley/Nearley',[],function(){
	class Organizator_Nearley_Parser {
        constructor(rules, start, options) {
            if (rules instanceof Organizator_Nearley_Grammar) {
                var grammar = rules;
                var options = start;
            } else {
                var grammar = Organizator_Nearley_Grammar.fromCompiled(rules, start);
            }
            this.grammar = grammar;

            // Read options
            this.options = {
                keepHistory: false,
            };
            for (const key in (options || {})) {
                this.options[key] = options[key];
            }

            // Setup a table
            const column = new Organizator_Nearley_Column(grammar, 0);
            const table = this.table = [column];

            // I could be expecting anything.
            column.wants[grammar.start] = [];
            column.predict(grammar.start);
            // TODO what if start rule is nullable?
            column.process();
            this.current = 0;
        }

        feed(chunk) {
            for (var chunkPos = 0; chunkPos < chunk.length; chunkPos++) {
                // We add new states to table[current+1]
                const column = this.table[this.current + chunkPos];

                // GC unused states
                if (!this.options.keepHistory) {
                    delete this.table[this.current + chunkPos - 1];
                }

                const n = this.current + chunkPos + 1;
                const nextColumn = new Organizator_Nearley_Column(this.grammar, n);
                this.table.push(nextColumn);

                // Advance all tokens that expect the symbol
                // So for each state in the previous row,

                const token = chunk[chunkPos];
                const scannable = column.scannable;
                for (let w = scannable.length; w--; ) {
                    const state = scannable[w];
                    const expect = state.rule.symbols[state.dot];
                    // Try to consume the token
                    // either regex or literal
                    if (expect.test ? expect.test(token) : expect.literal === token) {
                        // Add it
                        const next = state.nextState(token);
                        nextColumn.states.push(next);
                    }
                }

                // Next, for each of the rules, we either
                // (a) complete it, and try to see if the reference row expected that
                //     rule
                // (b) predict the next nonterminal it expects by adding that
                //     nonterminal's start state
                // To prevent duplication, we also keep track of rules we have already
                // added

                nextColumn.process();

                // If needed, throw an error:
                if (nextColumn.states.length === 0) {
                    // No states at all! This is not good.
                    const err = new Error(
                            `nearley: No possible parsings (@${this.current + chunkPos}: '${chunk[chunkPos]}').`
                            );
                    err.offset = this.current + chunkPos;
                    throw err;
                }
            }

            this.current += chunkPos;

            // Incrementally keep track of results
            this.results = this.finish();

            // Allow chaining, for whatever it's worth
            return this;
        }

        finish() {
            // Return the possible parsings
            const considerations = [];
            const start = this.grammar.start;
            const column = this.table[this.table.length - 1];
            column.states.forEach(t => {
                if (t.rule.name === start
                        && t.dot === t.rule.symbols.length
                        && t.reference === 0
                        && t.data !== Organizator_Nearley_Parser.fail) {
                    considerations.push(t);
                }
            });
            return considerations.map(c => c.data);
        }
        
        static get fail() {
            Organizator_Nearley_Parser.MY_CONST;
        }
    }

    Organizator_Nearley_Parser.fail = {};

	class Organizator_Nearley_Column {
        constructor(grammar, index) {
            this.grammar = grammar;
            this.index = index;
            this.states = [];
            this.wants = {}; // states indexed by the non-terminal they expect
            this.scannable = []; // list of states that expect a token
            this.completed = {}; // states that are nullable
        }

        process(nextColumn) {
            const states = this.states;
            const wants = this.wants;
            const completed = this.completed;

            // nb. we push() during iteration
            for (const state of states) {
                if (state.isComplete) {
                    state.finish();
                    if (state.data !== Organizator_Nearley_Parser.fail) {
                        // complete
                        const wantedBy = state.wantedBy;
                        for (var i = wantedBy.length; i--; ) { // this line is hot
                            const left = wantedBy[i];
                            this.complete(left, state);
                        }

                        // special-case nullables
                        if (state.reference === this.index) {
                            // make sure future predictors of this rule get completed. 
                            var exp = state.rule.name;
                            (this.completed[exp] = this.completed[exp] || []).push(state);
                        }
                    }

                } else {
                    // queue scannable states
                    var exp = state.rule.symbols[state.dot];
                    if (typeof exp !== 'string') {
                        this.scannable.push(state);
                        continue;
                    }

                    // predict
                    if (wants[exp]) {
                        wants[exp].push(state);

                        if (completed.hasOwnProperty(exp)) {
                            const nulls = completed[exp];
                            for (var i = 0; i < nulls.length; i++) {
                                const right = nulls[i];
                                this.complete(state, right);
                            }
                        }
                    } else {
                        wants[exp] = [state];
                        this.predict(exp);
                    }
                }
            }
        }

        predict(exp) {
            const rules = this.grammar.byName[exp] || [];

            for (const r of rules) {
                const wantedBy = this.wants[exp];
                const s = new Organizator_Nearley_State(r, 0, this.index, wantedBy);
                this.states.push(s);
            }
        }

        complete(left, right) {
            const inp = right.rule.name;
            if (left.rule.symbols[left.dot] === inp) {
                const copy = left.nextState(right.data);
                this.states.push(copy);
            }
        }
    }

    class Organizator_Nearley_Grammar {
        constructor(rules, start) {
            this.rules = rules;
            this.start = start || this.rules[0].name;
            const byName = this.byName = {};
            this.rules.forEach(rule => {
                if (!byName.hasOwnProperty(rule.name)) {
                    byName[rule.name] = [];
                }
                byName[rule.name].push(rule);
            });
        }

        // So we can allow passing (rules, start) directly to Parser for backwards compatibility
        static fromCompiled(rules, start) {
            if (rules.ParserStart) {
                start = rules.ParserStart;
                rules = rules.ParserRules;
            }
            var rules = rules.map(r => new Organizator_Nearley_Rule(r.name, r.symbols, r.postprocess));
            return new Organizator_Nearley_Grammar(rules, start);
        }
    }

    class Organizator_Nearley_State {
        constructor(rule, dot, reference, wantedBy) {
            this.rule = rule;
            this.dot = dot;
            this.reference = reference;
            this.data = [];
            this.wantedBy = wantedBy;
            this.isComplete = this.dot === rule.symbols.length;
        }

        toString() {
            return `{${this.rule.toString(this.dot)}}, from: ${this.reference || 0}`;
        }

        nextState(data) {
            const state = new Organizator_Nearley_State(this.rule, this.dot + 1, this.reference, this.wantedBy);
            state.left = this;
            state.right = data;
            if (state.isComplete) {
                state.data = state.build();
            }
            return state;
        }

        build() {
            const children = [];
            let node = this;
            do {
                children.push(node.right);
                node = node.left;
            } while (node.left);
            children.reverse();
            return children;
        }

        finish() {
            if (this.rule.postprocess) {
                this.data = this.rule.postprocess(this.data, this.reference, Organizator_Nearley_Parser.fail);
            }
        }
    }

    class Organizator_Nearley_Rule {
        constructor(name, symbols, postprocess) {
            this.id = ++Organizator_Nearley_Rule.highestId;
            this.name = name;
            this.symbols = symbols;        // a list of literal | regex class | nonterminal
            this.postprocess = postprocess;
            return this;
        }

        toString(withCursorAt) {
            function stringifySymbolSequence (e) {
                return (e.literal) ? JSON.stringify(e.literal)
                                   : e.toString();
            }
            const symbolSequence = (typeof withCursorAt === "undefined")
                                 ? this.symbols.map(stringifySymbolSequence).join(' ')
                                 : (   `${this.symbols.slice(0, withCursorAt).map(stringifySymbolSequence).join(' ')} â—? ${this.symbols.slice(withCursorAt).map(stringifySymbolSequence).join(' ')}`     );
            return `${this.name} â†’ ${symbolSequence}`;
        }
    }

    Organizator_Nearley_Rule.highestId = 0;

	return {
		Organizator_Nearley_Parser: Organizator_Nearley_Parser,
		Organizator_Nearley_Column: Organizator_Nearley_Column,
		Organizator_Nearley_Grammar: Organizator_Nearley_Grammar,
		Organizator_Nearley_State: Organizator_Nearley_State,
		Organizator_Nearley_Rule: Organizator_Nearley_Rule
	};
});
define('organizator/Component/Validation/Grammar',[],function(){
    class Organizator_Validation_Grammar {
        constructor() {
            this.grammar = {
                ParserRules: [
                    {"name": "program", "symbols": ["expr"], "postprocess":
                                function (d) {
                                    return {
                                        type: 'program',
                                        value: d
                                    }
                                }
                    },
                    {"name": "expr", "symbols": [{"literal": "("}, "_", "expr", "_", {"literal": ")"}], "postprocess":
                                function (d) {
                                    return d[2];
                                }
                    },
                    {"name": "expr", "symbols": ["expr", "_", "op", "_", "expr"], "postprocess":
                                function (d) {
                                    let f = d.filter(function (i) {
                                        return i !== null
                                    });

                                    return {
                                        type: 'operation',
                                        value: f
                                    }
                                }
                    },
                    {"name": "expr", "symbols": ["rule"], "postprocess": this.id},
                    {"name": "rule$ebnf$1", "symbols": [/[a-z]/]},
                    {"name": "rule$ebnf$1", "symbols": ["rule$ebnf$1", /[a-z]/], "postprocess": function arrpush(d) {
                            return d[0].concat([d[1]]);
                        }},
                    {"name": "rule", "symbols": [{"literal": "@"}, "rule$ebnf$1", "_", {"literal": "("}, "_", "args", "_", {"literal": ")"}], "postprocess":
                                function (d) {
                                    let o = {};

                                    for (var i = 0; i < d[5].length; i++) {
                                        o = Object.assign(o, d[5][i]);
                                    }

                                    return {
                                        type: 'rule',
                                        name: d[1].join(''),
                                        arguments: o
                                    }
                                }
                    },
                    {"name": "rule$ebnf$2", "symbols": [/[a-z]/]},
                    {"name": "rule$ebnf$2", "symbols": ["rule$ebnf$2", /[a-z]/], "postprocess": function arrpush(d) {
                            return d[0].concat([d[1]]);
                        }},
                    {"name": "rule", "symbols": [{"literal": "@"}, "rule$ebnf$2", "_", {"literal": "("}, "_", {"literal": ")"}], "postprocess":
                                function (d) {
                                    return {
                                        type: 'rule',
                                        name: d[1].join(''),
                                        arguments: null
                                    }
                                }
                    },
                    {"name": "rule$ebnf$3", "symbols": [/[a-z]/]},
                    {"name": "rule$ebnf$3", "symbols": ["rule$ebnf$3", /[a-z]/], "postprocess": function arrpush(d) {
                            return d[0].concat([d[1]]);
                        }},
                    {"name": "rule", "symbols": [{"literal": "@"}, "rule$ebnf$3"], "postprocess":
                                function (d) {
                                    return {
                                        type: 'rule',
                                        name: d[1].join(''),
                                        arguments: null
                                    }
                                }
                    },
                    {"name": "args", "symbols": ["args", "_", {"literal": ","}, "_", "arg"], "postprocess":
                                function (d) {
                                    let args = [];

                                    for (var i = 0; i < d[0].length; i++) {
                                        args = args.concat(d[0][i]);
                                    }

                                    args = args.concat(d[4]);
                                    return args;
                                }
                    },
                    {"name": "args", "symbols": ["arg"], "postprocess":
                                function (d) {
                                    return [d[0]];
                                }
                    },
                    {"name": "arg", "symbols": ["argkey", "_", {"literal": "="}, "_", "argval"], "postprocess":
                                function (d) {
                                    let o = {};
                                    o[d[0]] = d[4];

                                    return o;
                                }
                    },
                    {"name": "argkey", "symbols": ["word"], "postprocess": this.id},
                    {"name": "argval", "symbols": ["word"], "postprocess": this.id},
                    {"name": "word$ebnf$1", "symbols": [/[^\s=(),'"]/]},
                    {"name": "word$ebnf$1", "symbols": ["word$ebnf$1", /[^\s=(),'"]/], "postprocess": function arrpush(d) {
                            return d[0].concat([d[1]]);
                        }},
                    {"name": "word", "symbols": ["word$ebnf$1"], "postprocess":
                                function (d) {
                                    return d[0].join('');
                                }
                    },
                    {"name": "word$ebnf$2", "symbols": [/[^"]/]},
                    {"name": "word$ebnf$2", "symbols": ["word$ebnf$2", /[^"]/], "postprocess": function arrpush(d) {
                            return d[0].concat([d[1]]);
                        }},
                    {"name": "word", "symbols": [{"literal": "\""}, "word$ebnf$2", {"literal": "\""}], "postprocess":
                                function (d) {
                                    return d[1].join('');
                                }
                    },
                    {"name": "word$ebnf$3", "symbols": [/[^']/]},
                    {"name": "word$ebnf$3", "symbols": ["word$ebnf$3", /[^']/], "postprocess": function arrpush(d) {
                            return d[0].concat([d[1]]);
                        }},
                    {"name": "word", "symbols": [{"literal": "'"}, "word$ebnf$3", {"literal": "'"}], "postprocess":
                                function (d) {
                                    return d[1].join('');
                                }
                    },
                    {"name": "op$string$1", "symbols": [{"literal": "&"}, {"literal": "&"}], "postprocess": function joiner(d) {
                            return d.join('');
                        }},
                    {"name": "op", "symbols": ["op$string$1"], "postprocess":
                                function (d) {
                                    return {
                                        type: 'operator',
                                        value: d[0]
                                    }
                                }
                    },
                    {"name": "op$string$2", "symbols": [{"literal": "|"}, {"literal": "|"}], "postprocess": function joiner(d) {
                            return d.join('');
                        }},
                    {"name": "op", "symbols": ["op$string$2"], "postprocess":
                                function (d) {
                                    return {
                                        type: 'operator',
                                        value: d[0]
                                    }
                                }
                    },
                    {"name": "_$ebnf$1", "symbols": []},
                    {"name": "_$ebnf$1", "symbols": ["_$ebnf$1", "wschar"], "postprocess": function arrpush(d) {
                            return d[0].concat([d[1]]);
                        }},
                    {"name": "_", "symbols": ["_$ebnf$1"], "postprocess": function (d) {
                            return null;
                        }},
                    {"name": "__$ebnf$1", "symbols": ["wschar"]},
                    {"name": "__$ebnf$1", "symbols": ["__$ebnf$1", "wschar"], "postprocess": function arrpush(d) {
                            return d[0].concat([d[1]]);
                        }},
                    {"name": "__", "symbols": ["__$ebnf$1"], "postprocess": function (d) {
                            return null;
                        }},
                    {"name": "wschar", "symbols": [/[ \t\n\v\f]/], "postprocess": this.id}
                ]
                , ParserStart: "program"
            };
        }

        id(x) {
            return x[0];
        }
    }

    return Organizator_Validation_Grammar;
});
/*
 * Organizator_Validation_ValidationResult
 */
define('organizator/Component/Validation/ValidationResult',[],function(){
    class Organizator_Validation_ValidationResult {
        constructor(options){
            this.isValid = options.isValid;
            this.results = options.results;
            this.errorCount = options.errorCount || 0;
        }
    }

    return Organizator_Validation_ValidationResult;
});
/*
 * Organizator_Validation_ValidationResult
 */
define(
    'organizator/Component/Validation/ValidationResultBuilder',[
        'organizator/Component/Validation/ValidationResult'
    ],
    function(
        Organizator_Validation_ValidationResult
    ){
        class Organizator_Validation_ValidationResultBuilder {
            constructor(){
                this.isValid = true;
                this.errorCount = 0;
                this.results = [];
            }

            addResult(itemValidationResult){
                this.results.push(itemValidationResult);

                if(!itemValidationResult.isValid){
                    this.errorCount++;
                }
            }

            calculate(){
                this.isValid = this.errorCount ? false : true;
            }

            setValue(value){
                this.value = value;
            }

            getResult(){
                this.calculate();

                var result = new Organizator_Validation_ValidationResult({
                    isValid: this.isValid,
                    errorCount: this.errorCount,
                    results: this.results
                });

                return result;
            }
        } 
       
       return Organizator_Validation_ValidationResultBuilder;
    }
);
/*
 * Organizator_Validation_ItemValidationResult
 */
define('organizator/Component/Validation/ItemValidationResult',[],function(){
    class Organizator_Validation_ItemValidationResult {
        constructor(options){
            this.item = options.item || null;
            this.value = options.value || null;
            this.isValid = options.isValid;
            this.constraints = options.constraints;
            this.errorCount = options.errorCount || 0;
        }
    }

    return Organizator_Validation_ItemValidationResult;
});
/*
 * Organizator_Validation_ItemValidationResult
 */
define(
    'organizator/Component/Validation/ItemValidationResultBuilder',[
        'organizator/Component/Validation/ItemValidationResult'
    ],
    function(
    	Organizator_Validation_ItemValidationResult
    ){
        class Organizator_Validation_ItemValidationResultBuilder {
            constructor(){
                this.item = null;
                this.value = null;
                this.isValid = true;
                this.errorCount = 0;
                this.constraints = {};
            }

            addResult(constraintName, itemValidationResult){
                this.constraints[constraintName] = itemValidationResult;

                if(!itemValidationResult.isValid){
                    this.errorCount++;
                }
            }

            reset(){
                this.item = null;
                this.value = null;
                this.isValid = true;
                this.errorCount = 0;
                this.constraints = {};
            }

            setIsValid(isValid){
                this.isValid = isValid;
            }

            setItem(item){
                this.item = item;
            }

            setValue(value){
                this.value = value;
            }

            getResult(){
                var result = new Organizator_Validation_ItemValidationResult({
                    item: this.item,
                    value: this.value,
                    isValid: this.isValid,
                    errorCount: this.errorCount,
                    constraints: this.constraints
                });

                return result;
            }
        }
        
        return Organizator_Validation_ItemValidationResultBuilder;
    }
);
/*
 * Organizator_Validation_ItemValidationResultBuilder
 */
define(
    'organizator/Component/Validation/Interpreter',[
        'organizator/Component/Validation/ItemValidationResultBuilder'
    ],
    function(
        Organizator_Validation_ItemValidationResultBuilder
    ){
       class Organizator_Validation_Interpreter {
            constructor(input, value, element, property) {
                this.property = property || null;
                this.element = element || null;
                this.input = input || '';
                this.value = value || '';
                this.itemValidationResultBuilder = new Organizator_Validation_ItemValidationResultBuilder();
            }

            getResult(){
                return this.itemValidationResultBuilder.getResult();
            }

            reset(){
                this.item = null;
                this.input = '';
                this.value = '';
                this.itemValidationResultBuilder.reset();
            }

            setItem(item){
                this.item = item;
                this.itemValidationResultBuilder.setItem(item);
            }

            setInput(input) {
                this.input = input;
            }

            setValue(value) {
                this.value = value;
                this.itemValidationResultBuilder.setValue(value);
            }
            
            setIsValid(isValid){
                this.itemValidationResultBuilder.setIsValid(isValid);
            }

            traverse(node, rootCommand){
                for(let i = 0; i < node.value.length; i++){
                    let subNode = node.value[i];
                    switch(subNode.type){
                        case 'group':
                            this.traverse(subNode);
                            node.value[i] = subNode.value;
                            break;
                        case 'operation':
                            node.value[i] = this.operate(subNode);
                            break;
                        case 'rule':
                            node.value[i] = this.validateRule(subNode);
                            break;
                    }
                }

                if(rootCommand){
                    this.input = node;
                    this.setIsValid(node.value[0].value);
                }
            }

            operate(node){
                let operator = node.value.filter(function(i){return i.type == 'operator';})[0];
                let operands = node.value.filter(function(i){return i.type != 'operator';});

                for(let i = 0; i < operands.length; i++){
                    let operand = operands[i];

                    switch(operands[i].type){
                        case 'operation':
                            operands[i] = this.operate(operands[i]);
                            break;
                        case 'group':
                            operands[i] = this.traverse(operands[i]);
                            break;
                        case 'rule':
                            operands[i] = this.validateRule(operands[i]);
                            break;
                    }
                }

                switch(operator.value){
                    case '&&':
                        return {
                            type: 'operationResult',
                            value: operands[0].value && operands[1].value
                        };
                        break;
                    case '||':
                        return {
                            type: 'operationResult',
                            value: operands[0].value || operands[1].value
                        };
                        break;
                }
            }

            validateRule(node){
                let constraintName = node.name;
                let constraintArguments = node.arguments;
                let constraint = new Organizator.Validator.constraints[constraintName](constraintArguments);
                let constraintValidationResult = constraint.validate(this.value, this.item);
                
                this.itemValidationResultBuilder.addResult(constraintName, constraintValidationResult);

                return {
                    type: 'operationResult',
                    value: constraintValidationResult.isValid
                }
            }

            /*
             * @return Organizator_Validation_ItemValidationResult
             */
            run(){
                this.traverse(this.input, true);
                return this.getResult();
            }
        }
        
        return Organizator_Validation_Interpreter;
    }
);
define('organizator/Util/QueryStringParser',[],function(){
    class Organizator_Util_QueryStringParser{
        constructor(){}
        /*
         * @author <sindresorhus>
         * https://github.com/sindresorhus/query-string/
         * 
         * @devnote check also this https://github.com/christianalfoni/form-data-to-object/blob/master/index.js
         */
        _parseQueryString(str, opts) {
            opts = Object.assign({arrayFormat: 'none'}, opts);

            var formatter = this._parserForArrayFormat(opts);

            // Create an object with no prototype
            // https://github.com/sindresorhus/query-string/issues/47
            var ret = Object.create(null);

            if (typeof str !== 'string') {
                return ret;
            }

            str = str.trim().replace(/^(\?|#|&)/, '');

            if (!str) {
                return ret;
            }

            str.split('&').forEach(function (param) {
                var parts = param.replace(/\+/g, ' ').split('=');
                // Firefox (pre 40) decodes `%3D` to `=`
                // https://github.com/sindresorhus/query-string/pull/37
                var key = parts.shift();
                var val = parts.length > 0 ? parts.join('=') : undefined;

                // missing `=` should be `null`:
                // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
                val = val === undefined ? null : decodeURIComponent(val);

                formatter(decodeURIComponent(key), val, ret);
            });

            return Object.keys(ret).sort().reduce(function (result, key) {
                var val = ret[key];
                if (Boolean(val) && typeof val === 'object' && !Array.isArray(val)) {
                    // Sort object keys, not values
                    result[key] = keysSorter(val);
                } else {
                    result[key] = val;
                }

                return result;
            }, Object.create(null));
        }

        /*
         * @author <sindresorhus>
         * https://github.com/sindresorhus/query-string/
         */
        _parserForArrayFormat(opts) {
            var result;

            switch (opts.arrayFormat) {
                case 'index':
                    return function (key, value, accumulator) {
                        result = /\[(\d*)\]$/.exec(key);

                        key = key.replace(/\[\d*\]$/, '');

                        if (!result) {
                            accumulator[key] = value;
                            return;
                        }

                        if (accumulator[key] === undefined) {
                            accumulator[key] = {};
                        }

                        accumulator[key][result[1]] = value;
                    };

                case 'bracket':
                    return function (key, value, accumulator) {
                        result = /(\[\])$/.exec(key);

                        key = key.replace(/\[\]$/, '');

                        if (!result || accumulator[key] === undefined) {
                            accumulator[key] = value;
                            return;
                        }

                        accumulator[key] = [].concat(accumulator[key], value);
                    };

                default:
                    return function (key, value, accumulator) {
                        if (accumulator[key] === undefined) {
                            accumulator[key] = value;
                            return;
                        }

                        accumulator[key] = [].concat(accumulator[key], value);
                    };
            }
        }
    }

    return Organizator_Util_QueryStringParser;
});
/*
 * Organizator_Validation_Validator
 */
define(
    'organizator/Component/Validation/Validator',[
        'organizator/Component/Nearley/Nearley',
        'organizator/Component/Validation/Grammar',
        'organizator/Component/Validation/ValidationResultBuilder',
        'organizator/Component/Validation/Interpreter',
        'organizator/Util/QueryStringParser'
    ],
    function (
        Organizator_Nearley,
        Organizator_Validation_Grammar,
        Organizator_Validation_ValidationResultBuilder,
        Organizator_Validation_Interpreter,
        Organizator_Util_QueryStringParser
        ) {
        class Organizator_Validation_Validator {
            constructor() {
                this.constraints = {};
            }

            addConstraint(constraint) {
                this.constraints[constraint.getName()] = constraint;
            }

            getConstraint(constraintName) {
                return this.constraints[constraintName];
            }

            validateHTMLElement(element, rules, grammar, parser, interpreter) {
                grammar = grammar || new Organizator_Validation_Grammar();
                parser = parser || new Organizator_Nearley.Organizator_Nearley_Parser(grammar.grammar.ParserRules, grammar.grammar.ParserStart);
                interpreter = interpreter || new Organizator_Validation_Interpreter();

                rules = rules || element.getAttribute('org-validate');

                let value = element.value;

                let validationInput = parser.feed(rules).results[0];
                
                interpreter.setInput(validationInput);
                interpreter.setValue(value);
                interpreter.setItem(element);

                let itemValidationResult = interpreter.run();

                return itemValidationResult;
            }

            validateForm(form) {
                let inputElements = form.querySelectorAll('[org-validate]');
                let validationResultBuilder = new Organizator_Validation_ValidationResultBuilder();
                let grammar = new Organizator_Validation_Grammar();
                let interpreter = new Organizator_Validation_Interpreter();

                for (var element of inputElements) {
                    if(element.hasAttribute('org-novalidate')){continue;}
                    
                    interpreter.reset();
                    let parser = new Organizator_Nearley.Organizator_Nearley_Parser(grammar.grammar.ParserRules, grammar.grammar.ParserStart);
                    let itemValidationResult = this.validateHTMLElement(element, null, grammar, parser, interpreter);

                    validationResultBuilder.addResult(itemValidationResult);
                }

                let validationResult = validationResultBuilder.getResult();

                return validationResult;
            }

            validateHTMLGroup(htmlElement) {
                return this.validateForm(htmlElement);
            }

            validateProperty(value, name, rules, grammar, parser, interpreter) {
                grammar = grammar || new Organizator_Validation_Grammar();
                parser = parser || new Organizator_Nearley.Organizator_Nearley_Parser(grammar.grammar.ParserRules, grammar.grammar.ParserStart);
                interpreter = interpreter || new Organizator_Validation_Interpreter();

                let validationInput = parser.feed(rules).results[0];

                interpreter.setInput(validationInput);
                interpreter.setValue(value);
                interpreter.setItem(name);

                let itemValidationResult = interpreter.run();

                return itemValidationResult;
            }

            validateObject(object, rules) {
                var validationRules = rules || object.OrganizatorValidationRules || null;
                var validationResultBuilder = new Organizator_Validation_ValidationResultBuilder();
                let grammar = new Organizator_Validation_Grammar();
                let interpreter = new Organizator_Validation_Interpreter();

                if (!validationRules) {
                    return true;
                }

                for (var property in validationRules) {
                    if (!object[property]) {
                        continue;
                    }

                    interpreter.reset();

                    let parser = new Organizator_Nearley.Organizator_Nearley_Parser(grammar.grammar.ParserRules, grammar.grammar.ParserStart);
                    let itemValidationResult = this.validateProperty(object[property], property, validationRules[property], grammar, parser, interpreter);

                    validationResultBuilder.addResult(itemValidationResult);
                }

                let validationResult = validationResultBuilder.getResult();

                return validationResult;
            }

            validateQueryString(queryString, rules) {
                var object = new Organizator_Util_QueryStringParser()._parseQueryString(queryString);
                
                return this.validateObject(object, rules);
            }

            validateValue(value, constraint) {
                if (this.constraints[constraint] === undefined) {
                    return;
                }
                return new this.constraints[constraint](null).validate(value);
            }
        }

        return Organizator_Validation_Validator;
    }
);
/*! Browser bundle of nunjucks 3.0.0  */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define('organizator/Component/Nunjucks/Nunjucks',[], factory);
	else if(typeof exports === 'object')
		nunjucks = factory();
	else
		nunjucks = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {
	'use strict';

	var lib = __webpack_require__(1);
	var env = __webpack_require__(2);
	var Loader = __webpack_require__(15);
	var loaders = __webpack_require__(14);
	var precompile = __webpack_require__(3);

	module.exports = {};
	module.exports.Environment = env.Environment;
	module.exports.Template = env.Template;

	module.exports.Loader = Loader;
	module.exports.FileSystemLoader = loaders.FileSystemLoader;
	module.exports.PrecompiledLoader = loaders.PrecompiledLoader;
	module.exports.WebLoader = loaders.WebLoader;

	module.exports.compiler = __webpack_require__(7);
	module.exports.parser = __webpack_require__(8);
	module.exports.lexer = __webpack_require__(9);
	module.exports.runtime = __webpack_require__(12);
	module.exports.lib = lib;
	module.exports.nodes = __webpack_require__(10);

	module.exports.installJinjaCompat = __webpack_require__(21);

	// A single instance of an environment, since this is so commonly used

	var e;
	module.exports.configure = function(templatesPath, opts) {
	    opts = opts || {};
	    if(lib.isObject(templatesPath)) {
	        opts = templatesPath;
	        templatesPath = null;
	    }

	    var TemplateLoader;
	    if(loaders.FileSystemLoader) {
	        TemplateLoader = new loaders.FileSystemLoader(templatesPath, {
	            watch: opts.watch,
	            noCache: opts.noCache
	        });
	    }
	    else if(loaders.WebLoader) {
	        TemplateLoader = new loaders.WebLoader(templatesPath, {
	            useCache: opts.web && opts.web.useCache,
	            async: opts.web && opts.web.async
	        });
	    }

	    e = new env.Environment(TemplateLoader, opts);

	    if(opts && opts.express) {
	        e.express(opts.express);
	    }

	    return e;
	};

	module.exports.compile = function(src, env, path, eagerCompile) {
	    if(!e) {
	        module.exports.configure();
	    }
	    return new module.exports.Template(src, env, path, eagerCompile);
	};

	module.exports.render = function(name, ctx, cb) {
	    if(!e) {
	        module.exports.configure();
	    }

	    return e.render(name, ctx, cb);
	};

	module.exports.renderString = function(src, ctx, cb) {
	    if(!e) {
	        module.exports.configure();
	    }

	    return e.renderString(src, ctx, cb);
	};

	if(precompile) {
	    module.exports.precompile = precompile.precompile;
	    module.exports.precompileString = precompile.precompileString;
	}


/***/ },
/* 1 */
/***/ function(module, exports) {

	'use strict';

	var ArrayProto = Array.prototype;
	var ObjProto = Object.prototype;

	var escapeMap = {
	    '&': '&amp;',
	    '"': '&quot;',
	    '\'': '&#39;',
	    '<': '&lt;',
	    '>': '&gt;'
	};

	var escapeRegex = /[&"'<>]/g;

	var lookupEscape = function(ch) {
	    return escapeMap[ch];
	};

	var exports = module.exports = {};

	exports.prettifyError = function(path, withInternals, err) {
	    // jshint -W022
	    // http://jslinterrors.com/do-not-assign-to-the-exception-parameter
	    if (!err.Update) {
	        // not one of ours, cast it
	        err = new exports.TemplateError(err);
	    }
	    err.Update(path);

	    // Unless they marked the dev flag, show them a trace from here
	    if (!withInternals) {
	        var old = err;
	        err = new Error(old.message);
	        err.name = old.name;
	    }

	    return err;
	};

	exports.TemplateError = function(message, lineno, colno) {
	    var err = this;

	    if (message instanceof Error) { // for casting regular js errors
	        err = message;
	        message = message.name + ': ' + message.message;

	        try {
	            if(err.name = '') {}
	        }
	        catch(e) {
	            // If we can't set the name of the error object in this
	            // environment, don't use it
	            err = this;
	        }
	    } else {
	        if(Error.captureStackTrace) {
	            Error.captureStackTrace(err);
	        }
	    }

	    err.name = 'Template render error';
	    err.message = message;
	    err.lineno = lineno;
	    err.colno = colno;
	    err.firstUpdate = true;

	    err.Update = function(path) {
	        var message = '(' + (path || 'unknown path') + ')';

	        // only show lineno + colno next to path of template
	        // where error occurred
	        if (this.firstUpdate) {
	            if(this.lineno && this.colno) {
	                message += ' [Line ' + this.lineno + ', Column ' + this.colno + ']';
	            }
	            else if(this.lineno) {
	                message += ' [Line ' + this.lineno + ']';
	            }
	        }

	        message += '\n ';
	        if (this.firstUpdate) {
	            message += ' ';
	        }

	        this.message = message + (this.message || '');
	        this.firstUpdate = false;
	        return this;
	    };

	    return err;
	};

	exports.TemplateError.prototype = Error.prototype;

	exports.escape = function(val) {
	  return val.replace(escapeRegex, lookupEscape);
	};

	exports.isFunction = function(obj) {
	    return ObjProto.toString.call(obj) === '[object Function]';
	};

	exports.isArray = Array.isArray || function(obj) {
	    return ObjProto.toString.call(obj) === '[object Array]';
	};

	exports.isString = function(obj) {
	    return ObjProto.toString.call(obj) === '[object String]';
	};

	exports.isObject = function(obj) {
	    return ObjProto.toString.call(obj) === '[object Object]';
	};

	exports.groupBy = function(obj, val) {
	    var result = {};
	    var iterator = exports.isFunction(val) ? val : function(obj) { return obj[val]; };
	    for(var i=0; i<obj.length; i++) {
	        var value = obj[i];
	        var key = iterator(value, i);
	        (result[key] || (result[key] = [])).push(value);
	    }
	    return result;
	};

	exports.toArray = function(obj) {
	    return Array.prototype.slice.call(obj);
	};

	exports.without = function(array) {
	    var result = [];
	    if (!array) {
	        return result;
	    }
	    var index = -1,
	    length = array.length,
	    contains = exports.toArray(arguments).slice(1);

	    while(++index < length) {
	        if(exports.indexOf(contains, array[index]) === -1) {
	            result.push(array[index]);
	        }
	    }
	    return result;
	};

	exports.extend = function(obj, obj2) {
	    for(var k in obj2) {
	        obj[k] = obj2[k];
	    }
	    return obj;
	};

	exports.repeat = function(char_, n) {
	    var str = '';
	    for(var i=0; i<n; i++) {
	        str += char_;
	    }
	    return str;
	};

	exports.each = function(obj, func, context) {
	    if(obj == null) {
	        return;
	    }

	    if(ArrayProto.each && obj.each === ArrayProto.each) {
	        obj.forEach(func, context);
	    }
	    else if(obj.length === +obj.length) {
	        for(var i=0, l=obj.length; i<l; i++) {
	            func.call(context, obj[i], i, obj);
	        }
	    }
	};

	exports.map = function(obj, func) {
	    var results = [];
	    if(obj == null) {
	        return results;
	    }

	    if(ArrayProto.map && obj.map === ArrayProto.map) {
	        return obj.map(func);
	    }

	    for(var i=0; i<obj.length; i++) {
	        results[results.length] = func(obj[i], i);
	    }

	    if(obj.length === +obj.length) {
	        results.length = obj.length;
	    }

	    return results;
	};

	exports.asyncIter = function(arr, iter, cb) {
	    var i = -1;

	    function next() {
	        i++;

	        if(i < arr.length) {
	            iter(arr[i], i, next, cb);
	        }
	        else {
	            cb();
	        }
	    }

	    next();
	};

	exports.asyncFor = function(obj, iter, cb) {
	    var keys = exports.keys(obj);
	    var len = keys.length;
	    var i = -1;

	    function next() {
	        i++;
	        var k = keys[i];

	        if(i < len) {
	            iter(k, obj[k], i, len, next);
	        }
	        else {
	            cb();
	        }
	    }

	    next();
	};

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Polyfill
	exports.indexOf = Array.prototype.indexOf ?
	    function (arr, searchElement, fromIndex) {
	        return Array.prototype.indexOf.call(arr, searchElement, fromIndex);
	    } :
	    function (arr, searchElement, fromIndex) {
	        var length = this.length >>> 0; // Hack to convert object.length to a UInt32

	        fromIndex = +fromIndex || 0;

	        if(Math.abs(fromIndex) === Infinity) {
	            fromIndex = 0;
	        }

	        if(fromIndex < 0) {
	            fromIndex += length;
	            if (fromIndex < 0) {
	                fromIndex = 0;
	            }
	        }

	        for(;fromIndex < length; fromIndex++) {
	            if (arr[fromIndex] === searchElement) {
	                return fromIndex;
	            }
	        }

	        return -1;
	    };

	if(!Array.prototype.map) {
	    Array.prototype.map = function() {
	        throw new Error('map is unimplemented for this js engine');
	    };
	}

	exports.keys = function(obj) {
	    if(Object.prototype.keys) {
	        return obj.keys();
	    }
	    else {
	        var keys = [];
	        for(var k in obj) {
	            if(obj.hasOwnProperty(k)) {
	                keys.push(k);
	            }
	        }
	        return keys;
	    }
	};

	exports.inOperator = function (key, val) {
	    if (exports.isArray(val)) {
	        return exports.indexOf(val, key) !== -1;
	    } else if (exports.isObject(val)) {
	        return key in val;
	    } else if (exports.isString(val)) {
	        return val.indexOf(key) !== -1;
	    } else {
	        throw new Error('Cannot use "in" operator to search for "'
	            + key + '" in unexpected types.');
	    }
	};


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var path = __webpack_require__(3);
	var asap = __webpack_require__(4);
	var lib = __webpack_require__(1);
	var Obj = __webpack_require__(6);
	var compiler = __webpack_require__(7);
	var builtin_filters = __webpack_require__(13);
	var builtin_loaders = __webpack_require__(14);
	var runtime = __webpack_require__(12);
	var globals = __webpack_require__(17);
	var waterfall = __webpack_require__(18);
	var Frame = runtime.Frame;
	var Template;

	// Unconditionally load in this loader, even if no other ones are
	// included (possible in the slim browser build)
	builtin_loaders.PrecompiledLoader = __webpack_require__(16);

	// If the user is using the async API, *always* call it
	// asynchronously even if the template was synchronous.
	function callbackAsap(cb, err, res) {
	    asap(function() { cb(err, res); });
	}

	var Environment = Obj.extend({
	    init: function(loaders, opts) {
	        // The dev flag determines the trace that'll be shown on errors.
	        // If set to true, returns the full trace from the error point,
	        // otherwise will return trace starting from Template.render
	        // (the full trace from within nunjucks may confuse developers using
	        //  the library)
	        // defaults to false
	        opts = this.opts = opts || {};
	        this.opts.dev = !!opts.dev;

	        // The autoescape flag sets global autoescaping. If true,
	        // every string variable will be escaped by default.
	        // If false, strings can be manually escaped using the `escape` filter.
	        // defaults to true
	        this.opts.autoescape = opts.autoescape != null ? opts.autoescape : true;

	        // If true, this will make the system throw errors if trying
	        // to output a null or undefined value
	        this.opts.throwOnUndefined = !!opts.throwOnUndefined;
	        this.opts.trimBlocks = !!opts.trimBlocks;
	        this.opts.lstripBlocks = !!opts.lstripBlocks;

	        this.loaders = [];

	        if(!loaders) {
	            // The filesystem loader is only available server-side
	            if(builtin_loaders.FileSystemLoader) {
	                this.loaders = [new builtin_loaders.FileSystemLoader('views')];
	            }
	            else if(builtin_loaders.WebLoader) {
	                this.loaders = [new builtin_loaders.WebLoader('/views')];
	            }
	        }
	        else {
	            this.loaders = lib.isArray(loaders) ? loaders : [loaders];
	        }

	        // It's easy to use precompiled templates: just include them
	        // before you configure nunjucks and this will automatically
	        // pick it up and use it
	        if((true) && window.nunjucksPrecompiled) {
	            this.loaders.unshift(
	                new builtin_loaders.PrecompiledLoader(window.nunjucksPrecompiled)
	            );
	        }

	        this.initCache();

	        this.globals = globals();
	        this.filters = {};
	        this.asyncFilters = [];
	        this.extensions = {};
	        this.extensionsList = [];

	        for(var name in builtin_filters) {
	            this.addFilter(name, builtin_filters[name]);
	        }
	    },

	    initCache: function() {
	        // Caching and cache busting
	        lib.each(this.loaders, function(loader) {
	            loader.cache = {};

	            if(typeof loader.on === 'function') {
	                loader.on('update', function(template) {
	                    loader.cache[template] = null;
	                });
	            }
	        });
	    },

	    addExtension: function(name, extension) {
	        extension._name = name;
	        this.extensions[name] = extension;
	        this.extensionsList.push(extension);
	        return this;
	    },

	    removeExtension: function(name) {
	        var extension = this.getExtension(name);
	        if (!extension) return;

	        this.extensionsList = lib.without(this.extensionsList, extension);
	        delete this.extensions[name];
	    },

	    getExtension: function(name) {
	        return this.extensions[name];
	    },

	    hasExtension: function(name) {
	        return !!this.extensions[name];
	    },

	    addGlobal: function(name, value) {
	        this.globals[name] = value;
	        return this;
	    },

	    getGlobal: function(name) {
	        if(typeof this.globals[name] === 'undefined') {
	            throw new Error('global not found: ' + name);
	        }
	        return this.globals[name];
	    },

	    addFilter: function(name, func, async) {
	        var wrapped = func;

	        if(async) {
	            this.asyncFilters.push(name);
	        }
	        this.filters[name] = wrapped;
	        return this;
	    },

	    getFilter: function(name) {
	        if(!this.filters[name]) {
	            throw new Error('filter not found: ' + name);
	        }
	        return this.filters[name];
	    },

	    resolveTemplate: function(loader, parentName, filename) {
	        var isRelative = (loader.isRelative && parentName)? loader.isRelative(filename) : false;
	        return (isRelative && loader.resolve)? loader.resolve(parentName, filename) : filename;
	    },

	    getTemplate: function(name, eagerCompile, parentName, ignoreMissing, cb) {
	        var that = this;
	        var tmpl = null;
	        if(name && name.raw) {
	            // this fixes autoescape for templates referenced in symbols
	            name = name.raw;
	        }

	        if(lib.isFunction(parentName)) {
	            cb = parentName;
	            parentName = null;
	            eagerCompile = eagerCompile || false;
	        }

	        if(lib.isFunction(eagerCompile)) {
	            cb = eagerCompile;
	            eagerCompile = false;
	        }

	        if (name instanceof Template) {
	             tmpl = name;
	        }
	        else if(typeof name !== 'string') {
	            throw new Error('template names must be a string: ' + name);
	        }
	        else {
	            for (var i = 0; i < this.loaders.length; i++) {
	                var _name = this.resolveTemplate(this.loaders[i], parentName, name);
	                tmpl = this.loaders[i].cache[_name];
	                if (tmpl) break;
	            }
	        }

	        if(tmpl) {
	            if(eagerCompile) {
	                tmpl.compile();
	            }

	            if(cb) {
	                cb(null, tmpl);
	            }
	            else {
	                return tmpl;
	            }
	        } else {
	            var syncResult;
	            var _this = this;

	            var createTemplate = function(err, info) {
	                if(!info && !err) {
	                    if(!ignoreMissing) {
	                        err = new Error('template not found: ' + name);
	                    }
	                }

	                if (err) {
	                    if(cb) {
	                        cb(err);
	                    }
	                    else {
	                        throw err;
	                    }
	                }
	                else {
	                    var tmpl;
	                    if(info) {
	                        tmpl = new Template(info.src, _this,
	                                            info.path, eagerCompile);

	                        if(!info.noCache) {
	                            info.loader.cache[name] = tmpl;
	                        }
	                    }
	                    else {
	                        tmpl = new Template('', _this,
	                                            '', eagerCompile);
	                    }

	                    if(cb) {
	                        cb(null, tmpl);
	                    }
	                    else {
	                        syncResult = tmpl;
	                    }
	                }
	            };

	            lib.asyncIter(this.loaders, function(loader, i, next, done) {
	                function handle(err, src) {
	                    if(err) {
	                        done(err);
	                    }
	                    else if(src) {
	                        src.loader = loader;
	                        done(null, src);
	                    }
	                    else {
	                        next();
	                    }
	                }

	                // Resolve name relative to parentName
	                name = that.resolveTemplate(loader, parentName, name);

	                if(loader.async) {
	                    loader.getSource(name, handle);
	                }
	                else {
	                    handle(null, loader.getSource(name));
	                }
	            }, createTemplate);

	            return syncResult;
	        }
	    },

	    express: function(app) {
	        var env = this;

	        function NunjucksView(name, opts) {
	            this.name          = name;
	            this.path          = name;
	            this.defaultEngine = opts.defaultEngine;
	            this.ext           = path.extname(name);
	            if (!this.ext && !this.defaultEngine) throw new Error('No default engine was specified and no extension was provided.');
	            if (!this.ext) this.name += (this.ext = ('.' !== this.defaultEngine[0] ? '.' : '') + this.defaultEngine);
	        }

	        NunjucksView.prototype.render = function(opts, cb) {
	          env.render(this.name, opts, cb);
	        };

	        app.set('view', NunjucksView);
	        app.set('nunjucksEnv', this);
	        return this;
	    },

	    render: function(name, ctx, cb) {
	        if(lib.isFunction(ctx)) {
	            cb = ctx;
	            ctx = null;
	        }

	        // We support a synchronous API to make it easier to migrate
	        // existing code to async. This works because if you don't do
	        // anything async work, the whole thing is actually run
	        // synchronously.
	        var syncResult = null;

	        this.getTemplate(name, function(err, tmpl) {
	            if(err && cb) {
	                callbackAsap(cb, err);
	            }
	            else if(err) {
	                throw err;
	            }
	            else {
	                syncResult = tmpl.render(ctx, cb);
	            }
	        });

	        return syncResult;
	    },

	    renderString: function(src, ctx, opts, cb) {
	        if(lib.isFunction(opts)) {
	            cb = opts;
	            opts = {};
	        }
	        opts = opts || {};

	        var tmpl = new Template(src, this, opts.path);
	        return tmpl.render(ctx, cb);
	    },

	    waterfall: waterfall
	});

	var Context = Obj.extend({
	    init: function(ctx, blocks, env) {
	        // Has to be tied to an environment so we can tap into its globals.
	        this.env = env || new Environment();

	        // Make a duplicate of ctx
	        this.ctx = {};
	        for(var k in ctx) {
	            if(ctx.hasOwnProperty(k)) {
	                this.ctx[k] = ctx[k];
	            }
	        }

	        this.blocks = {};
	        this.exported = [];

	        for(var name in blocks) {
	            this.addBlock(name, blocks[name]);
	        }
	    },

	    lookup: function(name) {
	        // This is one of the most called functions, so optimize for
	        // the typical case where the name isn't in the globals
	        if(name in this.env.globals && !(name in this.ctx)) {
	            return this.env.globals[name];
	        }
	        else {
	            return this.ctx[name];
	        }
	    },

	    setVariable: function(name, val) {
	        this.ctx[name] = val;
	    },

	    getVariables: function() {
	        return this.ctx;
	    },

	    addBlock: function(name, block) {
	        this.blocks[name] = this.blocks[name] || [];
	        this.blocks[name].push(block);
	        return this;
	    },

	    getBlock: function(name) {
	        if(!this.blocks[name]) {
	            throw new Error('unknown block "' + name + '"');
	        }

	        return this.blocks[name][0];
	    },

	    getSuper: function(env, name, block, frame, runtime, cb) {
	        var idx = lib.indexOf(this.blocks[name] || [], block);
	        var blk = this.blocks[name][idx + 1];
	        var context = this;

	        if(idx === -1 || !blk) {
	            throw new Error('no super block available for "' + name + '"');
	        }

	        blk(env, context, frame, runtime, cb);
	    },

	    addExport: function(name) {
	        this.exported.push(name);
	    },

	    getExported: function() {
	        var exported = {};
	        for(var i=0; i<this.exported.length; i++) {
	            var name = this.exported[i];
	            exported[name] = this.ctx[name];
	        }
	        return exported;
	    }
	});

	Template = Obj.extend({
	    init: function (src, env, path, eagerCompile) {
	        this.env = env || new Environment();

	        if(lib.isObject(src)) {
	            switch(src.type) {
	            case 'code': this.tmplProps = src.obj; break;
	            case 'string': this.tmplStr = src.obj; break;
	            }
	        }
	        else if(lib.isString(src)) {
	            this.tmplStr = src;
	        }
	        else {
	            throw new Error('src must be a string or an object describing ' +
	                            'the source');
	        }

	        this.path = path;

	        if(eagerCompile) {
	            var _this = this;
	            try {
	                _this._compile();
	            }
	            catch(err) {
	                throw lib.prettifyError(this.path, this.env.opts.dev, err);
	            }
	        }
	        else {
	            this.compiled = false;
	        }
	    },

	    render: function(ctx, parentFrame, cb) {
	        if (typeof ctx === 'function') {
	            cb = ctx;
	            ctx = {};
	        }
	        else if (typeof parentFrame === 'function') {
	            cb = parentFrame;
	            parentFrame = null;
	        }

	        var forceAsync = true;
	        if(parentFrame) {
	            // If there is a frame, we are being called from internal
	            // code of another template, and the internal system
	            // depends on the sync/async nature of the parent template
	            // to be inherited, so force an async callback
	            forceAsync = false;
	        }

	        var _this = this;
	        // Catch compile errors for async rendering
	        try {
	            _this.compile();
	        } catch (_err) {
	            var err = lib.prettifyError(this.path, this.env.opts.dev, _err);
	            if (cb) return callbackAsap(cb, err);
	            else throw err;
	        }

	        var context = new Context(ctx || {}, _this.blocks, _this.env);
	        var frame = parentFrame ? parentFrame.push(true) : new Frame();
	        frame.topLevel = true;
	        var syncResult = null;

	        _this.rootRenderFunc(
	            _this.env,
	            context,
	            frame || new Frame(),
	            runtime,
	            function(err, res) {
	                if(err) {
	                    err = lib.prettifyError(_this.path, _this.env.opts.dev, err);
	                }

	                if(cb) {
	                    if(forceAsync) {
	                        callbackAsap(cb, err, res);
	                    }
	                    else {
	                        cb(err, res);
	                    }
	                }
	                else {
	                    if(err) { throw err; }
	                    syncResult = res;
	                }
	            }
	        );

	        return syncResult;
	    },


	    getExported: function(ctx, parentFrame, cb) {
	        if (typeof ctx === 'function') {
	            cb = ctx;
	            ctx = {};
	        }

	        if (typeof parentFrame === 'function') {
	            cb = parentFrame;
	            parentFrame = null;
	        }

	        // Catch compile errors for async rendering
	        try {
	            this.compile();
	        } catch (e) {
	            if (cb) return cb(e);
	            else throw e;
	        }

	        var frame = parentFrame ? parentFrame.push() : new Frame();
	        frame.topLevel = true;

	        // Run the rootRenderFunc to populate the context with exported vars
	        var context = new Context(ctx || {}, this.blocks, this.env);
	        this.rootRenderFunc(this.env,
	                            context,
	                            frame,
	                            runtime,
	                            function(err) {
	        		        if ( err ) {
	        			    cb(err, null);
	        		        } else {
	        			    cb(null, context.getExported());
	        		        }
	                            });
	    },

	    compile: function() {
	        if(!this.compiled) {
	            this._compile();
	        }
	    },

	    _compile: function() {
	        var props;

	        if(this.tmplProps) {
	            props = this.tmplProps;
	        }
	        else {
	            var source = compiler.compile(this.tmplStr,
	                                          this.env.asyncFilters,
	                                          this.env.extensionsList,
	                                          this.path,
	                                          this.env.opts);

	            /* jslint evil: true */
	            var func = new Function(source);
	            props = func();
	        }

	        this.blocks = this._getBlocks(props);
	        this.rootRenderFunc = props.root;
	        this.compiled = true;
	    },

	    _getBlocks: function(props) {
	        var blocks = {};

	        for(var k in props) {
	            if(k.slice(0, 2) === 'b_') {
	                blocks[k.slice(2)] = props[k];
	            }
	        }

	        return blocks;
	    }
	});

	module.exports = {
	    Environment: Environment,
	    Template: Template
	};


/***/ },
/* 3 */
/***/ function(module, exports) {

	

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	// rawAsap provides everything we need except exception management.
	var rawAsap = __webpack_require__(5);
	// RawTasks are recycled to reduce GC churn.
	var freeTasks = [];
	// We queue errors to ensure they are thrown in right order (FIFO).
	// Array-as-queue is good enough here, since we are just dealing with exceptions.
	var pendingErrors = [];
	var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);

	function throwFirstError() {
	    if (pendingErrors.length) {
	        throw pendingErrors.shift();
	    }
	}

	/**
	 * Calls a task as soon as possible after returning, in its own event, with priority
	 * over other events like animation, reflow, and repaint. An error thrown from an
	 * event will not interrupt, nor even substantially slow down the processing of
	 * other events, but will be rather postponed to a lower priority event.
	 * @param {{call}} task A callable object, typically a function that takes no
	 * arguments.
	 */
	module.exports = asap;
	function asap(task) {
	    var rawTask;
	    if (freeTasks.length) {
	        rawTask = freeTasks.pop();
	    } else {
	        rawTask = new RawTask();
	    }
	    rawTask.task = task;
	    rawAsap(rawTask);
	}

	// We wrap tasks with recyclable task objects.  A task object implements
	// `call`, just like a function.
	function RawTask() {
	    this.task = null;
	}

	// The sole purpose of wrapping the task is to catch the exception and recycle
	// the task object after its single use.
	RawTask.prototype.call = function () {
	    try {
	        this.task.call();
	    } catch (error) {
	        if (asap.onerror) {
	            // This hook exists purely for testing purposes.
	            // Its name will be periodically randomized to break any code that
	            // depends on its existence.
	            asap.onerror(error);
	        } else {
	            // In a web browser, exceptions are not fatal. However, to avoid
	            // slowing down the queue of pending tasks, we rethrow the error in a
	            // lower priority turn.
	            pendingErrors.push(error);
	            requestErrorThrow();
	        }
	    } finally {
	        this.task = null;
	        freeTasks[freeTasks.length] = this;
	    }
	};


/***/ },
/* 5 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";

	// Use the fastest means possible to execute a task in its own turn, with
	// priority over other events including IO, animation, reflow, and redraw
	// events in browsers.
	//
	// An exception thrown by a task will permanently interrupt the processing of
	// subsequent tasks. The higher level `asap` function ensures that if an
	// exception is thrown by a task, that the task queue will continue flushing as
	// soon as possible, but if you use `rawAsap` directly, you are responsible to
	// either ensure that no exceptions are thrown from your task, or to manually
	// call `rawAsap.requestFlush` if an exception is thrown.
	module.exports = rawAsap;
	function rawAsap(task) {
	    if (!queue.length) {
	        requestFlush();
	        flushing = true;
	    }
	    // Equivalent to push, but avoids a function call.
	    queue[queue.length] = task;
	}

	var queue = [];
	// Once a flush has been requested, no further calls to `requestFlush` are
	// necessary until the next `flush` completes.
	var flushing = false;
	// `requestFlush` is an implementation-specific method that attempts to kick
	// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
	// the event queue before yielding to the browser's own event loop.
	var requestFlush;
	// The position of the next task to execute in the task queue. This is
	// preserved between calls to `flush` so that it can be resumed if
	// a task throws an exception.
	var index = 0;
	// If a task schedules additional tasks recursively, the task queue can grow
	// unbounded. To prevent memory exhaustion, the task queue will periodically
	// truncate already-completed tasks.
	var capacity = 1024;

	// The flush function processes all tasks that have been scheduled with
	// `rawAsap` unless and until one of those tasks throws an exception.
	// If a task throws an exception, `flush` ensures that its state will remain
	// consistent and will resume where it left off when called again.
	// However, `flush` does not make any arrangements to be called again if an
	// exception is thrown.
	function flush() {
	    while (index < queue.length) {
	        var currentIndex = index;
	        // Advance the index before calling the task. This ensures that we will
	        // begin flushing on the next task the task throws an error.
	        index = index + 1;
	        queue[currentIndex].call();
	        // Prevent leaking memory for long chains of recursive calls to `asap`.
	        // If we call `asap` within tasks scheduled by `asap`, the queue will
	        // grow, but to avoid an O(n) walk for every task we execute, we don't
	        // shift tasks off the queue after they have been executed.
	        // Instead, we periodically shift 1024 tasks off the queue.
	        if (index > capacity) {
	            // Manually shift all values starting at the index back to the
	            // beginning of the queue.
	            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
	                queue[scan] = queue[scan + index];
	            }
	            queue.length -= index;
	            index = 0;
	        }
	    }
	    queue.length = 0;
	    index = 0;
	    flushing = false;
	}

	// `requestFlush` is implemented using a strategy based on data collected from
	// every available SauceLabs Selenium web driver worker at time of writing.
	// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593

	// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
	// have WebKitMutationObserver but not un-prefixed MutationObserver.
	// Must use `global` instead of `window` to work in both frames and web
	// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.
	var BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;

	// MutationObservers are desirable because they have high priority and work
	// reliably everywhere they are implemented.
	// They are implemented in all modern browsers.
	//
	// - Android 4-4.3
	// - Chrome 26-34
	// - Firefox 14-29
	// - Internet Explorer 11
	// - iPad Safari 6-7.1
	// - iPhone Safari 7-7.1
	// - Safari 6-7
	if (typeof BrowserMutationObserver === "function") {
	    requestFlush = makeRequestCallFromMutationObserver(flush);

	// MessageChannels are desirable because they give direct access to the HTML
	// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
	// 11-12, and in web workers in many engines.
	// Although message channels yield to any queued rendering and IO tasks, they
	// would be better than imposing the 4ms delay of timers.
	// However, they do not work reliably in Internet Explorer or Safari.

	// Internet Explorer 10 is the only browser that has setImmediate but does
	// not have MutationObservers.
	// Although setImmediate yields to the browser's renderer, it would be
	// preferrable to falling back to setTimeout since it does not have
	// the minimum 4ms penalty.
	// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
	// Desktop to a lesser extent) that renders both setImmediate and
	// MessageChannel useless for the purposes of ASAP.
	// https://github.com/kriskowal/q/issues/396

	// Timers are implemented universally.
	// We fall back to timers in workers in most engines, and in foreground
	// contexts in the following browsers.
	// However, note that even this simple case requires nuances to operate in a
	// broad spectrum of browsers.
	//
	// - Firefox 3-13
	// - Internet Explorer 6-9
	// - iPad Safari 4.3
	// - Lynx 2.8.7
	} else {
	    requestFlush = makeRequestCallFromTimer(flush);
	}

	// `requestFlush` requests that the high priority event queue be flushed as
	// soon as possible.
	// This is useful to prevent an error thrown in a task from stalling the event
	// queue if the exception handled by Node.js’s
	// `process.on("uncaughtException")` or by a domain.
	rawAsap.requestFlush = requestFlush;

	// To request a high priority event, we induce a mutation observer by toggling
	// the text of a text node between "1" and "-1".
	function makeRequestCallFromMutationObserver(callback) {
	    var toggle = 1;
	    var observer = new BrowserMutationObserver(callback);
	    var node = document.createTextNode("");
	    observer.observe(node, {characterData: true});
	    return function requestCall() {
	        toggle = -toggle;
	        node.data = toggle;
	    };
	}

	// The message channel technique was discovered by Malte Ubl and was the
	// original foundation for this library.
	// http://www.nonblocking.io/2011/06/windownexttick.html

	// Safari 6.0.5 (at least) intermittently fails to create message ports on a
	// page's first load. Thankfully, this version of Safari supports
	// MutationObservers, so we don't need to fall back in that case.

	// function makeRequestCallFromMessageChannel(callback) {
	//     var channel = new MessageChannel();
	//     channel.port1.onmessage = callback;
	//     return function requestCall() {
	//         channel.port2.postMessage(0);
	//     };
	// }

	// For reasons explained above, we are also unable to use `setImmediate`
	// under any circumstances.
	// Even if we were, there is another bug in Internet Explorer 10.
	// It is not sufficient to assign `setImmediate` to `requestFlush` because
	// `setImmediate` must be called *by name* and therefore must be wrapped in a
	// closure.
	// Never forget.

	// function makeRequestCallFromSetImmediate(callback) {
	//     return function requestCall() {
	//         setImmediate(callback);
	//     };
	// }

	// Safari 6.0 has a problem where timers will get lost while the user is
	// scrolling. This problem does not impact ASAP because Safari 6.0 supports
	// mutation observers, so that implementation is used instead.
	// However, if we ever elect to use timers in Safari, the prevalent work-around
	// is to add a scroll event listener that calls for a flush.

	// `setTimeout` does not call the passed callback if the delay is less than
	// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
	// even then.

	function makeRequestCallFromTimer(callback) {
	    return function requestCall() {
	        // We dispatch a timeout with a specified delay of 0 for engines that
	        // can reliably accommodate that request. This will usually be snapped
	        // to a 4 milisecond delay, but once we're flushing, there's no delay
	        // between events.
	        var timeoutHandle = setTimeout(handleTimer, 0);
	        // However, since this timer gets frequently dropped in Firefox
	        // workers, we enlist an interval handle that will try to fire
	        // an event 20 times per second until it succeeds.
	        var intervalHandle = setInterval(handleTimer, 50);

	        function handleTimer() {
	            // Whichever timer succeeds will cancel both timers and
	            // execute the callback.
	            clearTimeout(timeoutHandle);
	            clearInterval(intervalHandle);
	            callback();
	        }
	    };
	}

	// This is for `asap.js` only.
	// Its name will be periodically randomized to break any code that depends on
	// its existence.
	rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;

	// ASAP was originally a nextTick shim included in Q. This was factored out
	// into this ASAP package. It was later adapted to RSVP which made further
	// amendments. These decisions, particularly to marginalize MessageChannel and
	// to capture the MutationObserver implementation in a closure, were integrated
	// back into ASAP proper.
	// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 6 */
/***/ function(module, exports) {

	'use strict';

	// A simple class system, more documentation to come

	function extend(cls, name, props) {
	    // This does that same thing as Object.create, but with support for IE8
	    var F = function() {};
	    F.prototype = cls.prototype;
	    var prototype = new F();

	    // jshint undef: false
	    var fnTest = /xyz/.test(function(){ xyz; }) ? /\bparent\b/ : /.*/;
	    props = props || {};

	    for(var k in props) {
	        var src = props[k];
	        var parent = prototype[k];

	        if(typeof parent === 'function' &&
	           typeof src === 'function' &&
	           fnTest.test(src)) {
	            /*jshint -W083 */
	            prototype[k] = (function (src, parent) {
	                return function() {
	                    // Save the current parent method
	                    var tmp = this.parent;

	                    // Set parent to the previous method, call, and restore
	                    this.parent = parent;
	                    var res = src.apply(this, arguments);
	                    this.parent = tmp;

	                    return res;
	                };
	            })(src, parent);
	        }
	        else {
	            prototype[k] = src;
	        }
	    }

	    prototype.typename = name;

	    var new_cls = function() {
	        if(prototype.init) {
	            prototype.init.apply(this, arguments);
	        }
	    };

	    new_cls.prototype = prototype;
	    new_cls.prototype.constructor = new_cls;

	    new_cls.extend = function(name, props) {
	        if(typeof name === 'object') {
	            props = name;
	            name = 'anonymous';
	        }
	        return extend(new_cls, name, props);
	    };

	    return new_cls;
	}

	module.exports = extend(Object, 'Object', {});


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var lib = __webpack_require__(1);
	var parser = __webpack_require__(8);
	var transformer = __webpack_require__(11);
	var nodes = __webpack_require__(10);
	// jshint -W079
	var Object = __webpack_require__(6);
	var Frame = __webpack_require__(12).Frame;

	// These are all the same for now, but shouldn't be passed straight
	// through
	var compareOps = {
	    '==': '==',
	    '===': '===',
	    '!=': '!=',
	    '!==': '!==',
	    '<': '<',
	    '>': '>',
	    '<=': '<=',
	    '>=': '>='
	};

	// A common pattern is to emit binary operators
	function binOpEmitter(str) {
	    return function(node, frame) {
	        this.compile(node.left, frame);
	        this.emit(str);
	        this.compile(node.right, frame);
	    };
	}

	var Compiler = Object.extend({
	    init: function(templateName, throwOnUndefined) {
	        this.templateName = templateName;
	        this.codebuf = [];
	        this.lastId = 0;
	        this.buffer = null;
	        this.bufferStack = [];
	        this.scopeClosers = '';
	        this.inBlock = false;
	        this.throwOnUndefined = throwOnUndefined;
	    },

	    fail: function (msg, lineno, colno) {
	        if (lineno !== undefined) lineno += 1;
	        if (colno !== undefined) colno += 1;

	        throw new lib.TemplateError(msg, lineno, colno);
	    },

	    pushBufferId: function(id) {
	        this.bufferStack.push(this.buffer);
	        this.buffer = id;
	        this.emit('var ' + this.buffer + ' = "";');
	    },

	    popBufferId: function() {
	        this.buffer = this.bufferStack.pop();
	    },

	    emit: function(code) {
	        this.codebuf.push(code);
	    },

	    emitLine: function(code) {
	        this.emit(code + '\n');
	    },

	    emitLines: function() {
	        lib.each(lib.toArray(arguments), function(line) {
	            this.emitLine(line);
	        }, this);
	    },

	    emitFuncBegin: function(name) {
	        this.buffer = 'output';
	        this.scopeClosers = '';
	        this.emitLine('function ' + name + '(env, context, frame, runtime, cb) {');
	        this.emitLine('var lineno = null;');
	        this.emitLine('var colno = null;');
	        this.emitLine('var ' + this.buffer + ' = "";');
	        this.emitLine('try {');
	    },

	    emitFuncEnd: function(noReturn) {
	        if(!noReturn) {
	            this.emitLine('cb(null, ' + this.buffer +');');
	        }

	        this.closeScopeLevels();
	        this.emitLine('} catch (e) {');
	        this.emitLine('  cb(runtime.handleError(e, lineno, colno));');
	        this.emitLine('}');
	        this.emitLine('}');
	        this.buffer = null;
	    },

	    addScopeLevel: function() {
	        this.scopeClosers += '})';
	    },

	    closeScopeLevels: function() {
	        this.emitLine(this.scopeClosers + ';');
	        this.scopeClosers = '';
	    },

	    withScopedSyntax: function(func) {
	        var scopeClosers = this.scopeClosers;
	        this.scopeClosers = '';

	        func.call(this);

	        this.closeScopeLevels();
	        this.scopeClosers = scopeClosers;
	    },

	    makeCallback: function(res) {
	        var err = this.tmpid();

	        return 'function(' + err + (res ? ',' + res : '') + ') {\n' +
	            'if(' + err + ') { cb(' + err + '); return; }';
	    },

	    tmpid: function() {
	        this.lastId++;
	        return 't_' + this.lastId;
	    },

	    _templateName: function() {
	        return this.templateName == null? 'undefined' : JSON.stringify(this.templateName);
	    },

	    _compileChildren: function(node, frame) {
	        var children = node.children;
	        for(var i=0, l=children.length; i<l; i++) {
	            this.compile(children[i], frame);
	        }
	    },

	    _compileAggregate: function(node, frame, startChar, endChar) {
	        if(startChar) {
	            this.emit(startChar);
	        }

	        for(var i=0; i<node.children.length; i++) {
	            if(i > 0) {
	                this.emit(',');
	            }

	            this.compile(node.children[i], frame);
	        }

	        if(endChar) {
	            this.emit(endChar);
	        }
	    },

	    _compileExpression: function(node, frame) {
	        // TODO: I'm not really sure if this type check is worth it or
	        // not.
	        this.assertType(
	            node,
	            nodes.Literal,
	            nodes.Symbol,
	            nodes.Group,
	            nodes.Array,
	            nodes.Dict,
	            nodes.FunCall,
	            nodes.Caller,
	            nodes.Filter,
	            nodes.LookupVal,
	            nodes.Compare,
	            nodes.InlineIf,
	            nodes.In,
	            nodes.And,
	            nodes.Or,
	            nodes.Not,
	            nodes.Add,
	            nodes.Concat,
	            nodes.Sub,
	            nodes.Mul,
	            nodes.Div,
	            nodes.FloorDiv,
	            nodes.Mod,
	            nodes.Pow,
	            nodes.Neg,
	            nodes.Pos,
	            nodes.Compare,
	            nodes.NodeList
	        );
	        this.compile(node, frame);
	    },

	    assertType: function(node /*, types */) {
	        var types = lib.toArray(arguments).slice(1);
	        var success = false;

	        for(var i=0; i<types.length; i++) {
	            if(node instanceof types[i]) {
	                success = true;
	            }
	        }

	        if(!success) {
	            this.fail('assertType: invalid type: ' + node.typename,
	                      node.lineno,
	                      node.colno);
	        }
	    },

	    compileCallExtension: function(node, frame, async) {
	        var args = node.args;
	        var contentArgs = node.contentArgs;
	        var autoescape = typeof node.autoescape === 'boolean' ? node.autoescape : true;

	        if(!async) {
	            this.emit(this.buffer + ' += runtime.suppressValue(');
	        }

	        this.emit('env.getExtension("' + node.extName + '")["' + node.prop + '"](');
	        this.emit('context');

	        if(args || contentArgs) {
	            this.emit(',');
	        }

	        if(args) {
	            if(!(args instanceof nodes.NodeList)) {
	                this.fail('compileCallExtension: arguments must be a NodeList, ' +
	                          'use `parser.parseSignature`');
	            }

	            lib.each(args.children, function(arg, i) {
	                // Tag arguments are passed normally to the call. Note
	                // that keyword arguments are turned into a single js
	                // object as the last argument, if they exist.
	                this._compileExpression(arg, frame);

	                if(i !== args.children.length - 1 || contentArgs.length) {
	                    this.emit(',');
	                }
	            }, this);
	        }

	        if(contentArgs.length) {
	            lib.each(contentArgs, function(arg, i) {
	                if(i > 0) {
	                    this.emit(',');
	                }

	                if(arg) {
	                    var id = this.tmpid();

	                    this.emitLine('function(cb) {');
	                    this.emitLine('if(!cb) { cb = function(err) { if(err) { throw err; }}}');
	                    this.pushBufferId(id);

	                    this.withScopedSyntax(function() {
	                        this.compile(arg, frame);
	                        this.emitLine('cb(null, ' + id + ');');
	                    });

	                    this.popBufferId();
	                    this.emitLine('return ' + id + ';');
	                    this.emitLine('}');
	                }
	                else {
	                    this.emit('null');
	                }
	            }, this);
	        }

	        if(async) {
	            var res = this.tmpid();
	            this.emitLine(', ' + this.makeCallback(res));
	            this.emitLine(this.buffer + ' += runtime.suppressValue(' + res + ', ' + autoescape + ' && env.opts.autoescape);');
	            this.addScopeLevel();
	        }
	        else {
	            this.emit(')');
	            this.emit(', ' + autoescape + ' && env.opts.autoescape);\n');
	        }
	    },

	    compileCallExtensionAsync: function(node, frame) {
	        this.compileCallExtension(node, frame, true);
	    },

	    compileNodeList: function(node, frame) {
	        this._compileChildren(node, frame);
	    },

	    compileLiteral: function(node) {
	        if(typeof node.value === 'string') {
	            var val = node.value.replace(/\\/g, '\\\\');
	            val = val.replace(/"/g, '\\"');
	            val = val.replace(/\n/g, '\\n');
	            val = val.replace(/\r/g, '\\r');
	            val = val.replace(/\t/g, '\\t');
	            this.emit('"' + val  + '"');
	        }
	        else if (node.value === null) {
	            this.emit('null');
	        }
	        else {
	            this.emit(node.value.toString());
	        }
	    },

	    compileSymbol: function(node, frame) {
	        var name = node.value;
	        var v;

	        if((v = frame.lookup(name))) {
	            this.emit(v);
	        }
	        else {
	            this.emit('runtime.contextOrFrameLookup(' +
	                      'context, frame, "' + name + '")');
	        }
	    },

	    compileGroup: function(node, frame) {
	        this._compileAggregate(node, frame, '(', ')');
	    },

	    compileArray: function(node, frame) {
	        this._compileAggregate(node, frame, '[', ']');
	    },

	    compileDict: function(node, frame) {
	        this._compileAggregate(node, frame, '{', '}');
	    },

	    compilePair: function(node, frame) {
	        var key = node.key;
	        var val = node.value;

	        if(key instanceof nodes.Symbol) {
	            key = new nodes.Literal(key.lineno, key.colno, key.value);
	        }
	        else if(!(key instanceof nodes.Literal &&
	                  typeof key.value === 'string')) {
	            this.fail('compilePair: Dict keys must be strings or names',
	                      key.lineno,
	                      key.colno);
	        }

	        this.compile(key, frame);
	        this.emit(': ');
	        this._compileExpression(val, frame);
	    },

	    compileInlineIf: function(node, frame) {
	        this.emit('(');
	        this.compile(node.cond, frame);
	        this.emit('?');
	        this.compile(node.body, frame);
	        this.emit(':');
	        if(node.else_ !== null)
	            this.compile(node.else_, frame);
	        else
	            this.emit('""');
	        this.emit(')');
	    },

	    compileIn: function(node, frame) {
	      this.emit('runtime.inOperator(');
	      this.compile(node.left, frame);
	      this.emit(',');
	      this.compile(node.right, frame);
	      this.emit(')');
	    },

	    compileOr: binOpEmitter(' || '),
	    compileAnd: binOpEmitter(' && '),
	    compileAdd: binOpEmitter(' + '),
	    // ensure concatenation instead of addition
	    // by adding empty string in between
	    compileConcat: binOpEmitter(' + "" + '),
	    compileSub: binOpEmitter(' - '),
	    compileMul: binOpEmitter(' * '),
	    compileDiv: binOpEmitter(' / '),
	    compileMod: binOpEmitter(' % '),

	    compileNot: function(node, frame) {
	        this.emit('!');
	        this.compile(node.target, frame);
	    },

	    compileFloorDiv: function(node, frame) {
	        this.emit('Math.floor(');
	        this.compile(node.left, frame);
	        this.emit(' / ');
	        this.compile(node.right, frame);
	        this.emit(')');
	    },

	    compilePow: function(node, frame) {
	        this.emit('Math.pow(');
	        this.compile(node.left, frame);
	        this.emit(', ');
	        this.compile(node.right, frame);
	        this.emit(')');
	    },

	    compileNeg: function(node, frame) {
	        this.emit('-');
	        this.compile(node.target, frame);
	    },

	    compilePos: function(node, frame) {
	        this.emit('+');
	        this.compile(node.target, frame);
	    },

	    compileCompare: function(node, frame) {
	        this.compile(node.expr, frame);

	        for(var i=0; i<node.ops.length; i++) {
	            var n = node.ops[i];
	            this.emit(' ' + compareOps[n.type] + ' ');
	            this.compile(n.expr, frame);
	        }
	    },

	    compileLookupVal: function(node, frame) {
	        this.emit('runtime.memberLookup((');
	        this._compileExpression(node.target, frame);
	        this.emit('),');
	        this._compileExpression(node.val, frame);
	        this.emit(')');
	    },

	    _getNodeName: function(node) {
	        switch (node.typename) {
	            case 'Symbol':
	                return node.value;
	            case 'FunCall':
	                return 'the return value of (' + this._getNodeName(node.name) + ')';
	            case 'LookupVal':
	                return this._getNodeName(node.target) + '["' +
	                       this._getNodeName(node.val) + '"]';
	            case 'Literal':
	                return node.value.toString();
	            default:
	                return '--expression--';
	        }
	    },

	    compileFunCall: function(node, frame) {
	        // Keep track of line/col info at runtime by settings
	        // variables within an expression. An expression in javascript
	        // like (x, y, z) returns the last value, and x and y can be
	        // anything
	        this.emit('(lineno = ' + node.lineno +
	                  ', colno = ' + node.colno + ', ');

	        this.emit('runtime.callWrap(');
	        // Compile it as normal.
	        this._compileExpression(node.name, frame);

	        // Output the name of what we're calling so we can get friendly errors
	        // if the lookup fails.
	        this.emit(', "' + this._getNodeName(node.name).replace(/"/g, '\\"') + '", context, ');

	        this._compileAggregate(node.args, frame, '[', '])');

	        this.emit(')');
	    },

	    compileFilter: function(node, frame) {
	        var name = node.name;
	        this.assertType(name, nodes.Symbol);
	        this.emit('env.getFilter("' + name.value + '").call(context, ');
	        this._compileAggregate(node.args, frame);
	        this.emit(')');
	    },

	    compileFilterAsync: function(node, frame) {
	        var name = node.name;
	        this.assertType(name, nodes.Symbol);

	        var symbol = node.symbol.value;
	        frame.set(symbol, symbol);

	        this.emit('env.getFilter("' + name.value + '").call(context, ');
	        this._compileAggregate(node.args, frame);
	        this.emitLine(', ' + this.makeCallback(symbol));

	        this.addScopeLevel();
	    },

	    compileKeywordArgs: function(node, frame) {
	        var names = [];

	        lib.each(node.children, function(pair) {
	            names.push(pair.key.value);
	        });

	        this.emit('runtime.makeKeywordArgs(');
	        this.compileDict(node, frame);
	        this.emit(')');
	    },

	    compileSet: function(node, frame) {
	        var ids = [];

	        // Lookup the variable names for each identifier and create
	        // new ones if necessary
	        lib.each(node.targets, function(target) {
	            var name = target.value;
	            var id = frame.lookup(name);

	            if (id === null || id === undefined) {
	                id = this.tmpid();

	                // Note: This relies on js allowing scope across
	                // blocks, in case this is created inside an `if`
	                this.emitLine('var ' + id + ';');
	            }

	            ids.push(id);
	        }, this);

	        if (node.value) {
	          this.emit(ids.join(' = ') + ' = ');
	          this._compileExpression(node.value, frame);
	          this.emitLine(';');
	        }
	        else {
	          this.emit(ids.join(' = ') + ' = ');
	          this.compile(node.body, frame);
	          this.emitLine(';');
	        }

	        lib.each(node.targets, function(target, i) {
	            var id = ids[i];
	            var name = target.value;

	            // We are running this for every var, but it's very
	            // uncommon to assign to multiple vars anyway
	            this.emitLine('frame.set("' + name + '", ' + id + ', true);');

	            this.emitLine('if(frame.topLevel) {');
	            this.emitLine('context.setVariable("' + name + '", ' + id + ');');
	            this.emitLine('}');

	            if(name.charAt(0) !== '_') {
	                this.emitLine('if(frame.topLevel) {');
	                this.emitLine('context.addExport("' + name + '", ' + id + ');');
	                this.emitLine('}');
	            }
	        }, this);
	    },

	    compileIf: function(node, frame, async) {
	        this.emit('if(');
	        this._compileExpression(node.cond, frame);
	        this.emitLine(') {');

	        this.withScopedSyntax(function() {
	            this.compile(node.body, frame);

	            if(async) {
	                this.emit('cb()');
	            }
	        });

	        if(node.else_) {
	            this.emitLine('}\nelse {');

	            this.withScopedSyntax(function() {
	                this.compile(node.else_, frame);

	                if(async) {
	                    this.emit('cb()');
	                }
	            });
	        } else if(async) {
	            this.emitLine('}\nelse {');
	            this.emit('cb()');
	        }

	        this.emitLine('}');
	    },

	    compileIfAsync: function(node, frame) {
	        this.emit('(function(cb) {');
	        this.compileIf(node, frame, true);
	        this.emit('})(' + this.makeCallback());
	        this.addScopeLevel();
	    },

	    emitLoopBindings: function(node, arr, i, len) {
	        var bindings = {
	            index: i + ' + 1',
	            index0: i,
	            revindex: len + ' - ' + i,
	            revindex0: len + ' - ' + i + ' - 1',
	            first: i + ' === 0',
	            last: i + ' === ' + len + ' - 1',
	            length: len
	        };

	        for (var name in bindings) {
	            this.emitLine('frame.set("loop.' + name + '", ' + bindings[name] + ');');
	        }
	    },

	    compileFor: function(node, frame) {
	        // Some of this code is ugly, but it keeps the generated code
	        // as fast as possible. ForAsync also shares some of this, but
	        // not much.

	        var v;
	        var i = this.tmpid();
	        var len = this.tmpid();
	        var arr = this.tmpid();
	        frame = frame.push();

	        this.emitLine('frame = frame.push();');

	        this.emit('var ' + arr + ' = ');
	        this._compileExpression(node.arr, frame);
	        this.emitLine(';');

	        this.emit('if(' + arr + ') {');

	        // If multiple names are passed, we need to bind them
	        // appropriately
	        if(node.name instanceof nodes.Array) {
	            this.emitLine('var ' + i + ';');

	            // The object could be an arroy or object. Note that the
	            // body of the loop is duplicated for each condition, but
	            // we are optimizing for speed over size.
	            this.emitLine('if(runtime.isArray(' + arr + ')) {'); {
	                this.emitLine('var ' + len + ' = ' + arr + '.length;');
	                this.emitLine('for(' + i + '=0; ' + i + ' < ' + arr + '.length; '
	                              + i + '++) {');

	                // Bind each declared var
	                for (var u=0; u < node.name.children.length; u++) {
	                    var tid = this.tmpid();
	                    this.emitLine('var ' + tid + ' = ' + arr + '[' + i + '][' + u + ']');
	                    this.emitLine('frame.set("' + node.name.children[u].value
	                                  + '", ' + arr + '[' + i + '][' + u + ']' + ');');
	                    frame.set(node.name.children[u].value, tid);
	                }

	                this.emitLoopBindings(node, arr, i, len);
	                this.withScopedSyntax(function() {
	                    this.compile(node.body, frame);
	                });
	                this.emitLine('}');
	            }

	            this.emitLine('} else {'); {
	                // Iterate over the key/values of an object
	                var key = node.name.children[0];
	                var val = node.name.children[1];
	                var k = this.tmpid();
	                v = this.tmpid();
	                frame.set(key.value, k);
	                frame.set(val.value, v);

	                this.emitLine(i + ' = -1;');
	                this.emitLine('var ' + len + ' = runtime.keys(' + arr + ').length;');
	                this.emitLine('for(var ' + k + ' in ' + arr + ') {');
	                this.emitLine(i + '++;');
	                this.emitLine('var ' + v + ' = ' + arr + '[' + k + '];');
	                this.emitLine('frame.set("' + key.value + '", ' + k + ');');
	                this.emitLine('frame.set("' + val.value + '", ' + v + ');');

	                this.emitLoopBindings(node, arr, i, len);
	                this.withScopedSyntax(function() {
	                    this.compile(node.body, frame);
	                });
	                this.emitLine('}');
	            }

	            this.emitLine('}');
	        }
	        else {
	            // Generate a typical array iteration
	            v = this.tmpid();
	            frame.set(node.name.value, v);

	            this.emitLine('var ' + len + ' = ' + arr + '.length;');
	            this.emitLine('for(var ' + i + '=0; ' + i + ' < ' + arr + '.length; ' +
	                          i + '++) {');
	            this.emitLine('var ' + v + ' = ' + arr + '[' + i + '];');
	            this.emitLine('frame.set("' + node.name.value + '", ' + v + ');');

	            this.emitLoopBindings(node, arr, i, len);

	            this.withScopedSyntax(function() {
	                this.compile(node.body, frame);
	            });

	            this.emitLine('}');
	        }

	        this.emitLine('}');
	        if (node.else_) {
	          this.emitLine('if (!' + len + ') {');
	          this.compile(node.else_, frame);
	          this.emitLine('}');
	        }

	        this.emitLine('frame = frame.pop();');
	    },

	    _compileAsyncLoop: function(node, frame, parallel) {
	        // This shares some code with the For tag, but not enough to
	        // worry about. This iterates across an object asynchronously,
	        // but not in parallel.

	        var i = this.tmpid();
	        var len = this.tmpid();
	        var arr = this.tmpid();
	        var asyncMethod = parallel ? 'asyncAll' : 'asyncEach';
	        frame = frame.push();

	        this.emitLine('frame = frame.push();');

	        this.emit('var ' + arr + ' = ');
	        this._compileExpression(node.arr, frame);
	        this.emitLine(';');

	        if(node.name instanceof nodes.Array) {
	            this.emit('runtime.' + asyncMethod + '(' + arr + ', ' +
	                      node.name.children.length + ', function(');

	            lib.each(node.name.children, function(name) {
	                this.emit(name.value + ',');
	            }, this);

	            this.emit(i + ',' + len + ',next) {');

	            lib.each(node.name.children, function(name) {
	                var id = name.value;
	                frame.set(id, id);
	                this.emitLine('frame.set("' + id + '", ' + id + ');');
	            }, this);
	        }
	        else {
	            var id = node.name.value;
	            this.emitLine('runtime.' + asyncMethod + '(' + arr + ', 1, function(' + id + ', ' + i + ', ' + len + ',next) {');
	            this.emitLine('frame.set("' + id + '", ' + id + ');');
	            frame.set(id, id);
	        }

	        this.emitLoopBindings(node, arr, i, len);

	        this.withScopedSyntax(function() {
	            var buf;
	            if(parallel) {
	                buf = this.tmpid();
	                this.pushBufferId(buf);
	            }

	            this.compile(node.body, frame);
	            this.emitLine('next(' + i + (buf ? ',' + buf : '') + ');');

	            if(parallel) {
	                this.popBufferId();
	            }
	        });

	        var output = this.tmpid();
	        this.emitLine('}, ' + this.makeCallback(output));
	        this.addScopeLevel();

	        if(parallel) {
	            this.emitLine(this.buffer + ' += ' + output + ';');
	        }

	        if (node.else_) {
	          this.emitLine('if (!' + arr + '.length) {');
	          this.compile(node.else_, frame);
	          this.emitLine('}');
	        }

	        this.emitLine('frame = frame.pop();');
	    },

	    compileAsyncEach: function(node, frame) {
	        this._compileAsyncLoop(node, frame);
	    },

	    compileAsyncAll: function(node, frame) {
	        this._compileAsyncLoop(node, frame, true);
	    },

	    _compileMacro: function(node) {
	        var args = [];
	        var kwargs = null;
	        var funcId = 'macro_' + this.tmpid();

	        // Type check the definition of the args
	        lib.each(node.args.children, function(arg, i) {
	            if(i === node.args.children.length - 1 &&
	               arg instanceof nodes.Dict) {
	                kwargs = arg;
	            }
	            else {
	                this.assertType(arg, nodes.Symbol);
	                args.push(arg);
	            }
	        }, this);

	        var realNames = lib.map(args, function(n) { return 'l_' + n.value; });
	        realNames.push('kwargs');

	        // Quoted argument names
	        var argNames = lib.map(args, function(n) { return '"' + n.value + '"'; });
	        var kwargNames = lib.map((kwargs && kwargs.children) || [],
	                                 function(n) { return '"' + n.key.value + '"'; });

	        // We pass a function to makeMacro which destructures the
	        // arguments so support setting positional args with keywords
	        // args and passing keyword args as positional args
	        // (essentially default values). See runtime.js.
	        var frame = new Frame();
	        this.emitLines(
	            'var ' + funcId + ' = runtime.makeMacro(',
	            '[' + argNames.join(', ') + '], ',
	            '[' + kwargNames.join(', ') + '], ',
	            'function (' + realNames.join(', ') + ') {',
	            'var callerFrame = frame;',
	            'frame = new runtime.Frame();',
	            'kwargs = kwargs || {};',
	            'if (kwargs.hasOwnProperty("caller")) {',
	            'frame.set("caller", kwargs.caller); }'
	        );

	        // Expose the arguments to the template. Don't need to use
	        // random names because the function
	        // will create a new run-time scope for us
	        lib.each(args, function(arg) {
	            this.emitLine('frame.set("' + arg.value + '", ' +
	                          'l_' + arg.value + ');');
	            frame.set(arg.value, 'l_' + arg.value);
	        }, this);

	        // Expose the keyword arguments
	        if(kwargs) {
	            lib.each(kwargs.children, function(pair) {
	                var name = pair.key.value;
	                this.emit('frame.set("' + name + '", ' +
	                          'kwargs.hasOwnProperty("' + name + '") ? ' +
	                          'kwargs["' + name + '"] : ');
	                this._compileExpression(pair.value, frame);
	                this.emitLine(');');
	            }, this);
	        }

	        var bufferId = this.tmpid();
	        this.pushBufferId(bufferId);

	        this.withScopedSyntax(function () {
	          this.compile(node.body, frame);
	        });

	        this.emitLine('frame = callerFrame;');
	        this.emitLine('return new runtime.SafeString(' + bufferId + ');');
	        this.emitLine('});');
	        this.popBufferId();

	        return funcId;
	    },

	    compileMacro: function(node, frame) {
	        var funcId = this._compileMacro(node, frame);

	        // Expose the macro to the templates
	        var name = node.name.value;
	        frame.set(name, funcId);

	        if(frame.parent) {
	            this.emitLine('frame.set("' + name + '", ' + funcId + ');');
	        }
	        else {
	            if(node.name.value.charAt(0) !== '_') {
	                this.emitLine('context.addExport("' + name + '");');
	            }
	            this.emitLine('context.setVariable("' + name + '", ' + funcId + ');');
	        }
	    },

	    compileCaller: function(node, frame) {
	        // basically an anonymous "macro expression"
	        this.emit('(function (){');
	        var funcId = this._compileMacro(node, frame);
	        this.emit('return ' + funcId + ';})()');
	    },

	    compileImport: function(node, frame) {
	        var id = this.tmpid();
	        var target = node.target.value;

	        this.emit('env.getTemplate(');
	        this._compileExpression(node.template, frame);
	        this.emitLine(', false, '+this._templateName()+', false, ' + this.makeCallback(id));
	        this.addScopeLevel();

	        this.emitLine(id + '.getExported(' +
	            (node.withContext ? 'context.getVariables(), frame, ' : '') +
	            this.makeCallback(id));
	        this.addScopeLevel();

	        frame.set(target, id);

	        if(frame.parent) {
	            this.emitLine('frame.set("' + target + '", ' + id + ');');
	        }
	        else {
	            this.emitLine('context.setVariable("' + target + '", ' + id + ');');
	        }
	    },

	    compileFromImport: function(node, frame) {
	        var importedId = this.tmpid();

	        this.emit('env.getTemplate(');
	        this._compileExpression(node.template, frame);
	        this.emitLine(', false, '+this._templateName()+', false, ' + this.makeCallback(importedId));
	        this.addScopeLevel();

	        this.emitLine(importedId + '.getExported(' +
	            (node.withContext ? 'context.getVariables(), frame, ' : '') +
	            this.makeCallback(importedId));
	        this.addScopeLevel();

	        lib.each(node.names.children, function(nameNode) {
	            var name;
	            var alias;
	            var id = this.tmpid();

	            if(nameNode instanceof nodes.Pair) {
	                name = nameNode.key.value;
	                alias = nameNode.value.value;
	            }
	            else {
	                name = nameNode.value;
	                alias = name;
	            }

	            this.emitLine('if(' + importedId + '.hasOwnProperty("' + name + '")) {');
	            this.emitLine('var ' + id + ' = ' + importedId + '.' + name + ';');
	            this.emitLine('} else {');
	            this.emitLine('cb(new Error("cannot import \'' + name + '\'")); return;');
	            this.emitLine('}');

	            frame.set(alias, id);

	            if(frame.parent) {
	                this.emitLine('frame.set("' + alias + '", ' + id + ');');
	            }
	            else {
	                this.emitLine('context.setVariable("' + alias + '", ' + id + ');');
	            }
	        }, this);
	    },

	    compileBlock: function(node) {
	        var id = this.tmpid();

	        // If we are executing outside a block (creating a top-level
	        // block), we really don't want to execute its code because it
	        // will execute twice: once when the child template runs and
	        // again when the parent template runs. Note that blocks
	        // within blocks will *always* execute immediately *and*
	        // wherever else they are invoked (like used in a parent
	        // template). This may have behavioral differences from jinja
	        // because blocks can have side effects, but it seems like a
	        // waste of performance to always execute huge top-level
	        // blocks twice
	        if(!this.inBlock) {
	            this.emit('(parentTemplate ? function(e, c, f, r, cb) { cb(""); } : ');
	        }
	        this.emit('context.getBlock("' + node.name.value + '")');
	        if(!this.inBlock) {
	            this.emit(')');
	        }
	        this.emitLine('(env, context, frame, runtime, ' + this.makeCallback(id));
	        this.emitLine(this.buffer + ' += ' + id + ';');
	        this.addScopeLevel();
	    },

	    compileSuper: function(node, frame) {
	        var name = node.blockName.value;
	        var id = node.symbol.value;

	        this.emitLine('context.getSuper(env, ' +
	                      '"' + name + '", ' +
	                      'b_' + name + ', ' +
	                      'frame, runtime, '+
	                      this.makeCallback(id));
	        this.emitLine(id + ' = runtime.markSafe(' + id + ');');
	        this.addScopeLevel();
	        frame.set(id, id);
	    },

	    compileExtends: function(node, frame) {
	        var k = this.tmpid();

	        this.emit('env.getTemplate(');
	        this._compileExpression(node.template, frame);
	        this.emitLine(', true, '+this._templateName()+', false, ' + this.makeCallback('_parentTemplate'));

	        // extends is a dynamic tag and can occur within a block like
	        // `if`, so if this happens we need to capture the parent
	        // template in the top-level scope
	        this.emitLine('parentTemplate = _parentTemplate');

	        this.emitLine('for(var ' + k + ' in parentTemplate.blocks) {');
	        this.emitLine('context.addBlock(' + k +
	                      ', parentTemplate.blocks[' + k + ']);');
	        this.emitLine('}');

	        this.addScopeLevel();
	    },

	    compileInclude: function(node, frame) {
	        var id = this.tmpid();
	        var id2 = this.tmpid();

	        this.emitLine('var tasks = [];');
	        this.emitLine('tasks.push(');
	        this.emitLine('function(callback) {');
	        this.emit('env.getTemplate(');
	        this._compileExpression(node.template, frame);
	        this.emitLine(', false, '+this._templateName()+', ' + node.ignoreMissing + ', ' + this.makeCallback(id));
	        this.emitLine('callback(null,' + id + ');});');
	        this.emitLine('});');

	        this.emitLine('tasks.push(');
	        this.emitLine('function(template, callback){');
	        this.emitLine('template.render(' +
	            'context.getVariables(), frame, ' + this.makeCallback(id2));
	        this.emitLine('callback(null,' + id2 + ');});');
	        this.emitLine('});');

	        this.emitLine('tasks.push(');
	        this.emitLine('function(result, callback){');
	        this.emitLine(this.buffer + ' += result;');
	        this.emitLine('callback(null);');
	        this.emitLine('});');
	        this.emitLine('env.waterfall(tasks, function(){');
	        this.addScopeLevel();
	    },

	    compileTemplateData: function(node, frame) {
	        this.compileLiteral(node, frame);
	    },

	    compileCapture: function(node, frame) {
	        this.emitLine('(function() {');
	        this.emitLine('var output = "";');
	        this.withScopedSyntax(function () {
	            this.compile(node.body, frame);
	        });
	        this.emitLine('return output;');
	        this.emitLine('})()');
	    },

	    compileOutput: function(node, frame) {
	        var children = node.children;
	        for(var i=0, l=children.length; i<l; i++) {
	            // TemplateData is a special case because it is never
	            // autoescaped, so simply output it for optimization
	            if(children[i] instanceof nodes.TemplateData) {
	                if(children[i].value) {
	                    this.emit(this.buffer + ' += ');
	                    this.compileLiteral(children[i], frame);
	                    this.emitLine(';');
	                }
	            }
	            else {
	                this.emit(this.buffer + ' += runtime.suppressValue(');
	                if(this.throwOnUndefined) {
	                    this.emit('runtime.ensureDefined(');
	                }
	                this.compile(children[i], frame);
	                if(this.throwOnUndefined) {
	                    this.emit(',' + node.lineno + ',' + node.colno + ')');
	                }
	                this.emit(', env.opts.autoescape);\n');
	            }
	        }
	    },

	    compileRoot: function(node, frame) {
	        if(frame) {
	            this.fail('compileRoot: root node can\'t have frame');
	        }

	        frame = new Frame();

	        this.emitFuncBegin('root');
	        this.emitLine('var parentTemplate = null;');
	        this._compileChildren(node, frame);
	        this.emitLine('if(parentTemplate) {');
	        this.emitLine('parentTemplate.rootRenderFunc(env, context, frame, runtime, cb);');
	        this.emitLine('} else {');
	        this.emitLine('cb(null, ' + this.buffer +');');
	        this.emitLine('}');
	        this.emitFuncEnd(true);

	        this.inBlock = true;

	        var blockNames = [];

	        var i, name, block, blocks = node.findAll(nodes.Block);
	        for (i = 0; i < blocks.length; i++) {
	            block = blocks[i];
	            name = block.name.value;

	            if (blockNames.indexOf(name) !== -1) {
	                throw new Error('Block "' + name + '" defined more than once.');
	            }
	            blockNames.push(name);

	            this.emitFuncBegin('b_' + name);

	            var tmpFrame = new Frame();
	            this.emitLine('var frame = frame.push(true);');
	            this.compile(block.body, tmpFrame);
	            this.emitFuncEnd();
	        }

	        this.emitLine('return {');
	        for (i = 0; i < blocks.length; i++) {
	            block = blocks[i];
	            name = 'b_' + block.name.value;
	            this.emitLine(name + ': ' + name + ',');
	        }
	        this.emitLine('root: root\n};');
	    },

	    compile: function (node, frame) {
	        var _compile = this['compile' + node.typename];
	        if(_compile) {
	            _compile.call(this, node, frame);
	        }
	        else {
	            this.fail('compile: Cannot compile node: ' + node.typename,
	                      node.lineno,
	                      node.colno);
	        }
	    },

	    getCode: function() {
	        return this.codebuf.join('');
	    }
	});

	// var c = new Compiler();
	// var src = 'hello {% filter title %}' +
	//     'Hello madam how are you' +
	//     '{% endfilter %}'
	// var ast = transformer.transform(parser.parse(src));
	// nodes.printNodes(ast);
	// c.compile(ast);
	// var tmpl = c.getCode();
	// console.log(tmpl);

	module.exports = {
	    compile: function(src, asyncFilters, extensions, name, opts) {
	        var c = new Compiler(name, opts.throwOnUndefined);

	        // Run the extension preprocessors against the source.
	        if(extensions && extensions.length) {
	            for(var i=0; i<extensions.length; i++) {
	                if('preprocess' in extensions[i]) {
	                    src = extensions[i].preprocess(src, name);
	                }
	            }
	        }

	        c.compile(transformer.transform(
	            parser.parse(src,
	                         extensions,
	                         opts),
	            asyncFilters,
	            name
	        ));
	        return c.getCode();
	    },

	    Compiler: Compiler
	};


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var lexer = __webpack_require__(9);
	var nodes = __webpack_require__(10);
	// jshint -W079
	var Object = __webpack_require__(6);
	var lib = __webpack_require__(1);

	var Parser = Object.extend({
	    init: function (tokens) {
	        this.tokens = tokens;
	        this.peeked = null;
	        this.breakOnBlocks = null;
	        this.dropLeadingWhitespace = false;

	        this.extensions = [];
	    },

	    nextToken: function (withWhitespace) {
	        var tok;

	        if(this.peeked) {
	            if(!withWhitespace && this.peeked.type === lexer.TOKEN_WHITESPACE) {
	                this.peeked = null;
	            }
	            else {
	                tok = this.peeked;
	                this.peeked = null;
	                return tok;
	            }
	        }

	        tok = this.tokens.nextToken();

	        if(!withWhitespace) {
	            while(tok && tok.type === lexer.TOKEN_WHITESPACE) {
	                tok = this.tokens.nextToken();
	            }
	        }

	        return tok;
	    },

	    peekToken: function () {
	        this.peeked = this.peeked || this.nextToken();
	        return this.peeked;
	    },

	    pushToken: function(tok) {
	        if(this.peeked) {
	            throw new Error('pushToken: can only push one token on between reads');
	        }
	        this.peeked = tok;
	    },

	    fail: function (msg, lineno, colno) {
	        if((lineno === undefined || colno === undefined) && this.peekToken()) {
	            var tok = this.peekToken();
	            lineno = tok.lineno;
	            colno = tok.colno;
	        }
	        if (lineno !== undefined) lineno += 1;
	        if (colno !== undefined) colno += 1;

	        throw new lib.TemplateError(msg, lineno, colno);
	    },

	    skip: function(type) {
	        var tok = this.nextToken();
	        if(!tok || tok.type !== type) {
	            this.pushToken(tok);
	            return false;
	        }
	        return true;
	    },

	    expect: function(type) {
	        var tok = this.nextToken();
	        if(tok.type !== type) {
	            this.fail('expected ' + type + ', got ' + tok.type,
	                      tok.lineno,
	                      tok.colno);
	        }
	        return tok;
	    },

	    skipValue: function(type, val) {
	        var tok = this.nextToken();
	        if(!tok || tok.type !== type || tok.value !== val) {
	            this.pushToken(tok);
	            return false;
	        }
	        return true;
	    },

	    skipSymbol: function(val) {
	        return this.skipValue(lexer.TOKEN_SYMBOL, val);
	    },

	    advanceAfterBlockEnd: function(name) {
	        var tok;
	        if(!name) {
	            tok = this.peekToken();

	            if(!tok) {
	                this.fail('unexpected end of file');
	            }

	            if(tok.type !== lexer.TOKEN_SYMBOL) {
	                this.fail('advanceAfterBlockEnd: expected symbol token or ' +
	                          'explicit name to be passed');
	            }

	            name = this.nextToken().value;
	        }

	        tok = this.nextToken();

	        if(tok && tok.type === lexer.TOKEN_BLOCK_END) {
	            if(tok.value.charAt(0) === '-') {
	                this.dropLeadingWhitespace = true;
	            }
	        }
	        else {
	            this.fail('expected block end in ' + name + ' statement');
	        }

	        return tok;
	    },

	    advanceAfterVariableEnd: function() {
	        var tok = this.nextToken();

	        if(tok && tok.type === lexer.TOKEN_VARIABLE_END) {
	            this.dropLeadingWhitespace = tok.value.charAt(
	                tok.value.length - this.tokens.tags.VARIABLE_END.length - 1
	            ) === '-';
	        } else {
	            this.pushToken(tok);
	            this.fail('expected variable end');
	        }
	    },

	    parseFor: function() {
	        var forTok = this.peekToken();
	        var node;
	        var endBlock;

	        if(this.skipSymbol('for')) {
	            node = new nodes.For(forTok.lineno, forTok.colno);
	            endBlock = 'endfor';
	        }
	        else if(this.skipSymbol('asyncEach')) {
	            node = new nodes.AsyncEach(forTok.lineno, forTok.colno);
	            endBlock = 'endeach';
	        }
	        else if(this.skipSymbol('asyncAll')) {
	            node = new nodes.AsyncAll(forTok.lineno, forTok.colno);
	            endBlock = 'endall';
	        }
	        else {
	            this.fail('parseFor: expected for{Async}', forTok.lineno, forTok.colno);
	        }

	        node.name = this.parsePrimary();

	        if(!(node.name instanceof nodes.Symbol)) {
	            this.fail('parseFor: variable name expected for loop');
	        }

	        var type = this.peekToken().type;
	        if(type === lexer.TOKEN_COMMA) {
	            // key/value iteration
	            var key = node.name;
	            node.name = new nodes.Array(key.lineno, key.colno);
	            node.name.addChild(key);

	            while(this.skip(lexer.TOKEN_COMMA)) {
	                var prim = this.parsePrimary();
	                node.name.addChild(prim);
	            }
	        }

	        if(!this.skipSymbol('in')) {
	            this.fail('parseFor: expected "in" keyword for loop',
	                      forTok.lineno,
	                      forTok.colno);
	        }

	        node.arr = this.parseExpression();
	        this.advanceAfterBlockEnd(forTok.value);

	        node.body = this.parseUntilBlocks(endBlock, 'else');

	        if(this.skipSymbol('else')) {
	            this.advanceAfterBlockEnd('else');
	            node.else_ = this.parseUntilBlocks(endBlock);
	        }

	        this.advanceAfterBlockEnd();

	        return node;
	    },

	    parseMacro: function() {
	        var macroTok = this.peekToken();
	        if(!this.skipSymbol('macro')) {
	            this.fail('expected macro');
	        }

	        var name = this.parsePrimary(true);
	        var args = this.parseSignature();
	        var node = new nodes.Macro(macroTok.lineno,
	                                   macroTok.colno,
	                                   name,
	                                   args);

	        this.advanceAfterBlockEnd(macroTok.value);
	        node.body = this.parseUntilBlocks('endmacro');
	        this.advanceAfterBlockEnd();

	        return node;
	    },

	    parseCall: function() {
	        // a call block is parsed as a normal FunCall, but with an added
	        // 'caller' kwarg which is a Caller node.
	        var callTok = this.peekToken();
	        if(!this.skipSymbol('call')) {
	            this.fail('expected call');
	        }

	        var callerArgs = this.parseSignature(true) || new nodes.NodeList();
	        var macroCall = this.parsePrimary();

	        this.advanceAfterBlockEnd(callTok.value);
	        var body = this.parseUntilBlocks('endcall');
	        this.advanceAfterBlockEnd();

	        var callerName = new nodes.Symbol(callTok.lineno,
	                                          callTok.colno,
	                                          'caller');
	        var callerNode = new nodes.Caller(callTok.lineno,
	                                          callTok.colno,
	                                          callerName,
	                                          callerArgs,
	                                          body);

	        // add the additional caller kwarg, adding kwargs if necessary
	        var args = macroCall.args.children;
	        if (!(args[args.length-1] instanceof nodes.KeywordArgs)) {
	          args.push(new nodes.KeywordArgs());
	        }
	        var kwargs = args[args.length - 1];
	        kwargs.addChild(new nodes.Pair(callTok.lineno,
	                                       callTok.colno,
	                                       callerName,
	                                       callerNode));

	        return new nodes.Output(callTok.lineno,
	                                callTok.colno,
	                                [macroCall]);
	    },

	    parseWithContext: function() {
	        var tok = this.peekToken();

	        var withContext = null;

	        if(this.skipSymbol('with')) {
	            withContext = true;
	        }
	        else if(this.skipSymbol('without')) {
	            withContext = false;
	        }

	        if(withContext !== null) {
	            if(!this.skipSymbol('context')) {
	                this.fail('parseFrom: expected context after with/without',
	                            tok.lineno,
	                            tok.colno);
	            }
	        }

	        return withContext;
	    },

	    parseImport: function() {
	        var importTok = this.peekToken();
	        if(!this.skipSymbol('import')) {
	            this.fail('parseImport: expected import',
	                      importTok.lineno,
	                      importTok.colno);
	        }

	        var template = this.parseExpression();

	        if(!this.skipSymbol('as')) {
	            this.fail('parseImport: expected "as" keyword',
	                            importTok.lineno,
	                            importTok.colno);
	        }

	        var target = this.parseExpression();

	        var withContext = this.parseWithContext();

	        var node = new nodes.Import(importTok.lineno,
	                                    importTok.colno,
	                                    template,
	                                    target,
	                                    withContext);

	        this.advanceAfterBlockEnd(importTok.value);

	        return node;
	    },

	    parseFrom: function() {
	        var fromTok = this.peekToken();
	        if(!this.skipSymbol('from')) {
	            this.fail('parseFrom: expected from');
	        }

	        var template = this.parseExpression();

	        if(!this.skipSymbol('import')) {
	            this.fail('parseFrom: expected import',
	                            fromTok.lineno,
	                            fromTok.colno);
	        }

	        var names = new nodes.NodeList(),
	            withContext;

	        while(1) {
	            var nextTok = this.peekToken();
	            if(nextTok.type === lexer.TOKEN_BLOCK_END) {
	                if(!names.children.length) {
	                    this.fail('parseFrom: Expected at least one import name',
	                              fromTok.lineno,
	                              fromTok.colno);
	                }

	                // Since we are manually advancing past the block end,
	                // need to keep track of whitespace control (normally
	                // this is done in `advanceAfterBlockEnd`
	                if(nextTok.value.charAt(0) === '-') {
	                    this.dropLeadingWhitespace = true;
	                }

	                this.nextToken();
	                break;
	            }

	            if(names.children.length > 0 && !this.skip(lexer.TOKEN_COMMA)) {
	                this.fail('parseFrom: expected comma',
	                                fromTok.lineno,
	                                fromTok.colno);
	            }

	            var name = this.parsePrimary();
	            if(name.value.charAt(0) === '_') {
	                this.fail('parseFrom: names starting with an underscore ' +
	                          'cannot be imported',
	                          name.lineno,
	                          name.colno);
	            }

	            if(this.skipSymbol('as')) {
	                var alias = this.parsePrimary();
	                names.addChild(new nodes.Pair(name.lineno,
	                                              name.colno,
	                                              name,
	                                              alias));
	            }
	            else {
	                names.addChild(name);
	            }

	            withContext = this.parseWithContext();
	        }

	        return new nodes.FromImport(fromTok.lineno,
	                                    fromTok.colno,
	                                    template,
	                                    names,
	                                    withContext);
	    },

	    parseBlock: function() {
	        var tag = this.peekToken();
	        if(!this.skipSymbol('block')) {
	            this.fail('parseBlock: expected block', tag.lineno, tag.colno);
	        }

	        var node = new nodes.Block(tag.lineno, tag.colno);

	        node.name = this.parsePrimary();
	        if(!(node.name instanceof nodes.Symbol)) {
	            this.fail('parseBlock: variable name expected',
	                      tag.lineno,
	                      tag.colno);
	        }

	        this.advanceAfterBlockEnd(tag.value);

	        node.body = this.parseUntilBlocks('endblock');
	        this.skipSymbol('endblock');
	        this.skipSymbol(node.name.value);

	        var tok = this.peekToken();
	        if(!tok) {
	            this.fail('parseBlock: expected endblock, got end of file');
	        }

	        this.advanceAfterBlockEnd(tok.value);

	        return node;
	    },

	    parseExtends: function() {
	        var tagName = 'extends';
	        var tag = this.peekToken();
	        if(!this.skipSymbol(tagName)) {
	            this.fail('parseTemplateRef: expected '+ tagName);
	        }

	        var node = new nodes.Extends(tag.lineno, tag.colno);
	        node.template = this.parseExpression();

	        this.advanceAfterBlockEnd(tag.value);
	        return node;
	    },

	    parseInclude: function() {
	        var tagName = 'include';
	        var tag = this.peekToken();
	        if(!this.skipSymbol(tagName)) {
	            this.fail('parseInclude: expected '+ tagName);
	        }

	        var node = new nodes.Include(tag.lineno, tag.colno);
	        node.template = this.parseExpression();

	        if(this.skipSymbol('ignore') && this.skipSymbol('missing')) {
	            node.ignoreMissing = true;
	        }

	        this.advanceAfterBlockEnd(tag.value);
	        return node;
	    },

	    parseIf: function() {
	        var tag = this.peekToken();
	        var node;

	        if(this.skipSymbol('if') || this.skipSymbol('elif') || this.skipSymbol('elseif')) {
	            node = new nodes.If(tag.lineno, tag.colno);
	        }
	        else if(this.skipSymbol('ifAsync')) {
	            node = new nodes.IfAsync(tag.lineno, tag.colno);
	        }
	        else {
	            this.fail('parseIf: expected if, elif, or elseif',
	                      tag.lineno,
	                      tag.colno);
	        }

	        node.cond = this.parseExpression();
	        this.advanceAfterBlockEnd(tag.value);

	        node.body = this.parseUntilBlocks('elif', 'elseif', 'else', 'endif');
	        var tok = this.peekToken();

	        switch(tok && tok.value) {
	        case 'elseif':
	        case 'elif':
	            node.else_ = this.parseIf();
	            break;
	        case 'else':
	            this.advanceAfterBlockEnd();
	            node.else_ = this.parseUntilBlocks('endif');
	            this.advanceAfterBlockEnd();
	            break;
	        case 'endif':
	            node.else_ = null;
	            this.advanceAfterBlockEnd();
	            break;
	        default:
	            this.fail('parseIf: expected elif, else, or endif, ' +
	                      'got end of file');
	        }

	        return node;
	    },

	    parseSet: function() {
	        var tag = this.peekToken();
	        if(!this.skipSymbol('set')) {
	            this.fail('parseSet: expected set', tag.lineno, tag.colno);
	        }

	        var node = new nodes.Set(tag.lineno, tag.colno, []);

	        var target;
	        while((target = this.parsePrimary())) {
	            node.targets.push(target);

	            if(!this.skip(lexer.TOKEN_COMMA)) {
	                break;
	            }
	        }

	        if(!this.skipValue(lexer.TOKEN_OPERATOR, '=')) {
	            if (!this.skip(lexer.TOKEN_BLOCK_END)) {
	                this.fail('parseSet: expected = or block end in set tag',
	                          tag.lineno,
	                          tag.colno);
	            }
	            else {
	                node.body = new nodes.Capture(
	                    tag.lineno,
	                    tag.colno,
	                    this.parseUntilBlocks('endset')
	                );
	                node.value = null;
	                this.advanceAfterBlockEnd();
	            }
	        }
	        else {
	            node.value = this.parseExpression();
	            this.advanceAfterBlockEnd(tag.value);
	        }

	        return node;
	    },

	    parseStatement: function () {
	        var tok = this.peekToken();
	        var node;

	        if(tok.type !== lexer.TOKEN_SYMBOL) {
	            this.fail('tag name expected', tok.lineno, tok.colno);
	        }

	        if(this.breakOnBlocks &&
	           lib.indexOf(this.breakOnBlocks, tok.value) !== -1) {
	            return null;
	        }

	        switch(tok.value) {
	        case 'raw': return this.parseRaw();
	        case 'verbatim': return this.parseRaw('verbatim');
	        case 'if':
	        case 'ifAsync':
	            return this.parseIf();
	        case 'for':
	        case 'asyncEach':
	        case 'asyncAll':
	            return this.parseFor();
	        case 'block': return this.parseBlock();
	        case 'extends': return this.parseExtends();
	        case 'include': return this.parseInclude();
	        case 'set': return this.parseSet();
	        case 'macro': return this.parseMacro();
	        case 'call': return this.parseCall();
	        case 'import': return this.parseImport();
	        case 'from': return this.parseFrom();
	        case 'filter': return this.parseFilterStatement();
	        default:
	            if (this.extensions.length) {
	                for (var i = 0; i < this.extensions.length; i++) {
	                    var ext = this.extensions[i];
	                    if (lib.indexOf(ext.tags || [], tok.value) !== -1) {
	                        return ext.parse(this, nodes, lexer);
	                    }
	                }
	            }
	            this.fail('unknown block tag: ' + tok.value, tok.lineno, tok.colno);
	        }

	        return node;
	    },

	    parseRaw: function(tagName) {
	        tagName = tagName || 'raw';
	        var endTagName = 'end' + tagName;
	        // Look for upcoming raw blocks (ignore all other kinds of blocks)
	        var rawBlockRegex = new RegExp('([\\s\\S]*?){%\\s*(' + tagName + '|' + endTagName + ')\\s*(?=%})%}');
	        var rawLevel = 1;
	        var str = '';
	        var matches = null;

	        // Skip opening raw token
	        // Keep this token to track line and column numbers
	        var begun = this.advanceAfterBlockEnd();

	        // Exit when there's nothing to match
	        // or when we've found the matching "endraw" block
	        while((matches = this.tokens._extractRegex(rawBlockRegex)) && rawLevel > 0) {
	            var all = matches[0];
	            var pre = matches[1];
	            var blockName = matches[2];

	            // Adjust rawlevel
	            if(blockName === tagName) {
	                rawLevel += 1;
	            } else if(blockName === endTagName) {
	                rawLevel -= 1;
	            }

	            // Add to str
	            if(rawLevel === 0) {
	                // We want to exclude the last "endraw"
	                str += pre;
	                // Move tokenizer to beginning of endraw block
	                this.tokens.backN(all.length - pre.length);
	            } else {
	                str += all;
	            }
	        }

	        return new nodes.Output(
	            begun.lineno,
	            begun.colno,
	            [new nodes.TemplateData(begun.lineno, begun.colno, str)]
	        );
	    },

	    parsePostfix: function(node) {
	        var lookup, tok = this.peekToken();

	        while(tok) {
	            if(tok.type === lexer.TOKEN_LEFT_PAREN) {
	                // Function call
	                node = new nodes.FunCall(tok.lineno,
	                                         tok.colno,
	                                         node,
	                                         this.parseSignature());
	            }
	            else if(tok.type === lexer.TOKEN_LEFT_BRACKET) {
	                // Reference
	                lookup = this.parseAggregate();
	                if(lookup.children.length > 1) {
	                    this.fail('invalid index');
	                }

	                node =  new nodes.LookupVal(tok.lineno,
	                                            tok.colno,
	                                            node,
	                                            lookup.children[0]);
	            }
	            else if(tok.type === lexer.TOKEN_OPERATOR && tok.value === '.') {
	                // Reference
	                this.nextToken();
	                var val = this.nextToken();

	                if(val.type !== lexer.TOKEN_SYMBOL) {
	                    this.fail('expected name as lookup value, got ' + val.value,
	                              val.lineno,
	                              val.colno);
	                }

	                // Make a literal string because it's not a variable
	                // reference
	                lookup = new nodes.Literal(val.lineno,
	                                               val.colno,
	                                               val.value);

	                node =  new nodes.LookupVal(tok.lineno,
	                                            tok.colno,
	                                            node,
	                                            lookup);
	            }
	            else {
	                break;
	            }

	            tok = this.peekToken();
	        }

	        return node;
	    },

	    parseExpression: function() {
	        var node = this.parseInlineIf();
	        return node;
	    },

	    parseInlineIf: function() {
	        var node = this.parseOr();
	        if(this.skipSymbol('if')) {
	            var cond_node = this.parseOr();
	            var body_node = node;
	            node = new nodes.InlineIf(node.lineno, node.colno);
	            node.body = body_node;
	            node.cond = cond_node;
	            if(this.skipSymbol('else')) {
	                node.else_ = this.parseOr();
	            } else {
	                node.else_ = null;
	            }
	        }

	        return node;
	    },

	    parseOr: function() {
	        var node = this.parseAnd();
	        while(this.skipSymbol('or')) {
	            var node2 = this.parseAnd();
	            node = new nodes.Or(node.lineno,
	                                node.colno,
	                                node,
	                                node2);
	        }
	        return node;
	    },

	    parseAnd: function() {
	        var node = this.parseNot();
	        while(this.skipSymbol('and')) {
	            var node2 = this.parseNot();
	            node = new nodes.And(node.lineno,
	                                 node.colno,
	                                 node,
	                                 node2);
	        }
	        return node;
	    },

	    parseNot: function() {
	        var tok = this.peekToken();
	        if(this.skipSymbol('not')) {
	            return new nodes.Not(tok.lineno,
	                                 tok.colno,
	                                 this.parseNot());
	        }
	        return this.parseIn();
	    },

	    parseIn: function() {
	      var node = this.parseCompare();
	      while(1) {
	        // check if the next token is 'not'
	        var tok = this.nextToken();
	        if (!tok) { break; }
	        var invert = tok.type === lexer.TOKEN_SYMBOL && tok.value === 'not';
	        // if it wasn't 'not', put it back
	        if (!invert) { this.pushToken(tok); }
	        if (this.skipSymbol('in')) {
	          var node2 = this.parseCompare();
	          node = new nodes.In(node.lineno,
	                              node.colno,
	                              node,
	                              node2);
	          if (invert) {
	            node = new nodes.Not(node.lineno,
	                                 node.colno,
	                                 node);
	          }
	        }
	        else {
	          // if we'd found a 'not' but this wasn't an 'in', put back the 'not'
	          if (invert) { this.pushToken(tok); }
	          break;
	        }
	      }
	      return node;
	    },

	    parseCompare: function() {
	        var compareOps = ['==', '===', '!=', '!==', '<', '>', '<=', '>='];
	        var expr = this.parseConcat();
	        var ops = [];

	        while(1) {
	            var tok = this.nextToken();

	            if(!tok) {
	                break;
	            }
	            else if(lib.indexOf(compareOps, tok.value) !== -1) {
	                ops.push(new nodes.CompareOperand(tok.lineno,
	                                                  tok.colno,
	                                                  this.parseConcat(),
	                                                  tok.value));
	            }
	            else {
	                this.pushToken(tok);
	                break;
	            }
	        }

	        if(ops.length) {
	            return new nodes.Compare(ops[0].lineno,
	                                     ops[0].colno,
	                                     expr,
	                                     ops);
	        }
	        else {
	            return expr;
	        }
	    },

	    // finds the '~' for string concatenation
	    parseConcat: function(){
	        var node = this.parseAdd();
	        while(this.skipValue(lexer.TOKEN_TILDE, '~')) {
	            var node2 = this.parseAdd();
	            node = new nodes.Concat(node.lineno,
	                                 node.colno,
	                                 node,
	                                 node2);
	        }
	        return node;
	    },

	    parseAdd: function() {
	        var node = this.parseSub();
	        while(this.skipValue(lexer.TOKEN_OPERATOR, '+')) {
	            var node2 = this.parseSub();
	            node = new nodes.Add(node.lineno,
	                                 node.colno,
	                                 node,
	                                 node2);
	        }
	        return node;
	    },

	    parseSub: function() {
	        var node = this.parseMul();
	        while(this.skipValue(lexer.TOKEN_OPERATOR, '-')) {
	            var node2 = this.parseMul();
	            node = new nodes.Sub(node.lineno,
	                                 node.colno,
	                                 node,
	                                 node2);
	        }
	        return node;
	    },

	    parseMul: function() {
	        var node = this.parseDiv();
	        while(this.skipValue(lexer.TOKEN_OPERATOR, '*')) {
	            var node2 = this.parseDiv();
	            node = new nodes.Mul(node.lineno,
	                                 node.colno,
	                                 node,
	                                 node2);
	        }
	        return node;
	    },

	    parseDiv: function() {
	        var node = this.parseFloorDiv();
	        while(this.skipValue(lexer.TOKEN_OPERATOR, '/')) {
	            var node2 = this.parseFloorDiv();
	            node = new nodes.Div(node.lineno,
	                                 node.colno,
	                                 node,
	                                 node2);
	        }
	        return node;
	    },

	    parseFloorDiv: function() {
	        var node = this.parseMod();
	        while(this.skipValue(lexer.TOKEN_OPERATOR, '//')) {
	            var node2 = this.parseMod();
	            node = new nodes.FloorDiv(node.lineno,
	                                      node.colno,
	                                      node,
	                                      node2);
	        }
	        return node;
	    },

	    parseMod: function() {
	        var node = this.parsePow();
	        while(this.skipValue(lexer.TOKEN_OPERATOR, '%')) {
	            var node2 = this.parsePow();
	            node = new nodes.Mod(node.lineno,
	                                 node.colno,
	                                 node,
	                                 node2);
	        }
	        return node;
	    },

	    parsePow: function() {
	        var node = this.parseUnary();
	        while(this.skipValue(lexer.TOKEN_OPERATOR, '**')) {
	            var node2 = this.parseUnary();
	            node = new nodes.Pow(node.lineno,
	                                 node.colno,
	                                 node,
	                                 node2);
	        }
	        return node;
	    },

	    parseUnary: function(noFilters) {
	        var tok = this.peekToken();
	        var node;

	        if(this.skipValue(lexer.TOKEN_OPERATOR, '-')) {
	            node = new nodes.Neg(tok.lineno,
	                                 tok.colno,
	                                 this.parseUnary(true));
	        }
	        else if(this.skipValue(lexer.TOKEN_OPERATOR, '+')) {
	            node = new nodes.Pos(tok.lineno,
	                                 tok.colno,
	                                 this.parseUnary(true));
	        }
	        else {
	            node = this.parsePrimary();
	        }

	        if(!noFilters) {
	            node = this.parseFilter(node);
	        }

	        return node;
	    },

	    parsePrimary: function (noPostfix) {
	        var tok = this.nextToken();
	        var val;
	        var node = null;

	        if(!tok) {
	            this.fail('expected expression, got end of file');
	        }
	        else if(tok.type === lexer.TOKEN_STRING) {
	            val = tok.value;
	        }
	        else if(tok.type === lexer.TOKEN_INT) {
	            val = parseInt(tok.value, 10);
	        }
	        else if(tok.type === lexer.TOKEN_FLOAT) {
	            val = parseFloat(tok.value);
	        }
	        else if(tok.type === lexer.TOKEN_BOOLEAN) {
	            if(tok.value === 'true') {
	                val = true;
	            }
	            else if(tok.value === 'false') {
	                val = false;
	            }
	            else {
	                this.fail('invalid boolean: ' + tok.value,
	                          tok.lineno,
	                          tok.colno);
	            }
	        }
	        else if(tok.type === lexer.TOKEN_NONE) {
	            val = null;
	        }
	        else if (tok.type === lexer.TOKEN_REGEX) {
	            val = new RegExp(tok.value.body, tok.value.flags);
	        }

	        if(val !== undefined) {
	            node = new nodes.Literal(tok.lineno, tok.colno, val);
	        }
	        else if(tok.type === lexer.TOKEN_SYMBOL) {
	            node = new nodes.Symbol(tok.lineno, tok.colno, tok.value);

	            if(!noPostfix) {
	                node = this.parsePostfix(node);
	            }
	        }
	        else {
	            // See if it's an aggregate type, we need to push the
	            // current delimiter token back on
	            this.pushToken(tok);
	            node = this.parseAggregate();
	        }

	        if(node) {
	            return node;
	        }
	        else {
	            this.fail('unexpected token: ' + tok.value,
	                      tok.lineno,
	                      tok.colno);
	        }
	    },

	    parseFilterName: function() {
	        var tok = this.expect(lexer.TOKEN_SYMBOL);
	        var name = tok.value;

	        while(this.skipValue(lexer.TOKEN_OPERATOR, '.')) {
	            name += '.' + this.expect(lexer.TOKEN_SYMBOL).value;
	        }

	        return new nodes.Symbol(tok.lineno, tok.colno, name);
	    },

	    parseFilterArgs: function(node) {
	        if(this.peekToken().type === lexer.TOKEN_LEFT_PAREN) {
	            // Get a FunCall node and add the parameters to the
	            // filter
	            var call = this.parsePostfix(node);
	            return call.args.children;
	        }
	        return [];
	    },

	    parseFilter: function(node) {
	        while(this.skip(lexer.TOKEN_PIPE)) {
	            var name = this.parseFilterName();

	            node = new nodes.Filter(
	                name.lineno,
	                name.colno,
	                name,
	                new nodes.NodeList(
	                    name.lineno,
	                    name.colno,
	                    [node].concat(this.parseFilterArgs(node))
	                )
	            );
	        }

	        return node;
	    },

	    parseFilterStatement: function() {
	        var filterTok = this.peekToken();
	        if(!this.skipSymbol('filter')) {
	            this.fail('parseFilterStatement: expected filter');
	        }

	        var name = this.parseFilterName();
	        var args = this.parseFilterArgs(name);

	        this.advanceAfterBlockEnd(filterTok.value);
	        var body = new nodes.Capture(
	            name.lineno,
	            name.colno,
	            this.parseUntilBlocks('endfilter')
	        );
	        this.advanceAfterBlockEnd();

	        var node = new nodes.Filter(
	            name.lineno,
	            name.colno,
	            name,
	            new nodes.NodeList(
	                name.lineno,
	                name.colno,
	                [body].concat(args)
	            )
	        );

	        return new nodes.Output(
	            name.lineno,
	            name.colno,
	            [node]
	        );
	    },

	    parseAggregate: function() {
	        var tok = this.nextToken();
	        var node;

	        switch(tok.type) {
	        case lexer.TOKEN_LEFT_PAREN:
	            node = new nodes.Group(tok.lineno, tok.colno); break;
	        case lexer.TOKEN_LEFT_BRACKET:
	            node = new nodes.Array(tok.lineno, tok.colno); break;
	        case lexer.TOKEN_LEFT_CURLY:
	            node = new nodes.Dict(tok.lineno, tok.colno); break;
	        default:
	            return null;
	        }

	        while(1) {
	            var type = this.peekToken().type;
	            if(type === lexer.TOKEN_RIGHT_PAREN ||
	               type === lexer.TOKEN_RIGHT_BRACKET ||
	               type === lexer.TOKEN_RIGHT_CURLY) {
	                this.nextToken();
	                break;
	            }

	            if(node.children.length > 0) {
	                if(!this.skip(lexer.TOKEN_COMMA)) {
	                    this.fail('parseAggregate: expected comma after expression',
	                              tok.lineno,
	                              tok.colno);
	                }
	            }

	            if(node instanceof nodes.Dict) {
	                // TODO: check for errors
	                var key = this.parsePrimary();

	                // We expect a key/value pair for dicts, separated by a
	                // colon
	                if(!this.skip(lexer.TOKEN_COLON)) {
	                    this.fail('parseAggregate: expected colon after dict key',
	                        tok.lineno,
	                        tok.colno);
	                }

	                // TODO: check for errors
	                var value = this.parseExpression();
	                node.addChild(new nodes.Pair(key.lineno,
	                                             key.colno,
	                                             key,
	                                             value));
	            }
	            else {
	                // TODO: check for errors
	                var expr = this.parseExpression();
	                node.addChild(expr);
	            }
	        }

	        return node;
	    },

	    parseSignature: function(tolerant, noParens) {
	        var tok = this.peekToken();
	        if(!noParens && tok.type !== lexer.TOKEN_LEFT_PAREN) {
	            if(tolerant) {
	                return null;
	            }
	            else {
	                this.fail('expected arguments', tok.lineno, tok.colno);
	            }
	        }

	        if(tok.type === lexer.TOKEN_LEFT_PAREN) {
	            tok = this.nextToken();
	        }

	        var args = new nodes.NodeList(tok.lineno, tok.colno);
	        var kwargs = new nodes.KeywordArgs(tok.lineno, tok.colno);
	        var checkComma = false;

	        while(1) {
	            tok = this.peekToken();
	            if(!noParens && tok.type === lexer.TOKEN_RIGHT_PAREN) {
	                this.nextToken();
	                break;
	            }
	            else if(noParens && tok.type === lexer.TOKEN_BLOCK_END) {
	                break;
	            }

	            if(checkComma && !this.skip(lexer.TOKEN_COMMA)) {
	                this.fail('parseSignature: expected comma after expression',
	                          tok.lineno,
	                          tok.colno);
	            }
	            else {
	                var arg = this.parseExpression();

	                if(this.skipValue(lexer.TOKEN_OPERATOR, '=')) {
	                    kwargs.addChild(
	                        new nodes.Pair(arg.lineno,
	                                       arg.colno,
	                                       arg,
	                                       this.parseExpression())
	                    );
	                }
	                else {
	                    args.addChild(arg);
	                }
	            }

	            checkComma = true;
	        }

	        if(kwargs.children.length) {
	            args.addChild(kwargs);
	        }

	        return args;
	    },

	    parseUntilBlocks: function(/* blockNames */) {
	        var prev = this.breakOnBlocks;
	        this.breakOnBlocks = lib.toArray(arguments);

	        var ret = this.parse();

	        this.breakOnBlocks = prev;
	        return ret;
	    },

	    parseNodes: function () {
	        var tok;
	        var buf = [];

	        while((tok = this.nextToken())) {
	            if(tok.type === lexer.TOKEN_DATA) {
	                var data = tok.value;
	                var nextToken = this.peekToken();
	                var nextVal = nextToken && nextToken.value;

	                // If the last token has "-" we need to trim the
	                // leading whitespace of the data. This is marked with
	                // the `dropLeadingWhitespace` variable.
	                if(this.dropLeadingWhitespace) {
	                    // TODO: this could be optimized (don't use regex)
	                    data = data.replace(/^\s*/, '');
	                    this.dropLeadingWhitespace = false;
	                }

	                // Same for the succeeding block start token
	                if(nextToken &&
	                    ((nextToken.type === lexer.TOKEN_BLOCK_START &&
	                      nextVal.charAt(nextVal.length - 1) === '-') ||
	                    (nextToken.type === lexer.TOKEN_VARIABLE_START &&
	                      nextVal.charAt(this.tokens.tags.VARIABLE_START.length)
	                        === '-') ||
	                    (nextToken.type === lexer.TOKEN_COMMENT &&
	                      nextVal.charAt(this.tokens.tags.COMMENT_START.length)
	                        === '-'))) {
	                    // TODO: this could be optimized (don't use regex)
	                    data = data.replace(/\s*$/, '');
	                }

	                buf.push(new nodes.Output(tok.lineno,
	                                          tok.colno,
	                                          [new nodes.TemplateData(tok.lineno,
	                                                                  tok.colno,
	                                                                  data)]));
	            }
	            else if(tok.type === lexer.TOKEN_BLOCK_START) {
	                this.dropLeadingWhitespace = false;
	                var n = this.parseStatement();
	                if(!n) {
	                    break;
	                }
	                buf.push(n);
	            }
	            else if(tok.type === lexer.TOKEN_VARIABLE_START) {
	                var e = this.parseExpression();
	                this.dropLeadingWhitespace = false;
	                this.advanceAfterVariableEnd();
	                buf.push(new nodes.Output(tok.lineno, tok.colno, [e]));
	            }
	            else if(tok.type === lexer.TOKEN_COMMENT) {
	                this.dropLeadingWhitespace = tok.value.charAt(
	                    tok.value.length - this.tokens.tags.COMMENT_END.length - 1
	                ) === '-';
	            } else {
	                // Ignore comments, otherwise this should be an error
	                this.fail('Unexpected token at top-level: ' +
	                                tok.type, tok.lineno, tok.colno);

	            }
	        }

	        return buf;
	    },

	    parse: function() {
	        return new nodes.NodeList(0, 0, this.parseNodes());
	    },

	    parseAsRoot: function() {
	        return new nodes.Root(0, 0, this.parseNodes());
	    }
	});

	// var util = require('util');

	// var l = lexer.lex('{%- if x -%}\n hello {% endif %}');
	// var t;
	// while((t = l.nextToken())) {
	//     console.log(util.inspect(t));
	// }

	// var p = new Parser(lexer.lex('hello {% filter title %}' +
	//                              'Hello madam how are you' +
	//                              '{% endfilter %}'));
	// var n = p.parseAsRoot();
	// nodes.printNodes(n);

	module.exports = {
	    parse: function(src, extensions, opts) {
	        var p = new Parser(lexer.lex(src, opts));
	        if (extensions !== undefined) {
	            p.extensions = extensions;
	        }
	        return p.parseAsRoot();
	    }
	};


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var lib = __webpack_require__(1);

	var whitespaceChars = ' \n\t\r\u00A0';
	var delimChars = '()[]{}%*-+~/#,:|.<>=!';
	var intChars = '0123456789';

	var BLOCK_START = '{%';
	var BLOCK_END = '%}';
	var VARIABLE_START = '{{';
	var VARIABLE_END = '}}';
	var COMMENT_START = '{#';
	var COMMENT_END = '#}';

	var TOKEN_STRING = 'string';
	var TOKEN_WHITESPACE = 'whitespace';
	var TOKEN_DATA = 'data';
	var TOKEN_BLOCK_START = 'block-start';
	var TOKEN_BLOCK_END = 'block-end';
	var TOKEN_VARIABLE_START = 'variable-start';
	var TOKEN_VARIABLE_END = 'variable-end';
	var TOKEN_COMMENT = 'comment';
	var TOKEN_LEFT_PAREN = 'left-paren';
	var TOKEN_RIGHT_PAREN = 'right-paren';
	var TOKEN_LEFT_BRACKET = 'left-bracket';
	var TOKEN_RIGHT_BRACKET = 'right-bracket';
	var TOKEN_LEFT_CURLY = 'left-curly';
	var TOKEN_RIGHT_CURLY = 'right-curly';
	var TOKEN_OPERATOR = 'operator';
	var TOKEN_COMMA = 'comma';
	var TOKEN_COLON = 'colon';
	var TOKEN_TILDE = 'tilde';
	var TOKEN_PIPE = 'pipe';
	var TOKEN_INT = 'int';
	var TOKEN_FLOAT = 'float';
	var TOKEN_BOOLEAN = 'boolean';
	var TOKEN_NONE = 'none';
	var TOKEN_SYMBOL = 'symbol';
	var TOKEN_SPECIAL = 'special';
	var TOKEN_REGEX = 'regex';

	function token(type, value, lineno, colno) {
	    return {
	        type: type,
	        value: value,
	        lineno: lineno,
	        colno: colno
	    };
	}

	function Tokenizer(str, opts) {
	    this.str = str;
	    this.index = 0;
	    this.len = str.length;
	    this.lineno = 0;
	    this.colno = 0;

	    this.in_code = false;

	    opts = opts || {};

	    var tags = opts.tags || {};
	    this.tags = {
	        BLOCK_START: tags.blockStart || BLOCK_START,
	        BLOCK_END: tags.blockEnd || BLOCK_END,
	        VARIABLE_START: tags.variableStart || VARIABLE_START,
	        VARIABLE_END: tags.variableEnd || VARIABLE_END,
	        COMMENT_START: tags.commentStart || COMMENT_START,
	        COMMENT_END: tags.commentEnd || COMMENT_END
	    };

	    this.trimBlocks = !!opts.trimBlocks;
	    this.lstripBlocks = !!opts.lstripBlocks;
	}

	Tokenizer.prototype.nextToken = function() {
	    var lineno = this.lineno;
	    var colno = this.colno;
	    var tok;

	    if(this.in_code) {
	        // Otherwise, if we are in a block parse it as code
	        var cur = this.current();

	        if(this.is_finished()) {
	            // We have nothing else to parse
	            return null;
	        }
	        else if(cur === '"' || cur === '\'') {
	            // We've hit a string
	            return token(TOKEN_STRING, this.parseString(cur), lineno, colno);
	        }
	        else if((tok = this._extract(whitespaceChars))) {
	            // We hit some whitespace
	            return token(TOKEN_WHITESPACE, tok, lineno, colno);
	        }
	        else if((tok = this._extractString(this.tags.BLOCK_END)) ||
	                (tok = this._extractString('-' + this.tags.BLOCK_END))) {
	            // Special check for the block end tag
	            //
	            // It is a requirement that start and end tags are composed of
	            // delimiter characters (%{}[] etc), and our code always
	            // breaks on delimiters so we can assume the token parsing
	            // doesn't consume these elsewhere
	            this.in_code = false;
	            if(this.trimBlocks) {
	                cur = this.current();
	                if(cur === '\n') {
	                    // Skip newline
	                    this.forward();
	                }else if(cur === '\r'){
	                    // Skip CRLF newline
	                    this.forward();
	                    cur = this.current();
	                    if(cur === '\n'){
	                        this.forward();
	                    }else{
	                        // Was not a CRLF, so go back
	                        this.back();
	                    }
	                }
	            }
	            return token(TOKEN_BLOCK_END, tok, lineno, colno);
	        }
	        else if((tok = this._extractString(this.tags.VARIABLE_END)) ||
	                (tok = this._extractString('-' + this.tags.VARIABLE_END))) {
	            // Special check for variable end tag (see above)
	            this.in_code = false;
	            return token(TOKEN_VARIABLE_END, tok, lineno, colno);
	        }
	        else if (cur === 'r' && this.str.charAt(this.index + 1) === '/') {
	            // Skip past 'r/'.
	            this.forwardN(2);

	            // Extract until the end of the regex -- / ends it, \/ does not.
	            var regexBody = '';
	            while (!this.is_finished()) {
	                if (this.current() === '/' && this.previous() !== '\\') {
	                    this.forward();
	                    break;
	                } else {
	                    regexBody += this.current();
	                    this.forward();
	                }
	            }

	            // Check for flags.
	            // The possible flags are according to https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/RegExp)
	            var POSSIBLE_FLAGS = ['g', 'i', 'm', 'y'];
	            var regexFlags = '';
	            while (!this.is_finished()) {
	                var isCurrentAFlag = POSSIBLE_FLAGS.indexOf(this.current()) !== -1;
	                if (isCurrentAFlag) {
	                    regexFlags += this.current();
	                    this.forward();
	                } else {
	                    break;
	                }
	            }

	            return token(TOKEN_REGEX, {body: regexBody, flags: regexFlags}, lineno, colno);
	        }
	        else if(delimChars.indexOf(cur) !== -1) {
	            // We've hit a delimiter (a special char like a bracket)
	            this.forward();
	            var complexOps = ['==', '===', '!=', '!==', '<=', '>=', '//', '**'];
	            var curComplex = cur + this.current();
	            var type;

	            if(lib.indexOf(complexOps, curComplex) !== -1) {
	                this.forward();
	                cur = curComplex;

	                // See if this is a strict equality/inequality comparator
	                if(lib.indexOf(complexOps, curComplex + this.current()) !== -1) {
	                    cur = curComplex + this.current();
	                    this.forward();
	                }
	            }

	            switch(cur) {
	            case '(': type = TOKEN_LEFT_PAREN; break;
	            case ')': type = TOKEN_RIGHT_PAREN; break;
	            case '[': type = TOKEN_LEFT_BRACKET; break;
	            case ']': type = TOKEN_RIGHT_BRACKET; break;
	            case '{': type = TOKEN_LEFT_CURLY; break;
	            case '}': type = TOKEN_RIGHT_CURLY; break;
	            case ',': type = TOKEN_COMMA; break;
	            case ':': type = TOKEN_COLON; break;
	            case '~': type = TOKEN_TILDE; break;
	            case '|': type = TOKEN_PIPE; break;
	            default: type = TOKEN_OPERATOR;
	            }

	            return token(type, cur, lineno, colno);
	        }
	        else {
	            // We are not at whitespace or a delimiter, so extract the
	            // text and parse it
	            tok = this._extractUntil(whitespaceChars + delimChars);

	            if(tok.match(/^[-+]?[0-9]+$/)) {
	                if(this.current() === '.') {
	                    this.forward();
	                    var dec = this._extract(intChars);
	                    return token(TOKEN_FLOAT, tok + '.' + dec, lineno, colno);
	                }
	                else {
	                    return token(TOKEN_INT, tok, lineno, colno);
	                }
	            }
	            else if(tok.match(/^(true|false)$/)) {
	                return token(TOKEN_BOOLEAN, tok, lineno, colno);
	            }
	            else if(tok === 'none') {
	                return token(TOKEN_NONE, tok, lineno, colno);
	            }
	            else if(tok) {
	                return token(TOKEN_SYMBOL, tok, lineno, colno);
	            }
	            else {
	                throw new Error('Unexpected value while parsing: ' + tok);
	            }
	        }
	    }
	    else {
	        // Parse out the template text, breaking on tag
	        // delimiters because we need to look for block/variable start
	        // tags (don't use the full delimChars for optimization)
	        var beginChars = (this.tags.BLOCK_START.charAt(0) +
	                          this.tags.VARIABLE_START.charAt(0) +
	                          this.tags.COMMENT_START.charAt(0) +
	                          this.tags.COMMENT_END.charAt(0));

	        if(this.is_finished()) {
	            return null;
	        }
	        else if((tok = this._extractString(this.tags.BLOCK_START + '-')) ||
	                (tok = this._extractString(this.tags.BLOCK_START))) {
	            this.in_code = true;
	            return token(TOKEN_BLOCK_START, tok, lineno, colno);
	        }
	        else if((tok = this._extractString(this.tags.VARIABLE_START + '-')) ||
	                (tok = this._extractString(this.tags.VARIABLE_START))) {
	            this.in_code = true;
	            return token(TOKEN_VARIABLE_START, tok, lineno, colno);
	        }
	        else {
	            tok = '';
	            var data;
	            var in_comment = false;

	            if(this._matches(this.tags.COMMENT_START)) {
	                in_comment = true;
	                tok = this._extractString(this.tags.COMMENT_START);
	            }

	            // Continually consume text, breaking on the tag delimiter
	            // characters and checking to see if it's a start tag.
	            //
	            // We could hit the end of the template in the middle of
	            // our looping, so check for the null return value from
	            // _extractUntil
	            while((data = this._extractUntil(beginChars)) !== null) {
	                tok += data;

	                if((this._matches(this.tags.BLOCK_START) ||
	                    this._matches(this.tags.VARIABLE_START) ||
	                    this._matches(this.tags.COMMENT_START)) &&
	                  !in_comment) {
	                    if(this.lstripBlocks &&
	                        this._matches(this.tags.BLOCK_START) &&
	                        this.colno > 0 &&
	                        this.colno <= tok.length) {
	                        var lastLine = tok.slice(-this.colno);
	                        if(/^\s+$/.test(lastLine)) {
	                            // Remove block leading whitespace from beginning of the string
	                            tok = tok.slice(0, -this.colno);
	                            if(!tok.length) {
	                                // All data removed, collapse to avoid unnecessary nodes
	                                // by returning next token (block start)
	                                return this.nextToken();
	                            }
	                        }
	                    }
	                    // If it is a start tag, stop looping
	                    break;
	                }
	                else if(this._matches(this.tags.COMMENT_END)) {
	                    if(!in_comment) {
	                        throw new Error('unexpected end of comment');
	                    }
	                    tok += this._extractString(this.tags.COMMENT_END);
	                    break;
	                }
	                else {
	                    // It does not match any tag, so add the character and
	                    // carry on
	                    tok += this.current();
	                    this.forward();
	                }
	            }

	            if(data === null && in_comment) {
	                throw new Error('expected end of comment, got end of file');
	            }

	            return token(in_comment ? TOKEN_COMMENT : TOKEN_DATA,
	                         tok,
	                         lineno,
	                         colno);
	        }
	    }

	    throw new Error('Could not parse text');
	};

	Tokenizer.prototype.parseString = function(delimiter) {
	    this.forward();

	    var str = '';

	    while(!this.is_finished() && this.current() !== delimiter) {
	        var cur = this.current();

	        if(cur === '\\') {
	            this.forward();
	            switch(this.current()) {
	            case 'n': str += '\n'; break;
	            case 't': str += '\t'; break;
	            case 'r': str += '\r'; break;
	            default:
	                str += this.current();
	            }
	            this.forward();
	        }
	        else {
	            str += cur;
	            this.forward();
	        }
	    }

	    this.forward();
	    return str;
	};

	Tokenizer.prototype._matches = function(str) {
	    if(this.index + str.length > this.len) {
	        return null;
	    }

	    var m = this.str.slice(this.index, this.index + str.length);
	    return m === str;
	};

	Tokenizer.prototype._extractString = function(str) {
	    if(this._matches(str)) {
	        this.index += str.length;
	        return str;
	    }
	    return null;
	};

	Tokenizer.prototype._extractUntil = function(charString) {
	    // Extract all non-matching chars, with the default matching set
	    // to everything
	    return this._extractMatching(true, charString || '');
	};

	Tokenizer.prototype._extract = function(charString) {
	    // Extract all matching chars (no default, so charString must be
	    // explicit)
	    return this._extractMatching(false, charString);
	};

	Tokenizer.prototype._extractMatching = function (breakOnMatch, charString) {
	    // Pull out characters until a breaking char is hit.
	    // If breakOnMatch is false, a non-matching char stops it.
	    // If breakOnMatch is true, a matching char stops it.

	    if(this.is_finished()) {
	        return null;
	    }

	    var first = charString.indexOf(this.current());

	    // Only proceed if the first character doesn't meet our condition
	    if((breakOnMatch && first === -1) ||
	       (!breakOnMatch && first !== -1)) {
	        var t = this.current();
	        this.forward();

	        // And pull out all the chars one at a time until we hit a
	        // breaking char
	        var idx = charString.indexOf(this.current());

	        while(((breakOnMatch && idx === -1) ||
	               (!breakOnMatch && idx !== -1)) && !this.is_finished()) {
	            t += this.current();
	            this.forward();

	            idx = charString.indexOf(this.current());
	        }

	        return t;
	    }

	    return '';
	};

	Tokenizer.prototype._extractRegex = function(regex) {
	    var matches = this.currentStr().match(regex);
	    if(!matches) {
	        return null;
	    }

	    // Move forward whatever was matched
	    this.forwardN(matches[0].length);

	    return matches;
	};

	Tokenizer.prototype.is_finished = function() {
	    return this.index >= this.len;
	};

	Tokenizer.prototype.forwardN = function(n) {
	    for(var i=0; i<n; i++) {
	        this.forward();
	    }
	};

	Tokenizer.prototype.forward = function() {
	    this.index++;

	    if(this.previous() === '\n') {
	        this.lineno++;
	        this.colno = 0;
	    }
	    else {
	        this.colno++;
	    }
	};

	Tokenizer.prototype.backN = function(n) {
	    for(var i=0; i<n; i++) {
	        this.back();
	    }
	};

	Tokenizer.prototype.back = function() {
	    this.index--;

	    if(this.current() === '\n') {
	        this.lineno--;

	        var idx = this.src.lastIndexOf('\n', this.index-1);
	        if(idx === -1) {
	            this.colno = this.index;
	        }
	        else {
	            this.colno = this.index - idx;
	        }
	    }
	    else {
	        this.colno--;
	    }
	};

	// current returns current character
	Tokenizer.prototype.current = function() {
	    if(!this.is_finished()) {
	        return this.str.charAt(this.index);
	    }
	    return '';
	};

	// currentStr returns what's left of the unparsed string
	Tokenizer.prototype.currentStr = function() {
	    if(!this.is_finished()) {
	        return this.str.substr(this.index);
	    }
	    return '';
	};

	Tokenizer.prototype.previous = function() {
	    return this.str.charAt(this.index-1);
	};

	module.exports = {
	    lex: function(src, opts) {
	        return new Tokenizer(src, opts);
	    },

	    TOKEN_STRING: TOKEN_STRING,
	    TOKEN_WHITESPACE: TOKEN_WHITESPACE,
	    TOKEN_DATA: TOKEN_DATA,
	    TOKEN_BLOCK_START: TOKEN_BLOCK_START,
	    TOKEN_BLOCK_END: TOKEN_BLOCK_END,
	    TOKEN_VARIABLE_START: TOKEN_VARIABLE_START,
	    TOKEN_VARIABLE_END: TOKEN_VARIABLE_END,
	    TOKEN_COMMENT: TOKEN_COMMENT,
	    TOKEN_LEFT_PAREN: TOKEN_LEFT_PAREN,
	    TOKEN_RIGHT_PAREN: TOKEN_RIGHT_PAREN,
	    TOKEN_LEFT_BRACKET: TOKEN_LEFT_BRACKET,
	    TOKEN_RIGHT_BRACKET: TOKEN_RIGHT_BRACKET,
	    TOKEN_LEFT_CURLY: TOKEN_LEFT_CURLY,
	    TOKEN_RIGHT_CURLY: TOKEN_RIGHT_CURLY,
	    TOKEN_OPERATOR: TOKEN_OPERATOR,
	    TOKEN_COMMA: TOKEN_COMMA,
	    TOKEN_COLON: TOKEN_COLON,
	    TOKEN_TILDE: TOKEN_TILDE,
	    TOKEN_PIPE: TOKEN_PIPE,
	    TOKEN_INT: TOKEN_INT,
	    TOKEN_FLOAT: TOKEN_FLOAT,
	    TOKEN_BOOLEAN: TOKEN_BOOLEAN,
	    TOKEN_NONE: TOKEN_NONE,
	    TOKEN_SYMBOL: TOKEN_SYMBOL,
	    TOKEN_SPECIAL: TOKEN_SPECIAL,
	    TOKEN_REGEX: TOKEN_REGEX
	};


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var lib = __webpack_require__(1);
	// jshint -W079
	var Object = __webpack_require__(6);

	function traverseAndCheck(obj, type, results) {
	    if(obj instanceof type) {
	        results.push(obj);
	    }

	    if(obj instanceof Node) {
	        obj.findAll(type, results);
	    }
	}

	var Node = Object.extend('Node', {
	    init: function(lineno, colno) {
	        this.lineno = lineno;
	        this.colno = colno;

	        var fields = this.fields;
	        for(var i = 0, l = fields.length; i < l; i++) {
	            var field = fields[i];

	            // The first two args are line/col numbers, so offset by 2
	            var val = arguments[i + 2];

	            // Fields should never be undefined, but null. It makes
	            // testing easier to normalize values.
	            if(val === undefined) {
	                val = null;
	            }

	            this[field] = val;
	        }
	    },

	    findAll: function(type, results) {
	        results = results || [];

	        var i, l;
	        if(this instanceof NodeList) {
	            var children = this.children;

	            for(i = 0, l = children.length; i < l; i++) {
	                traverseAndCheck(children[i], type, results);
	            }
	        }
	        else {
	            var fields = this.fields;

	            for(i = 0, l = fields.length; i < l; i++) {
	                traverseAndCheck(this[fields[i]], type, results);
	            }
	        }

	        return results;
	    },

	    iterFields: function(func) {
	        lib.each(this.fields, function(field) {
	            func(this[field], field);
	        }, this);
	    }
	});

	// Abstract nodes
	var Value = Node.extend('Value', { fields: ['value'] });

	// Concrete nodes
	var NodeList = Node.extend('NodeList', {
	    fields: ['children'],

	    init: function(lineno, colno, nodes) {
	        this.parent(lineno, colno, nodes || []);
	    },

	    addChild: function(node) {
	        this.children.push(node);
	    }
	});

	var Root = NodeList.extend('Root');
	var Literal = Value.extend('Literal');
	var Symbol = Value.extend('Symbol');
	var Group = NodeList.extend('Group');
	var Array = NodeList.extend('Array');
	var Pair = Node.extend('Pair', { fields: ['key', 'value'] });
	var Dict = NodeList.extend('Dict');
	var LookupVal = Node.extend('LookupVal', { fields: ['target', 'val'] });
	var If = Node.extend('If', { fields: ['cond', 'body', 'else_'] });
	var IfAsync = If.extend('IfAsync');
	var InlineIf = Node.extend('InlineIf', { fields: ['cond', 'body', 'else_'] });
	var For = Node.extend('For', { fields: ['arr', 'name', 'body', 'else_'] });
	var AsyncEach = For.extend('AsyncEach');
	var AsyncAll = For.extend('AsyncAll');
	var Macro = Node.extend('Macro', { fields: ['name', 'args', 'body'] });
	var Caller = Macro.extend('Caller');
	var Import = Node.extend('Import', { fields: ['template', 'target', 'withContext'] });
	var FromImport = Node.extend('FromImport', {
	    fields: ['template', 'names', 'withContext'],

	    init: function(lineno, colno, template, names, withContext) {
	        this.parent(lineno, colno,
	                    template,
	                    names || new NodeList(), withContext);
	    }
	});
	var FunCall = Node.extend('FunCall', { fields: ['name', 'args'] });
	var Filter = FunCall.extend('Filter');
	var FilterAsync = Filter.extend('FilterAsync', {
	    fields: ['name', 'args', 'symbol']
	});
	var KeywordArgs = Dict.extend('KeywordArgs');
	var Block = Node.extend('Block', { fields: ['name', 'body'] });
	var Super = Node.extend('Super', { fields: ['blockName', 'symbol'] });
	var TemplateRef = Node.extend('TemplateRef', { fields: ['template'] });
	var Extends = TemplateRef.extend('Extends');
	var Include = Node.extend('Include', { fields: ['template', 'ignoreMissing'] });
	var Set = Node.extend('Set', { fields: ['targets', 'value'] });
	var Output = NodeList.extend('Output');
	var Capture = Node.extend('Capture', { fields: ['body'] });
	var TemplateData = Literal.extend('TemplateData');
	var UnaryOp = Node.extend('UnaryOp', { fields: ['target'] });
	var BinOp = Node.extend('BinOp', { fields: ['left', 'right'] });
	var In = BinOp.extend('In');
	var Or = BinOp.extend('Or');
	var And = BinOp.extend('And');
	var Not = UnaryOp.extend('Not');
	var Add = BinOp.extend('Add');
	var Concat = BinOp.extend('Concat');
	var Sub = BinOp.extend('Sub');
	var Mul = BinOp.extend('Mul');
	var Div = BinOp.extend('Div');
	var FloorDiv = BinOp.extend('FloorDiv');
	var Mod = BinOp.extend('Mod');
	var Pow = BinOp.extend('Pow');
	var Neg = UnaryOp.extend('Neg');
	var Pos = UnaryOp.extend('Pos');
	var Compare = Node.extend('Compare', { fields: ['expr', 'ops'] });
	var CompareOperand = Node.extend('CompareOperand', {
	    fields: ['expr', 'type']
	});

	var CallExtension = Node.extend('CallExtension', {
	    fields: ['extName', 'prop', 'args', 'contentArgs'],

	    init: function(ext, prop, args, contentArgs) {
	        this.extName = ext._name || ext;
	        this.prop = prop;
	        this.args = args || new NodeList();
	        this.contentArgs = contentArgs || [];
	        this.autoescape = ext.autoescape;
	    }
	});

	var CallExtensionAsync = CallExtension.extend('CallExtensionAsync');

	// Print the AST in a nicely formatted tree format for debuggin
	function printNodes(node, indent) {
	    indent = indent || 0;

	    // This is hacky, but this is just a debugging function anyway
	    function print(str, indent, inline) {
	        var lines = str.split('\n');

	        for(var i=0; i<lines.length; i++) {
	            if(lines[i]) {
	                if((inline && i > 0) || !inline) {
	                    for(var j=0; j<indent; j++) {
	                        process.stdout.write(' ');
	                    }
	                }
	            }

	            if(i === lines.length-1) {
	                process.stdout.write(lines[i]);
	            }
	            else {
	                process.stdout.write(lines[i] + '\n');
	            }
	        }
	    }

	    print(node.typename + ': ', indent);

	    if(node instanceof NodeList) {
	        print('\n');
	        lib.each(node.children, function(n) {
	            printNodes(n, indent + 2);
	        });
	    }
	    else if(node instanceof CallExtension) {
	        print(node.extName + '.' + node.prop);
	        print('\n');

	        if(node.args) {
	            printNodes(node.args, indent + 2);
	        }

	        if(node.contentArgs) {
	            lib.each(node.contentArgs, function(n) {
	                printNodes(n, indent + 2);
	            });
	        }
	    }
	    else {
	        var nodes = null;
	        var props = null;

	        node.iterFields(function(val, field) {
	            if(val instanceof Node) {
	                nodes = nodes || {};
	                nodes[field] = val;
	            }
	            else {
	                props = props || {};
	                props[field] = val;
	            }
	        });

	        if(props) {
	            print(JSON.stringify(props, null, 2) + '\n', null, true);
	        }
	        else {
	            print('\n');
	        }

	        if(nodes) {
	            for(var k in nodes) {
	                printNodes(nodes[k], indent + 2);
	            }
	        }

	    }
	}

	// var t = new NodeList(0, 0,
	//                      [new Value(0, 0, 3),
	//                       new Value(0, 0, 10),
	//                       new Pair(0, 0,
	//                                new Value(0, 0, 'key'),
	//                                new Value(0, 0, 'value'))]);
	// printNodes(t);

	module.exports = {
	    Node: Node,
	    Root: Root,
	    NodeList: NodeList,
	    Value: Value,
	    Literal: Literal,
	    Symbol: Symbol,
	    Group: Group,
	    Array: Array,
	    Pair: Pair,
	    Dict: Dict,
	    Output: Output,
	    Capture: Capture,
	    TemplateData: TemplateData,
	    If: If,
	    IfAsync: IfAsync,
	    InlineIf: InlineIf,
	    For: For,
	    AsyncEach: AsyncEach,
	    AsyncAll: AsyncAll,
	    Macro: Macro,
	    Caller: Caller,
	    Import: Import,
	    FromImport: FromImport,
	    FunCall: FunCall,
	    Filter: Filter,
	    FilterAsync: FilterAsync,
	    KeywordArgs: KeywordArgs,
	    Block: Block,
	    Super: Super,
	    Extends: Extends,
	    Include: Include,
	    Set: Set,
	    LookupVal: LookupVal,
	    BinOp: BinOp,
	    In: In,
	    Or: Or,
	    And: And,
	    Not: Not,
	    Add: Add,
	    Concat: Concat,
	    Sub: Sub,
	    Mul: Mul,
	    Div: Div,
	    FloorDiv: FloorDiv,
	    Mod: Mod,
	    Pow: Pow,
	    Neg: Neg,
	    Pos: Pos,
	    Compare: Compare,
	    CompareOperand: CompareOperand,

	    CallExtension: CallExtension,
	    CallExtensionAsync: CallExtensionAsync,

	    printNodes: printNodes
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var nodes = __webpack_require__(10);
	var lib = __webpack_require__(1);

	var sym = 0;
	function gensym() {
	    return 'hole_' + sym++;
	}

	// copy-on-write version of map
	function mapCOW(arr, func) {
	    var res = null;

	    for(var i=0; i<arr.length; i++) {
	        var item = func(arr[i]);

	        if(item !== arr[i]) {
	            if(!res) {
	                res = arr.slice();
	            }

	            res[i] = item;
	        }
	    }

	    return res || arr;
	}

	function walk(ast, func, depthFirst) {
	    if(!(ast instanceof nodes.Node)) {
	        return ast;
	    }

	    if(!depthFirst) {
	        var astT = func(ast);

	        if(astT && astT !== ast) {
	            return astT;
	        }
	    }

	    if(ast instanceof nodes.NodeList) {
	        var children = mapCOW(ast.children, function(node) {
	            return walk(node, func, depthFirst);
	        });

	        if(children !== ast.children) {
	            ast = new nodes[ast.typename](ast.lineno, ast.colno, children);
	        }
	    }
	    else if(ast instanceof nodes.CallExtension) {
	        var args = walk(ast.args, func, depthFirst);

	        var contentArgs = mapCOW(ast.contentArgs, function(node) {
	            return walk(node, func, depthFirst);
	        });

	        if(args !== ast.args || contentArgs !== ast.contentArgs) {
	            ast = new nodes[ast.typename](ast.extName,
	                                          ast.prop,
	                                          args,
	                                          contentArgs);
	        }
	    }
	    else {
	        var props = ast.fields.map(function(field) {
	            return ast[field];
	        });

	        var propsT = mapCOW(props, function(prop) {
	            return walk(prop, func, depthFirst);
	        });

	        if(propsT !== props) {
	            ast = new nodes[ast.typename](ast.lineno, ast.colno);

	            propsT.forEach(function(prop, i) {
	                ast[ast.fields[i]] = prop;
	            });
	        }
	    }

	    return depthFirst ? (func(ast) || ast) : ast;
	}

	function depthWalk(ast, func) {
	    return walk(ast, func, true);
	}

	function _liftFilters(node, asyncFilters, prop) {
	    var children = [];

	    var walked = depthWalk(prop ? node[prop] : node, function(node) {
	        if(node instanceof nodes.Block) {
	            return node;
	        }
	        else if((node instanceof nodes.Filter &&
	                 lib.indexOf(asyncFilters, node.name.value) !== -1) ||
	                node instanceof nodes.CallExtensionAsync) {
	            var symbol = new nodes.Symbol(node.lineno,
	                                          node.colno,
	                                          gensym());

	            children.push(new nodes.FilterAsync(node.lineno,
	                                                node.colno,
	                                                node.name,
	                                                node.args,
	                                                symbol));
	            return symbol;
	        }
	    });

	    if(prop) {
	        node[prop] = walked;
	    }
	    else {
	        node = walked;
	    }

	    if(children.length) {
	        children.push(node);

	        return new nodes.NodeList(
	            node.lineno,
	            node.colno,
	            children
	        );
	    }
	    else {
	        return node;
	    }
	}

	function liftFilters(ast, asyncFilters) {
	    return depthWalk(ast, function(node) {
	        if(node instanceof nodes.Output) {
	            return _liftFilters(node, asyncFilters);
	        }
	        else if(node instanceof nodes.Set) {
	            return _liftFilters(node, asyncFilters, 'value');
	        }
	        else if(node instanceof nodes.For) {
	            return _liftFilters(node, asyncFilters, 'arr');
	        }
	        else if(node instanceof nodes.If) {
	            return _liftFilters(node, asyncFilters, 'cond');
	        }
	        else if(node instanceof nodes.CallExtension) {
	            return _liftFilters(node, asyncFilters, 'args');
	        }
	    });
	}

	function liftSuper(ast) {
	    return walk(ast, function(blockNode) {
	        if(!(blockNode instanceof nodes.Block)) {
	            return;
	        }

	        var hasSuper = false;
	        var symbol = gensym();

	        blockNode.body = walk(blockNode.body, function(node) {
	            if(node instanceof nodes.FunCall &&
	               node.name.value === 'super') {
	                hasSuper = true;
	                return new nodes.Symbol(node.lineno, node.colno, symbol);
	            }
	        });

	        if(hasSuper) {
	            blockNode.body.children.unshift(new nodes.Super(
	                0, 0, blockNode.name, new nodes.Symbol(0, 0, symbol)
	            ));
	        }
	    });
	}

	function convertStatements(ast) {
	    return depthWalk(ast, function(node) {
	        if(!(node instanceof nodes.If) &&
	           !(node instanceof nodes.For)) {
	            return;
	        }

	        var async = false;
	        walk(node, function(node) {
	            if(node instanceof nodes.FilterAsync ||
	               node instanceof nodes.IfAsync ||
	               node instanceof nodes.AsyncEach ||
	               node instanceof nodes.AsyncAll ||
	               node instanceof nodes.CallExtensionAsync) {
	                async = true;
	                // Stop iterating by returning the node
	                return node;
	            }
	        });

	        if(async) {
		        if(node instanceof nodes.If) {
	                return new nodes.IfAsync(
	                    node.lineno,
	                    node.colno,
	                    node.cond,
	                    node.body,
	                    node.else_
	                );
	            }
	            else if(node instanceof nodes.For) {
	                return new nodes.AsyncEach(
	                    node.lineno,
	                    node.colno,
	                    node.arr,
	                    node.name,
	                    node.body,
	                    node.else_
	                );
	            }
	        }
	    });
	}

	function cps(ast, asyncFilters) {
	    return convertStatements(liftSuper(liftFilters(ast, asyncFilters)));
	}

	function transform(ast, asyncFilters) {
	    return cps(ast, asyncFilters || []);
	}

	// var parser = require('./parser');
	// var src = 'hello {% foo %}{% endfoo %} end';
	// var ast = transform(parser.parse(src, [new FooExtension()]), ['bar']);
	// nodes.printNodes(ast);

	module.exports = {
	    transform: transform
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var lib = __webpack_require__(1);
	var Obj = __webpack_require__(6);

	// Frames keep track of scoping both at compile-time and run-time so
	// we know how to access variables. Block tags can introduce special
	// variables, for example.
	var Frame = Obj.extend({
	    init: function(parent, isolateWrites) {
	        this.variables = {};
	        this.parent = parent;
	        this.topLevel = false;
	        // if this is true, writes (set) should never propagate upwards past
	        // this frame to its parent (though reads may).
	        this.isolateWrites = isolateWrites;
	    },

	    set: function(name, val, resolveUp) {
	        // Allow variables with dots by automatically creating the
	        // nested structure
	        var parts = name.split('.');
	        var obj = this.variables;
	        var frame = this;

	        if(resolveUp) {
	            if((frame = this.resolve(parts[0], true))) {
	                frame.set(name, val);
	                return;
	            }
	        }

	        for(var i=0; i<parts.length - 1; i++) {
	            var id = parts[i];

	            if(!obj[id]) {
	                obj[id] = {};
	            }
	            obj = obj[id];
	        }

	        obj[parts[parts.length - 1]] = val;
	    },

	    get: function(name) {
	        var val = this.variables[name];
	        if(val !== undefined) {
	            return val;
	        }
	        return null;
	    },

	    lookup: function(name) {
	        var p = this.parent;
	        var val = this.variables[name];
	        if(val !== undefined) {
	            return val;
	        }
	        return p && p.lookup(name);
	    },

	    resolve: function(name, forWrite) {
	        var p = (forWrite && this.isolateWrites) ? undefined : this.parent;
	        var val = this.variables[name];
	        if(val !== undefined) {
	            return this;
	        }
	        return p && p.resolve(name);
	    },

	    push: function(isolateWrites) {
	        return new Frame(this, isolateWrites);
	    },

	    pop: function() {
	        return this.parent;
	    }
	});

	function makeMacro(argNames, kwargNames, func) {
	    return function() {
	        var argCount = numArgs(arguments);
	        var args;
	        var kwargs = getKeywordArgs(arguments);
	        var i;

	        if(argCount > argNames.length) {
	            args = Array.prototype.slice.call(arguments, 0, argNames.length);

	            // Positional arguments that should be passed in as
	            // keyword arguments (essentially default values)
	            var vals = Array.prototype.slice.call(arguments, args.length, argCount);
	            for(i = 0; i < vals.length; i++) {
	                if(i < kwargNames.length) {
	                    kwargs[kwargNames[i]] = vals[i];
	                }
	            }

	            args.push(kwargs);
	        }
	        else if(argCount < argNames.length) {
	            args = Array.prototype.slice.call(arguments, 0, argCount);

	            for(i = argCount; i < argNames.length; i++) {
	                var arg = argNames[i];

	                // Keyword arguments that should be passed as
	                // positional arguments, i.e. the caller explicitly
	                // used the name of a positional arg
	                args.push(kwargs[arg]);
	                delete kwargs[arg];
	            }

	            args.push(kwargs);
	        }
	        else {
	            args = arguments;
	        }

	        return func.apply(this, args);
	    };
	}

	function makeKeywordArgs(obj) {
	    obj.__keywords = true;
	    return obj;
	}

	function getKeywordArgs(args) {
	    var len = args.length;
	    if(len) {
	        var lastArg = args[len - 1];
	        if(lastArg && lastArg.hasOwnProperty('__keywords')) {
	            return lastArg;
	        }
	    }
	    return {};
	}

	function numArgs(args) {
	    var len = args.length;
	    if(len === 0) {
	        return 0;
	    }

	    var lastArg = args[len - 1];
	    if(lastArg && lastArg.hasOwnProperty('__keywords')) {
	        return len - 1;
	    }
	    else {
	        return len;
	    }
	}

	// A SafeString object indicates that the string should not be
	// autoescaped. This happens magically because autoescaping only
	// occurs on primitive string objects.
	function SafeString(val) {
	    if(typeof val !== 'string') {
	        return val;
	    }

	    this.val = val;
	    this.length = val.length;
	}

	SafeString.prototype = Object.create(String.prototype, {
	    length: { writable: true, configurable: true, value: 0 }
	});
	SafeString.prototype.valueOf = function() {
	    return this.val;
	};
	SafeString.prototype.toString = function() {
	    return this.val;
	};

	function copySafeness(dest, target) {
	    if(dest instanceof SafeString) {
	        return new SafeString(target);
	    }
	    return target.toString();
	}

	function markSafe(val) {
	    var type = typeof val;

	    if(type === 'string') {
	        return new SafeString(val);
	    }
	    else if(type !== 'function') {
	        return val;
	    }
	    else {
	        return function() {
	            var ret = val.apply(this, arguments);

	            if(typeof ret === 'string') {
	                return new SafeString(ret);
	            }

	            return ret;
	        };
	    }
	}

	function suppressValue(val, autoescape) {
	    val = (val !== undefined && val !== null) ? val : '';

	    if(autoescape && !(val instanceof SafeString)) {
	        val = lib.escape(val.toString());
	    }

	    return val;
	}

	function ensureDefined(val, lineno, colno) {
	    if(val === null || val === undefined) {
	        throw new lib.TemplateError(
	            'attempted to output null or undefined value',
	            lineno + 1,
	            colno + 1
	        );
	    }
	    return val;
	}

	function memberLookup(obj, val) {
	    obj = obj || {};

	    if(typeof obj[val] === 'function') {
	        return function() {
	            return obj[val].apply(obj, arguments);
	        };
	    }

	    return obj[val];
	}

	function callWrap(obj, name, context, args) {
	    if(!obj) {
	        throw new Error('Unable to call `' + name + '`, which is undefined or falsey');
	    }
	    else if(typeof obj !== 'function') {
	        throw new Error('Unable to call `' + name + '`, which is not a function');
	    }

	    // jshint validthis: true
	    return obj.apply(context, args);
	}

	function contextOrFrameLookup(context, frame, name) {
	    var val = frame.lookup(name);
	    return (val !== undefined) ?
	        val :
	        context.lookup(name);
	}

	function handleError(error, lineno, colno) {
	    if(error.lineno) {
	        return error;
	    }
	    else {
	        return new lib.TemplateError(error, lineno, colno);
	    }
	}

	function asyncEach(arr, dimen, iter, cb) {
	    if(lib.isArray(arr)) {
	        var len = arr.length;

	        lib.asyncIter(arr, function(item, i, next) {
	            switch(dimen) {
	            case 1: iter(item, i, len, next); break;
	            case 2: iter(item[0], item[1], i, len, next); break;
	            case 3: iter(item[0], item[1], item[2], i, len, next); break;
	            default:
	                item.push(i, next);
	                iter.apply(this, item);
	            }
	        }, cb);
	    }
	    else {
	        lib.asyncFor(arr, function(key, val, i, len, next) {
	            iter(key, val, i, len, next);
	        }, cb);
	    }
	}

	function asyncAll(arr, dimen, func, cb) {
	    var finished = 0;
	    var len, i;
	    var outputArr;

	    function done(i, output) {
	        finished++;
	        outputArr[i] = output;

	        if(finished === len) {
	            cb(null, outputArr.join(''));
	        }
	    }

	    if(lib.isArray(arr)) {
	        len = arr.length;
	        outputArr = new Array(len);

	        if(len === 0) {
	            cb(null, '');
	        }
	        else {
	            for(i = 0; i < arr.length; i++) {
	                var item = arr[i];

	                switch(dimen) {
	                case 1: func(item, i, len, done); break;
	                case 2: func(item[0], item[1], i, len, done); break;
	                case 3: func(item[0], item[1], item[2], i, len, done); break;
	                default:
	                    item.push(i, done);
	                    // jshint validthis: true
	                    func.apply(this, item);
	                }
	            }
	        }
	    }
	    else {
	        var keys = lib.keys(arr);
	        len = keys.length;
	        outputArr = new Array(len);

	        if(len === 0) {
	            cb(null, '');
	        }
	        else {
	            for(i = 0; i < keys.length; i++) {
	                var k = keys[i];
	                func(k, arr[k], i, len, done);
	            }
	        }
	    }
	}

	module.exports = {
	    Frame: Frame,
	    makeMacro: makeMacro,
	    makeKeywordArgs: makeKeywordArgs,
	    numArgs: numArgs,
	    suppressValue: suppressValue,
	    ensureDefined: ensureDefined,
	    memberLookup: memberLookup,
	    contextOrFrameLookup: contextOrFrameLookup,
	    callWrap: callWrap,
	    handleError: handleError,
	    isArray: lib.isArray,
	    keys: lib.keys,
	    SafeString: SafeString,
	    copySafeness: copySafeness,
	    markSafe: markSafe,
	    asyncEach: asyncEach,
	    asyncAll: asyncAll,
	    inOperator: lib.inOperator
	};


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var lib = __webpack_require__(1);
	var r = __webpack_require__(12);

	function normalize(value, defaultValue) {
	    if(value === null || value === undefined || value === false) {
	        return defaultValue;
	    }
	    return value;
	}

	var filters = {
	    abs: function(n) {
	        return Math.abs(n);
	    },

	    batch: function(arr, linecount, fill_with) {
	        var i;
	        var res = [];
	        var tmp = [];

	        for(i = 0; i < arr.length; i++) {
	            if(i % linecount === 0 && tmp.length) {
	                res.push(tmp);
	                tmp = [];
	            }

	            tmp.push(arr[i]);
	        }

	        if(tmp.length) {
	            if(fill_with) {
	                for(i = tmp.length; i < linecount; i++) {
	                    tmp.push(fill_with);
	                }
	            }

	            res.push(tmp);
	        }

	        return res;
	    },

	    capitalize: function(str) {
	        str = normalize(str, '');
	        var ret = str.toLowerCase();
	        return r.copySafeness(str, ret.charAt(0).toUpperCase() + ret.slice(1));
	    },

	    center: function(str, width) {
	        str = normalize(str, '');
	        width = width || 80;

	        if(str.length >= width) {
	            return str;
	        }

	        var spaces = width - str.length;
	        var pre = lib.repeat(' ', spaces/2 - spaces % 2);
	        var post = lib.repeat(' ', spaces/2);
	        return r.copySafeness(str, pre + str + post);
	    },

	    'default': function(val, def, bool) {
	        if(bool) {
	            return val ? val : def;
	        }
	        else {
	            return (val !== undefined) ? val : def;
	        }
	    },

	    dictsort: function(val, case_sensitive, by) {
	        if (!lib.isObject(val)) {
	            throw new lib.TemplateError('dictsort filter: val must be an object');
	        }

	        var array = [];
	        for (var k in val) {
	            // deliberately include properties from the object's prototype
	            array.push([k,val[k]]);
	        }

	        var si;
	        if (by === undefined || by === 'key') {
	            si = 0;
	        } else if (by === 'value') {
	            si = 1;
	        } else {
	            throw new lib.TemplateError(
	                'dictsort filter: You can only sort by either key or value');
	        }

	        array.sort(function(t1, t2) {
	            var a = t1[si];
	            var b = t2[si];

	            if (!case_sensitive) {
	                if (lib.isString(a)) {
	                    a = a.toUpperCase();
	                }
	                if (lib.isString(b)) {
	                    b = b.toUpperCase();
	                }
	            }

	            return a > b ? 1 : (a === b ? 0 : -1);
	        });

	        return array;
	    },

	    dump: function(obj, spaces) {
	        return JSON.stringify(obj, null, spaces);
	    },

	    escape: function(str) {
	        if(str instanceof r.SafeString) {
	            return str;
	        }
	        str = (str === null || str === undefined) ? '' : str;
	        return r.markSafe(lib.escape(str.toString()));
	    },

	    safe: function(str) {
	        if (str instanceof r.SafeString) {
	            return str;
	        }
	        str = (str === null || str === undefined) ? '' : str;
	        return r.markSafe(str.toString());
	    },

	    first: function(arr) {
	        return arr[0];
	    },

	    groupby: function(arr, attr) {
	        return lib.groupBy(arr, attr);
	    },

	    indent: function(str, width, indentfirst) {
	        str = normalize(str, '');

	        if (str === '') return '';

	        width = width || 4;
	        var res = '';
	        var lines = str.split('\n');
	        var sp = lib.repeat(' ', width);

	        for(var i=0; i<lines.length; i++) {
	            if(i === 0 && !indentfirst) {
	                res += lines[i] + '\n';
	            }
	            else {
	                res += sp + lines[i] + '\n';
	            }
	        }

	        return r.copySafeness(str, res);
	    },

	    join: function(arr, del, attr) {
	        del = del || '';

	        if(attr) {
	            arr = lib.map(arr, function(v) {
	                return v[attr];
	            });
	        }

	        return arr.join(del);
	    },

	    last: function(arr) {
	        return arr[arr.length-1];
	    },

	    length: function(val) {
	        var value = normalize(val, '');

	        if(value !== undefined) {
	            if(
	                (typeof Map === 'function' && value instanceof Map) ||
	                (typeof Set === 'function' && value instanceof Set)
	            ) {
	                // ECMAScript 2015 Maps and Sets
	                return value.size;
	            }
	            if(lib.isObject(value) && !(value instanceof r.SafeString)) {
	                // Objects (besides SafeStrings), non-primative Arrays
	                return Object.keys(value).length;
	            }
	            return value.length;
	        }
	        return 0;
	    },

	    list: function(val) {
	        if(lib.isString(val)) {
	            return val.split('');
	        }
	        else if(lib.isObject(val)) {
	            var keys = [];

	            if(Object.keys) {
	                keys = Object.keys(val);
	            }
	            else {
	                for(var k in val) {
	                    keys.push(k);
	                }
	            }

	            return lib.map(keys, function(k) {
	                return { key: k,
	                         value: val[k] };
	            });
	        }
	        else if(lib.isArray(val)) {
	          return val;
	        }
	        else {
	            throw new lib.TemplateError('list filter: type not iterable');
	        }
	    },

	    lower: function(str) {
	        str = normalize(str, '');
	        return str.toLowerCase();
	    },

	    nl2br: function(str) {
	        if (str === null || str === undefined) {
	            return '';
	        }
	        return r.copySafeness(str, str.replace(/\r\n|\n/g, '<br />\n'));
	    },

	    random: function(arr) {
	        return arr[Math.floor(Math.random() * arr.length)];
	    },

	    rejectattr: function(arr, attr) {
	      return arr.filter(function (item) {
	        return !item[attr];
	      });
	    },

	    selectattr: function(arr, attr) {
	      return arr.filter(function (item) {
	        return !!item[attr];
	      });
	    },

	    replace: function(str, old, new_, maxCount) {
	        var originalStr = str;

	        if (old instanceof RegExp) {
	            return str.replace(old, new_);
	        }

	        if(typeof maxCount === 'undefined'){
	            maxCount = -1;
	        }

	        var res = '';  // Output

	        // Cast Numbers in the search term to string
	        if(typeof old === 'number'){
	            old = old + '';
	        }
	        else if(typeof old !== 'string') {
	            // If it is something other than number or string,
	            // return the original string
	            return str;
	        }

	        // Cast numbers in the replacement to string
	        if(typeof str === 'number'){
	            str = str + '';
	        }

	        // If by now, we don't have a string, throw it back
	        if(typeof str !== 'string' && !(str instanceof r.SafeString)){
	            return str;
	        }

	        // ShortCircuits
	        if(old === ''){
	            // Mimic the python behaviour: empty string is replaced
	            // by replacement e.g. "abc"|replace("", ".") -> .a.b.c.
	            res = new_ + str.split('').join(new_) + new_;
	            return r.copySafeness(str, res);
	        }

	        var nextIndex = str.indexOf(old);
	        // if # of replacements to perform is 0, or the string to does
	        // not contain the old value, return the string
	        if(maxCount === 0 || nextIndex === -1){
	            return str;
	        }

	        var pos = 0;
	        var count = 0; // # of replacements made

	        while(nextIndex  > -1 && (maxCount === -1 || count < maxCount)){
	            // Grab the next chunk of src string and add it with the
	            // replacement, to the result
	            res += str.substring(pos, nextIndex) + new_;
	            // Increment our pointer in the src string
	            pos = nextIndex + old.length;
	            count++;
	            // See if there are any more replacements to be made
	            nextIndex = str.indexOf(old, pos);
	        }

	        // We've either reached the end, or done the max # of
	        // replacements, tack on any remaining string
	        if(pos < str.length) {
	            res += str.substring(pos);
	        }

	        return r.copySafeness(originalStr, res);
	    },

	    reverse: function(val) {
	        var arr;
	        if(lib.isString(val)) {
	            arr = filters.list(val);
	        }
	        else {
	            // Copy it
	            arr = lib.map(val, function(v) { return v; });
	        }

	        arr.reverse();

	        if(lib.isString(val)) {
	            return r.copySafeness(val, arr.join(''));
	        }
	        return arr;
	    },

	    round: function(val, precision, method) {
	        precision = precision || 0;
	        var factor = Math.pow(10, precision);
	        var rounder;

	        if(method === 'ceil') {
	            rounder = Math.ceil;
	        }
	        else if(method === 'floor') {
	            rounder = Math.floor;
	        }
	        else {
	            rounder = Math.round;
	        }

	        return rounder(val * factor) / factor;
	    },

	    slice: function(arr, slices, fillWith) {
	        var sliceLength = Math.floor(arr.length / slices);
	        var extra = arr.length % slices;
	        var offset = 0;
	        var res = [];

	        for(var i=0; i<slices; i++) {
	            var start = offset + i * sliceLength;
	            if(i < extra) {
	                offset++;
	            }
	            var end = offset + (i + 1) * sliceLength;

	            var slice = arr.slice(start, end);
	            if(fillWith && i >= extra) {
	                slice.push(fillWith);
	            }
	            res.push(slice);
	        }

	        return res;
	    },

	    sum: function(arr, attr, start) {
	        var sum = 0;

	        if(typeof start === 'number'){
	            sum += start;
	        }

	        if(attr) {
	            arr = lib.map(arr, function(v) {
	                return v[attr];
	            });
	        }

	        for(var i = 0; i < arr.length; i++) {
	            sum += arr[i];
	        }

	        return sum;
	    },

	    sort: r.makeMacro(['value', 'reverse', 'case_sensitive', 'attribute'], [], function(arr, reverse, caseSens, attr) {
	         // Copy it
	        arr = lib.map(arr, function(v) { return v; });

	        arr.sort(function(a, b) {
	            var x, y;

	            if(attr) {
	                x = a[attr];
	                y = b[attr];
	            }
	            else {
	                x = a;
	                y = b;
	            }

	            if(!caseSens && lib.isString(x) && lib.isString(y)) {
	                x = x.toLowerCase();
	                y = y.toLowerCase();
	            }

	            if(x < y) {
	                return reverse ? 1 : -1;
	            }
	            else if(x > y) {
	                return reverse ? -1: 1;
	            }
	            else {
	                return 0;
	            }
	        });

	        return arr;
	    }),

	    string: function(obj) {
	        return r.copySafeness(obj, obj);
	    },

	    striptags: function(input, preserve_linebreaks) {
	        input = normalize(input, '');
	        preserve_linebreaks = preserve_linebreaks || false;
	        var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>|<!--[\s\S]*?-->/gi;
	        var trimmedInput = filters.trim(input.replace(tags, ''));
	        var res = '';
	        if (preserve_linebreaks) {
	            res = trimmedInput
	                .replace(/^ +| +$/gm, '')     // remove leading and trailing spaces
	                .replace(/ +/g, ' ')          // squash adjacent spaces
	                .replace(/(\r\n)/g, '\n')     // normalize linebreaks (CRLF -> LF)
	                .replace(/\n\n\n+/g, '\n\n'); // squash abnormal adjacent linebreaks
	        } else {
	            res = trimmedInput.replace(/\s+/gi, ' ');
	        }
	        return r.copySafeness(input, res);
	    },

	    title: function(str) {
	        str = normalize(str, '');
	        var words = str.split(' ');
	        for(var i = 0; i < words.length; i++) {
	            words[i] = filters.capitalize(words[i]);
	        }
	        return r.copySafeness(str, words.join(' '));
	    },

	    trim: function(str) {
	        return r.copySafeness(str, str.replace(/^\s*|\s*$/g, ''));
	    },

	    truncate: function(input, length, killwords, end) {
	        var orig = input;
	        input = normalize(input, '');
	        length = length || 255;

	        if (input.length <= length)
	            return input;

	        if (killwords) {
	            input = input.substring(0, length);
	        } else {
	            var idx = input.lastIndexOf(' ', length);
	            if(idx === -1) {
	                idx = length;
	            }

	            input = input.substring(0, idx);
	        }

	        input += (end !== undefined && end !== null) ? end : '...';
	        return r.copySafeness(orig, input);
	    },

	    upper: function(str) {
	        str = normalize(str, '');
	        return str.toUpperCase();
	    },

	    urlencode: function(obj) {
	        var enc = encodeURIComponent;
	        if (lib.isString(obj)) {
	            return enc(obj);
	        } else {
	            var parts;
	            if (lib.isArray(obj)) {
	                parts = obj.map(function(item) {
	                    return enc(item[0]) + '=' + enc(item[1]);
	                });
	            } else {
	                parts = [];
	                for (var k in obj) {
	                    if (obj.hasOwnProperty(k)) {
	                        parts.push(enc(k) + '=' + enc(obj[k]));
	                    }
	                }
	            }
	            return parts.join('&');
	        }
	    },

	    urlize: function(str, length, nofollow) {
	        if (isNaN(length)) length = Infinity;

	        var noFollowAttr = (nofollow === true ? ' rel="nofollow"' : '');

	        // For the jinja regexp, see
	        // https://github.com/mitsuhiko/jinja2/blob/f15b814dcba6aa12bc74d1f7d0c881d55f7126be/jinja2/utils.py#L20-L23
	        var puncRE = /^(?:\(|<|&lt;)?(.*?)(?:\.|,|\)|\n|&gt;)?$/;
	        // from http://blog.gerv.net/2011/05/html5_email_address_regexp/
	        var emailRE = /^[\w.!#$%&'*+\-\/=?\^`{|}~]+@[a-z\d\-]+(\.[a-z\d\-]+)+$/i;
	        var httpHttpsRE = /^https?:\/\/.*$/;
	        var wwwRE = /^www\./;
	        var tldRE = /\.(?:org|net|com)(?:\:|\/|$)/;

	        var words = str.split(/(\s+)/).filter(function(word) {
	          // If the word has no length, bail. This can happen for str with
	          // trailing whitespace.
	          return word && word.length;
	        }).map(function(word) {
	          var matches = word.match(puncRE);
	          var possibleUrl = matches && matches[1] || word;

	          // url that starts with http or https
	          if (httpHttpsRE.test(possibleUrl))
	            return '<a href="' + possibleUrl + '"' + noFollowAttr + '>' + possibleUrl.substr(0, length) + '</a>';

	          // url that starts with www.
	          if (wwwRE.test(possibleUrl))
	            return '<a href="http://' + possibleUrl + '"' + noFollowAttr + '>' + possibleUrl.substr(0, length) + '</a>';

	          // an email address of the form username@domain.tld
	          if (emailRE.test(possibleUrl))
	            return '<a href="mailto:' + possibleUrl + '">' + possibleUrl + '</a>';

	          // url that ends in .com, .org or .net that is not an email address
	          if (tldRE.test(possibleUrl))
	            return '<a href="http://' + possibleUrl + '"' + noFollowAttr + '>' + possibleUrl.substr(0, length) + '</a>';

	          return word;

	        });

	        return words.join('');
	    },

	    wordcount: function(str) {
	        str = normalize(str, '');
	        var words = (str) ? str.match(/\w+/g) : null;
	        return (words) ? words.length : null;
	    },

	    'float': function(val, def) {
	        var res = parseFloat(val);
	        return isNaN(res) ? def : res;
	    },

	    'int': function(val, def) {
	        var res = parseInt(val, 10);
	        return isNaN(res) ? def : res;
	    }
	};

	// Aliases
	filters.d = filters['default'];
	filters.e = filters.escape;

	module.exports = filters;


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Loader = __webpack_require__(15);
	var PrecompiledLoader = __webpack_require__(16);

	var WebLoader = Loader.extend({
	    init: function(baseURL, opts) {
	        this.baseURL = baseURL || '.';
	        opts = opts || {};

	        // By default, the cache is turned off because there's no way
	        // to "watch" templates over HTTP, so they are re-downloaded
	        // and compiled each time. (Remember, PRECOMPILE YOUR
	        // TEMPLATES in production!)
	        this.useCache = !!opts.useCache;

	        // We default `async` to false so that the simple synchronous
	        // API can be used when you aren't doing anything async in
	        // your templates (which is most of the time). This performs a
	        // sync ajax request, but that's ok because it should *only*
	        // happen in development. PRECOMPILE YOUR TEMPLATES.
	        this.async = !!opts.async;
	    },

	    resolve: function(from, to) { // jshint ignore:line
	        throw new Error('relative templates not support in the browser yet');
	    },

	    getSource: function(name, cb) {
	        var useCache = this.useCache;
	        var result;
	        this.fetch(this.baseURL + '/' + name, function(err, src) {
	            if(err) {
	                if(cb) {
	                    cb(err.content);
	                } else {
	                    if (err.status === 404) {
	                      result = null;
	                    } else {
	                      throw err.content;
	                    }
	                }
	            }
	            else {
	                result = { src: src,
	                           path: name,
	                           noCache: !useCache };
	                if(cb) {
	                    cb(null, result);
	                }
	            }
	        });

	        // if this WebLoader isn't running asynchronously, the
	        // fetch above would actually run sync and we'll have a
	        // result here
	        return result;
	    },

	    fetch: function(url, cb) {
	        // Only in the browser please
	        var ajax;
	        var loading = true;

	        if(window.XMLHttpRequest) { // Mozilla, Safari, ...
	            ajax = new XMLHttpRequest();
	        }
	        else if(window.ActiveXObject) { // IE 8 and older
	            /* global ActiveXObject */
	            ajax = new ActiveXObject('Microsoft.XMLHTTP');
	        }

	        ajax.onreadystatechange = function() {
	            if(ajax.readyState === 4 && loading) {
	                loading = false;
	                if(ajax.status === 0 || ajax.status === 200) {
	                    cb(null, ajax.responseText);
	                }
	                else {
	                    cb({ status: ajax.status, content: ajax.responseText });
	                }
	            }
	        };

	        url += (url.indexOf('?') === -1 ? '?' : '&') + 's=' +
	               (new Date().getTime());

	        ajax.open('GET', url, this.async);
	        ajax.send();
	    }
	});

	module.exports = {
	    WebLoader: WebLoader,
	    PrecompiledLoader: PrecompiledLoader
	};


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var path = __webpack_require__(3);
	var Obj = __webpack_require__(6);
	var lib = __webpack_require__(1);

	var Loader = Obj.extend({
	    on: function(name, func) {
	        this.listeners = this.listeners || {};
	        this.listeners[name] = this.listeners[name] || [];
	        this.listeners[name].push(func);
	    },

	    emit: function(name /*, arg1, arg2, ...*/) {
	        var args = Array.prototype.slice.call(arguments, 1);

	        if(this.listeners && this.listeners[name]) {
	            lib.each(this.listeners[name], function(listener) {
	                listener.apply(null, args);
	            });
	        }
	    },

	    resolve: function(from, to) {
	        return path.resolve(path.dirname(from), to);
	    },

	    isRelative: function(filename) {
	        return (filename.indexOf('./') === 0 || filename.indexOf('../') === 0);
	    }
	});

	module.exports = Loader;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Loader = __webpack_require__(15);

	var PrecompiledLoader = Loader.extend({
	    init: function(compiledTemplates) {
	        this.precompiled = compiledTemplates || {};
	    },

	    getSource: function(name) {
	        if (this.precompiled[name]) {
	            return {
	                src: { type: 'code',
	                       obj: this.precompiled[name] },
	                path: name
	            };
	        }
	        return null;
	    }
	});

	module.exports = PrecompiledLoader;


/***/ },
/* 17 */
/***/ function(module, exports) {

	'use strict';

	function cycler(items) {
	    var index = -1;

	    return {
	        current: null,
	        reset: function() {
	            index = -1;
	            this.current = null;
	        },

	        next: function() {
	            index++;
	            if(index >= items.length) {
	                index = 0;
	            }

	            this.current = items[index];
	            return this.current;
	        },
	    };

	}

	function joiner(sep) {
	    sep = sep || ',';
	    var first = true;

	    return function() {
	        var val = first ? '' : sep;
	        first = false;
	        return val;
	    };
	}

	// Making this a function instead so it returns a new object
	// each time it's called. That way, if something like an environment
	// uses it, they will each have their own copy.
	function globals() {
	    return {
	        range: function(start, stop, step) {
	            if(typeof stop === 'undefined') {
	                stop = start;
	                start = 0;
	                step = 1;
	            }
	            else if(!step) {
	                step = 1;
	            }

	            var arr = [];
	            var i;
	            if (step > 0) {
	                for (i=start; i<stop; i+=step) {
	                    arr.push(i);
	                }
	            } else {
	                for (i=start; i>stop; i+=step) {
	                    arr.push(i);
	                }
	            }
	            return arr;
	        },

	        // lipsum: function(n, html, min, max) {
	        // },

	        cycler: function() {
	            return cycler(Array.prototype.slice.call(arguments));
	        },

	        joiner: function(sep) {
	            return joiner(sep);
	        }
	    };
	}

	module.exports = globals;


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(setImmediate, process) {// MIT license (by Elan Shanker).
	(function(globals) {
	  'use strict';

	  var executeSync = function(){
	    var args = Array.prototype.slice.call(arguments);
	    if (typeof args[0] === 'function'){
	      args[0].apply(null, args.splice(1));
	    }
	  };

	  var executeAsync = function(fn){
	    if (typeof setImmediate === 'function') {
	      setImmediate(fn);
	    } else if (typeof process !== 'undefined' && process.nextTick) {
	      process.nextTick(fn);
	    } else {
	      setTimeout(fn, 0);
	    }
	  };

	  var makeIterator = function (tasks) {
	    var makeCallback = function (index) {
	      var fn = function () {
	        if (tasks.length) {
	          tasks[index].apply(null, arguments);
	        }
	        return fn.next();
	      };
	      fn.next = function () {
	        return (index < tasks.length - 1) ? makeCallback(index + 1): null;
	      };
	      return fn;
	    };
	    return makeCallback(0);
	  };
	  
	  var _isArray = Array.isArray || function(maybeArray){
	    return Object.prototype.toString.call(maybeArray) === '[object Array]';
	  };

	  var waterfall = function (tasks, callback, forceAsync) {
	    var nextTick = forceAsync ? executeAsync : executeSync;
	    callback = callback || function () {};
	    if (!_isArray(tasks)) {
	      var err = new Error('First argument to waterfall must be an array of functions');
	      return callback(err);
	    }
	    if (!tasks.length) {
	      return callback();
	    }
	    var wrapIterator = function (iterator) {
	      return function (err) {
	        if (err) {
	          callback.apply(null, arguments);
	          callback = function () {};
	        } else {
	          var args = Array.prototype.slice.call(arguments, 1);
	          var next = iterator.next();
	          if (next) {
	            args.push(wrapIterator(next));
	          } else {
	            args.push(callback);
	          }
	          nextTick(function () {
	            iterator.apply(null, args);
	          });
	        }
	      };
	    };
	    wrapIterator(makeIterator(tasks))();
	  };

	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return waterfall;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); // RequireJS
	  } else if (typeof module !== 'undefined' && module.exports) {
	    module.exports = waterfall; // CommonJS
	  } else {
	    globals.waterfall = waterfall; // <script>
	  }
	})(this);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19).setImmediate, __webpack_require__(3)))

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(20).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(19).setImmediate, __webpack_require__(19).clearImmediate))

/***/ },
/* 20 */
/***/ function(module, exports) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 21 */
/***/ function(module, exports) {

	function installCompat() {
	  'use strict';

	  // This must be called like `nunjucks.installCompat` so that `this`
	  // references the nunjucks instance
	  var runtime = this.runtime; // jshint ignore:line
	  var lib = this.lib; // jshint ignore:line

	  var orig_contextOrFrameLookup = runtime.contextOrFrameLookup;
	  runtime.contextOrFrameLookup = function(context, frame, key) {
	    var val = orig_contextOrFrameLookup.apply(this, arguments);
	    if (val === undefined) {
	      switch (key) {
	      case 'True':
	        return true;
	      case 'False':
	        return false;
	      case 'None':
	        return null;
	      }
	    }

	    return val;
	  };

	  var orig_memberLookup = runtime.memberLookup;
	  var ARRAY_MEMBERS = {
	    pop: function(index) {
	      if (index === undefined) {
	        return this.pop();
	      }
	      if (index >= this.length || index < 0) {
	        throw new Error('KeyError');
	      }
	      return this.splice(index, 1);
	    },
	    append: function(element) {
	        return this.push(element);
	    },
	    remove: function(element) {
	      for (var i = 0; i < this.length; i++) {
	        if (this[i] === element) {
	          return this.splice(i, 1);
	        }
	      }
	      throw new Error('ValueError');
	    },
	    count: function(element) {
	      var count = 0;
	      for (var i = 0; i < this.length; i++) {
	        if (this[i] === element) {
	          count++;
	        }
	      }
	      return count;
	    },
	    index: function(element) {
	      var i;
	      if ((i = this.indexOf(element)) === -1) {
	        throw new Error('ValueError');
	      }
	      return i;
	    },
	    find: function(element) {
	      return this.indexOf(element);
	    },
	    insert: function(index, elem) {
	      return this.splice(index, 0, elem);
	    }
	  };
	  var OBJECT_MEMBERS = {
	    items: function() {
	      var ret = [];
	      for(var k in this) {
	        ret.push([k, this[k]]);
	      }
	      return ret;
	    },
	    values: function() {
	      var ret = [];
	      for(var k in this) {
	        ret.push(this[k]);
	      }
	      return ret;
	    },
	    keys: function() {
	      var ret = [];
	      for(var k in this) {
	        ret.push(k);
	      }
	      return ret;
	    },
	    get: function(key, def) {
	      var output = this[key];
	      if (output === undefined) {
	        output = def;
	      }
	      return output;
	    },
	    has_key: function(key) {
	      return this.hasOwnProperty(key);
	    },
	    pop: function(key, def) {
	      var output = this[key];
	      if (output === undefined && def !== undefined) {
	        output = def;
	      } else if (output === undefined) {
	        throw new Error('KeyError');
	      } else {
	        delete this[key];
	      }
	      return output;
	    },
	    popitem: function() {
	      for (var k in this) {
	        // Return the first object pair.
	        var val = this[k];
	        delete this[k];
	        return [k, val];
	      }
	      throw new Error('KeyError');
	    },
	    setdefault: function(key, def) {
	      if (key in this) {
	        return this[key];
	      }
	      if (def === undefined) {
	        def = null;
	      }
	      return this[key] = def;
	    },
	    update: function(kwargs) {
	      for (var k in kwargs) {
	        this[k] = kwargs[k];
	      }
	      return null;  // Always returns None
	    }
	  };
	  OBJECT_MEMBERS.iteritems = OBJECT_MEMBERS.items;
	  OBJECT_MEMBERS.itervalues = OBJECT_MEMBERS.values;
	  OBJECT_MEMBERS.iterkeys = OBJECT_MEMBERS.keys;
	  runtime.memberLookup = function(obj, val, autoescape) { // jshint ignore:line
	    obj = obj || {};

	    // If the object is an object, return any of the methods that Python would
	    // otherwise provide.
	    if (lib.isArray(obj) && ARRAY_MEMBERS.hasOwnProperty(val)) {
	      return function() {return ARRAY_MEMBERS[val].apply(obj, arguments);};
	    }

	    if (lib.isObject(obj) && OBJECT_MEMBERS.hasOwnProperty(val)) {
	      return function() {return OBJECT_MEMBERS[val].apply(obj, arguments);};
	    }

	    return orig_memberLookup.apply(this, arguments);
	  };
	}

	module.exports = installCompat;


/***/ }
/******/ ])
});
;
define('organizator/Component/Translator/Translator',[],function (){
    class Organizator_Translator {
        constructor(options) {
            options = Object.assign({}, options);
            
            this.availableLocales = options.availableLocales;
            this.defaultLocale = this.availableLocales.indexOf(options.defaultLocale) > -1 ? options.defaultLocale : undefined;
            this.locale = this.availableLocales.indexOf(options.locale) > -1 ? options.locale : options.defaultLocale;
            
            this.strings = {};
            for(let locale of this.availableLocales){
                this.strings[locale] = {};
            }
        }
        
        setLocale(locale){
            this.locale = locale;
        }
        
        translate(id, parameters){
            let string = this.strings[this.locale][id] || this.strings[this.defaultLocale][id] || id;
            
            return string;
        }
        
        addString(locale, id, string){
            this.strings[locale][id] = string;
        }
        
        addStrings(locale, strings){
            Object.assign(this.strings[locale], strings);
        }
        
        getString(id, locale = this.locale){
            return this.strings[locale][id] || this.strings[this.defaultLocale][id] || id;
        }
        
        addDocument(document, type, locale){
            switch(type){
                case 'xliff':
                case 'xlf':
                    this.addXliffDocument(document);
                    break;
            }
        }
        
        addXliffDocument(document){
            let files = document.querySelectorAll('file');
            
            for(let file of files){
                let sourceLanguage = file.getAttribute('source-language'),
                    targetLanguage = file.getAttribute('target-language'),
                    body = file.querySelector('body'),
                    transUnits = body.querySelectorAll('trans-unit');
            
                for(let transUnit of transUnits){
                    let sourceString = transUnit.querySelector('source').innerHTML;
                    let target = transUnit.querySelector('target');
                    let targetString = target ? target.innerHTML : sourceString;
                    
                    this.addString(targetLanguage || sourceLanguage, sourceString, targetString);
                }
            }
        }
    }
    
    return Organizator_Translator;
});
(function(root,factory){if(typeof define==="function"&&define.amd){define('lokijs/build/lokijs.min',[],factory)}else if(typeof exports==="object"){module.exports=factory()}else{root.loki=factory()}})(this,function(){return function(){"use strict";var hasOwnProperty=Object.prototype.hasOwnProperty;var Utils={copyProperties:function(src,dest){var prop;for(prop in src){dest[prop]=src[prop]}},resolveTransformObject:function(subObj,params,depth){var prop,pname;if(typeof depth!=="number"){depth=0}if(++depth>=10)return subObj;for(prop in subObj){if(typeof subObj[prop]==="string"&&subObj[prop].indexOf("[%lktxp]")===0){pname=subObj[prop].substring(8);if(params.hasOwnProperty(pname)){subObj[prop]=params[pname]}}else if(typeof subObj[prop]==="object"){subObj[prop]=Utils.resolveTransformObject(subObj[prop],params,depth)}}return subObj},resolveTransformParams:function(transform,params){var idx,clonedStep,resolvedTransform=[];if(typeof params==="undefined")return transform;for(idx=0;idx<transform.length;idx++){clonedStep=clone(transform[idx],"shallow-recurse-objects");resolvedTransform.push(Utils.resolveTransformObject(clonedStep,params))}return resolvedTransform},getIn:function(object,path,usingDotNotation){if(object==null){return undefined}if(!usingDotNotation){return object[path]}if(typeof path==="string"){path=path.split(".")}if(!Array.isArray(path)){throw new Error("path must be a string or array. Found "+typeof path)}var index=0,length=path.length;while(object!=null&&index<length){object=object[path[index++]]}return index&&index==length?object:undefined}};var Comparators={aeq:aeqHelper,lt:ltHelper,gt:gtHelper};function aeqHelper(prop1,prop2){var cv1,cv2,t1,t2;if(prop1===prop2)return true;if(!prop1||!prop2||prop1===true||prop2===true||prop1!==prop1||prop2!==prop2){switch(prop1){case undefined:t1=1;break;case null:t1=1;break;case false:t1=3;break;case true:t1=4;break;case"":t1=5;break;default:t1=prop1===prop1?9:0;break}switch(prop2){case undefined:t2=1;break;case null:t2=1;break;case false:t2=3;break;case true:t2=4;break;case"":t2=5;break;default:t2=prop2===prop2?9:0;break}if(t1!==9||t2!==9){return t1===t2}}cv1=Number(prop1);cv2=Number(prop2);if(cv1===cv1||cv2===cv2){return cv1===cv2}cv1=prop1.toString();cv2=prop2.toString();return cv1==cv2}function ltHelper(prop1,prop2,equal){var cv1,cv2,t1,t2;if(!prop1||!prop2||prop1===true||prop2===true||prop1!==prop1||prop2!==prop2){switch(prop1){case undefined:t1=1;break;case null:t1=1;break;case false:t1=3;break;case true:t1=4;break;case"":t1=5;break;default:t1=prop1===prop1?9:0;break}switch(prop2){case undefined:t2=1;break;case null:t2=1;break;case false:t2=3;break;case true:t2=4;break;case"":t2=5;break;default:t2=prop2===prop2?9:0;break}if(t1!==9||t2!==9){return t1===t2?equal:t1<t2}}cv1=Number(prop1);cv2=Number(prop2);if(cv1===cv1&&cv2===cv2){if(cv1<cv2)return true;if(cv1>cv2)return false;return equal}if(cv1===cv1&&cv2!==cv2){return true}if(cv2===cv2&&cv1!==cv1){return false}if(prop1<prop2)return true;if(prop1>prop2)return false;if(prop1==prop2)return equal;cv1=prop1.toString();cv2=prop2.toString();if(cv1<cv2){return true}if(cv1==cv2){return equal}return false}function gtHelper(prop1,prop2,equal){var cv1,cv2,t1,t2;if(!prop1||!prop2||prop1===true||prop2===true||prop1!==prop1||prop2!==prop2){switch(prop1){case undefined:t1=1;break;case null:t1=1;break;case false:t1=3;break;case true:t1=4;break;case"":t1=5;break;default:t1=prop1===prop1?9:0;break}switch(prop2){case undefined:t2=1;break;case null:t2=1;break;case false:t2=3;break;case true:t2=4;break;case"":t2=5;break;default:t2=prop2===prop2?9:0;break}if(t1!==9||t2!==9){return t1===t2?equal:t1>t2}}cv1=Number(prop1);cv2=Number(prop2);if(cv1===cv1&&cv2===cv2){if(cv1>cv2)return true;if(cv1<cv2)return false;return equal}if(cv1===cv1&&cv2!==cv2){return false}if(cv2===cv2&&cv1!==cv1){return true}if(prop1>prop2)return true;if(prop1<prop2)return false;if(prop1==prop2)return equal;cv1=prop1.toString();cv2=prop2.toString();if(cv1>cv2){return true}if(cv1==cv2){return equal}return false}function sortHelper(prop1,prop2,desc){if(Comparators.aeq(prop1,prop2))return 0;if(Comparators.lt(prop1,prop2,false)){return desc?1:-1}if(Comparators.gt(prop1,prop2,false)){return desc?-1:1}return 0}function compoundeval(properties,obj1,obj2){var res=0;var prop,field,val1,val2,arr,path;for(var i=0,len=properties.length;i<len;i++){prop=properties[i];field=prop[0];if(~field.indexOf(".")){arr=field.split(".");val1=Utils.getIn(obj1,arr,true);val2=Utils.getIn(obj2,arr,true)}else{val1=obj1[field];val2=obj2[field]}res=sortHelper(val1,val2,prop[1]);if(res!==0){return res}}return 0}function dotSubScan(root,paths,fun,value,poffset){var pathOffset=poffset||0;var path=paths[pathOffset];var valueFound=false;var element;if(typeof root==="object"&&path in root){element=root[path]}if(pathOffset+1>=paths.length){valueFound=fun(element,value)}else if(Array.isArray(element)){for(var index=0,len=element.length;index<len;index+=1){valueFound=dotSubScan(element[index],paths,fun,value,pathOffset+1);if(valueFound===true){break}}}else{valueFound=dotSubScan(element,paths,fun,value,pathOffset+1)}return valueFound}function containsCheckFn(a){if(typeof a==="string"||Array.isArray(a)){return function(b){return a.indexOf(b)!==-1}}else if(typeof a==="object"&&a!==null){return function(b){return hasOwnProperty.call(a,b)}}return null}function doQueryOp(val,op){for(var p in op){if(hasOwnProperty.call(op,p)){return LokiOps[p](val,op[p])}}return false}var LokiOps={$eq:function(a,b){return a===b},$aeq:function(a,b){return a==b},$ne:function(a,b){if(b!==b){return a===a}return a!==b},$dteq:function(a,b){return Comparators.aeq(a,b)},$gt:function(a,b){return Comparators.gt(a,b,false)},$gte:function(a,b){return Comparators.gt(a,b,true)},$lt:function(a,b){return Comparators.lt(a,b,false)},$lte:function(a,b){return Comparators.lt(a,b,true)},$jgt:function(a,b){return a>b},$jgte:function(a,b){return a>=b},$jlt:function(a,b){return a<b},$jlte:function(a,b){return a<=b},$between:function(a,vals){if(a===undefined||a===null)return false;return Comparators.gt(a,vals[0],true)&&Comparators.lt(a,vals[1],true)},$jbetween:function(a,vals){if(a===undefined||a===null)return false;return a>=vals[0]&&a<=vals[1]},$in:function(a,b){return b.indexOf(a)!==-1},$nin:function(a,b){return b.indexOf(a)===-1},$keyin:function(a,b){return a in b},$nkeyin:function(a,b){return!(a in b)},$definedin:function(a,b){return b[a]!==undefined},$undefinedin:function(a,b){return b[a]===undefined},$regex:function(a,b){return b.test(a)},$containsString:function(a,b){return typeof a==="string"&&a.indexOf(b)!==-1},$containsNone:function(a,b){return!LokiOps.$containsAny(a,b)},$containsAny:function(a,b){var checkFn=containsCheckFn(a);if(checkFn!==null){return Array.isArray(b)?b.some(checkFn):checkFn(b)}return false},$contains:function(a,b){var checkFn=containsCheckFn(a);if(checkFn!==null){return Array.isArray(b)?b.every(checkFn):checkFn(b)}return false},$type:function(a,b){var type=typeof a;if(type==="object"){if(Array.isArray(a)){type="array"}else if(a instanceof Date){type="date"}}return typeof b!=="object"?type===b:doQueryOp(type,b)},$finite:function(a,b){return b===isFinite(a)},$size:function(a,b){if(Array.isArray(a)){return typeof b!=="object"?a.length===b:doQueryOp(a.length,b)}return false},$len:function(a,b){if(typeof a==="string"){return typeof b!=="object"?a.length===b:doQueryOp(a.length,b)}return false},$where:function(a,b){return b(a)===true},$not:function(a,b){return!doQueryOp(a,b)},$and:function(a,b){for(var idx=0,len=b.length;idx<len;idx+=1){if(!doQueryOp(a,b[idx])){return false}}return true},$or:function(a,b){for(var idx=0,len=b.length;idx<len;idx+=1){if(doQueryOp(a,b[idx])){return true}}return false},$exists:function(a,b){if(b){return a!==undefined}else{return a===undefined}}};var indexedOps={$eq:LokiOps.$eq,$aeq:true,$dteq:true,$gt:true,$gte:true,$lt:true,$lte:true,$in:true,$between:true};function clone(data,method){if(data===null||data===undefined){return null}var cloneMethod=method||"parse-stringify",cloned;switch(cloneMethod){case"parse-stringify":cloned=JSON.parse(JSON.stringify(data));break;case"jquery-extend-deep":cloned=jQuery.extend(true,{},data);break;case"shallow":cloned=Object.create(data.constructor.prototype);Object.keys(data).map(function(i){cloned[i]=data[i]});break;case"shallow-assign":cloned=Object.create(data.constructor.prototype);Object.assign(cloned,data);break;case"shallow-recurse-objects":cloned=clone(data,"shallow");var keys=Object.keys(data);keys.forEach(function(key){if(typeof data[key]==="object"&&data[key].constructor.name==="Object"){cloned[key]=clone(data[key],"shallow-recurse-objects")}else if(Array.isArray(data[key])){cloned[key]=cloneObjectArray(data[key],"shallow-recurse-objects")}});break;default:break}return cloned}function cloneObjectArray(objarray,method){if(method=="parse-stringify"){return clone(objarray,method)}var result=[];for(var i=0,len=objarray.length;i<len;i++){result[i]=clone(objarray[i],method)}return result}function localStorageAvailable(){try{return window&&window.localStorage!==undefined&&window.localStorage!==null}catch(e){return false}}function LokiEventEmitter(){}LokiEventEmitter.prototype.events={};LokiEventEmitter.prototype.asyncListeners=false;LokiEventEmitter.prototype.on=function(eventName,listener){var event;var self=this;if(Array.isArray(eventName)){eventName.forEach(function(currentEventName){self.on(currentEventName,listener)});return listener}event=this.events[eventName];if(!event){event=this.events[eventName]=[]}event.push(listener);return listener};LokiEventEmitter.prototype.emit=function(eventName){var self=this;var selfArgs=Array.prototype.slice.call(arguments,1);if(eventName&&this.events[eventName]){this.events[eventName].forEach(function(listener){if(self.asyncListeners){setTimeout(function(){listener.apply(self,selfArgs)},1)}else{listener.apply(self,selfArgs)}})}else{throw new Error("No event "+eventName+" defined")}};LokiEventEmitter.prototype.addListener=LokiEventEmitter.prototype.on;LokiEventEmitter.prototype.removeListener=function(eventName,listener){var self=this;if(Array.isArray(eventName)){eventName.forEach(function(currentEventName){self.removeListener(currentEventName,listener)});return}if(this.events[eventName]){var listeners=this.events[eventName];listeners.splice(listeners.indexOf(listener),1)}};function Loki(filename,options){this.filename=filename||"loki.db";this.collections=[];this.databaseVersion=1.5;this.engineVersion=1.5;this.autosave=false;this.autosaveInterval=5e3;this.autosaveHandle=null;this.throttledSaves=true;this.options={};this.persistenceMethod=null;this.persistenceAdapter=null;this.throttledSavePending=false;this.throttledCallbacks=[];this.verbose=options&&options.hasOwnProperty("verbose")?options.verbose:false;this.events={init:[],loaded:[],flushChanges:[],close:[],changes:[],warning:[]};var getENV=function(){if(typeof global!=="undefined"&&(global.android||global.NSObject)){return"NATIVESCRIPT"}if(typeof window==="undefined"){return"NODEJS"}if(typeof global!=="undefined"&&global.window&&typeof process!=="undefined"){return"NODEJS"}if(typeof document!=="undefined"){if(document.URL.indexOf("http://")===-1&&document.URL.indexOf("https://")===-1){return"CORDOVA"}return"BROWSER"}return"CORDOVA"};if(options&&options.hasOwnProperty("env")){this.ENV=options.env}else{this.ENV=getENV()}if(this.ENV==="undefined"){this.ENV="NODEJS"}this.configureOptions(options,true);this.on("init",this.clearChanges)}Loki.prototype=new LokiEventEmitter;Loki.prototype.constructor=Loki;Loki.prototype.getIndexedAdapter=function(){var adapter;if(typeof require==="function"){adapter=require("./loki-indexed-adapter.js")}return adapter};Loki.prototype.configureOptions=function(options,initialConfig){var defaultPersistence={NODEJS:"fs",BROWSER:"localStorage",CORDOVA:"localStorage",MEMORY:"memory"},persistenceMethods={fs:LokiFsAdapter,localStorage:LokiLocalStorageAdapter,memory:LokiMemoryAdapter};this.options={};this.persistenceMethod=null;this.persistenceAdapter=null;if(typeof options!=="undefined"){this.options=options;if(this.options.hasOwnProperty("persistenceMethod")){if(typeof persistenceMethods[options.persistenceMethod]=="function"){this.persistenceMethod=options.persistenceMethod;this.persistenceAdapter=new persistenceMethods[options.persistenceMethod]}}if(this.options.hasOwnProperty("adapter")){this.persistenceMethod="adapter";this.persistenceAdapter=options.adapter;this.options.adapter=null}if(options.autoload&&initialConfig){var self=this;setTimeout(function(){self.loadDatabase(options,options.autoloadCallback)},1)}if(this.options.hasOwnProperty("autosaveInterval")){this.autosaveDisable();this.autosaveInterval=parseInt(this.options.autosaveInterval,10)}if(this.options.hasOwnProperty("autosave")&&this.options.autosave){this.autosaveDisable();this.autosave=true;if(this.options.hasOwnProperty("autosaveCallback")){this.autosaveEnable(options,options.autosaveCallback)}else{this.autosaveEnable()}}if(this.options.hasOwnProperty("throttledSaves")){this.throttledSaves=this.options.throttledSaves}}if(!this.options.hasOwnProperty("serializationMethod")){this.options.serializationMethod="normal"}if(!this.options.hasOwnProperty("destructureDelimiter")){this.options.destructureDelimiter="$<\n"}if(this.persistenceAdapter===null){this.persistenceMethod=defaultPersistence[this.ENV];if(this.persistenceMethod){this.persistenceAdapter=new persistenceMethods[this.persistenceMethod]}}};Loki.prototype.copy=function(options){var databaseCopy=new Loki(this.filename,{env:"NA"});var clen,idx;options=options||{};databaseCopy.loadJSONObject(this,{retainDirtyFlags:true});if(options.hasOwnProperty("removeNonSerializable")&&options.removeNonSerializable===true){databaseCopy.autosaveHandle=null;databaseCopy.persistenceAdapter=null;clen=databaseCopy.collections.length;for(idx=0;idx<clen;idx++){databaseCopy.collections[idx].constraints=null;databaseCopy.collections[idx].ttl=null}}return databaseCopy};Loki.prototype.addCollection=function(name,options){var i,len=this.collections.length;if(options&&options.disableMeta===true){if(options.disableChangesApi===false){throw new Error("disableMeta option cannot be passed as true when disableChangesApi is passed as false")}if(options.disableDeltaChangesApi===false){throw new Error("disableMeta option cannot be passed as true when disableDeltaChangesApi is passed as false")}if(typeof options.ttl==="number"&&options.ttl>0){throw new Error("disableMeta option cannot be passed as true when ttl is enabled")}}for(i=0;i<len;i+=1){if(this.collections[i].name===name){return this.collections[i]}}var collection=new Collection(name,options);this.collections.push(collection);if(this.verbose)collection.console=console;return collection};Loki.prototype.loadCollection=function(collection){if(!collection.name){throw new Error("Collection must have a name property to be loaded")}this.collections.push(collection)};Loki.prototype.getCollection=function(collectionName){var i,len=this.collections.length;for(i=0;i<len;i+=1){if(this.collections[i].name===collectionName){return this.collections[i]}}this.emit("warning","collection "+collectionName+" not found");return null};Loki.prototype.renameCollection=function(oldName,newName){var c=this.getCollection(oldName);if(c){c.name=newName}return c};Loki.prototype.listCollections=function(){var i=this.collections.length,colls=[];while(i--){colls.push({name:this.collections[i].name,type:this.collections[i].objType,count:this.collections[i].data.length})}return colls};Loki.prototype.removeCollection=function(collectionName){var i,len=this.collections.length;for(i=0;i<len;i+=1){if(this.collections[i].name===collectionName){var tmpcol=new Collection(collectionName,{});var curcol=this.collections[i];for(var prop in curcol){if(curcol.hasOwnProperty(prop)&&tmpcol.hasOwnProperty(prop)){curcol[prop]=tmpcol[prop]}}this.collections.splice(i,1);return}}};Loki.prototype.getName=function(){return this.name};Loki.prototype.serializeReplacer=function(key,value){switch(key){case"autosaveHandle":case"persistenceAdapter":case"constraints":case"ttl":return null;case"throttledSavePending":case"throttledCallbacks":return undefined;default:return value}};Loki.prototype.serialize=function(options){options=options||{};if(!options.hasOwnProperty("serializationMethod")){options.serializationMethod=this.options.serializationMethod}switch(options.serializationMethod){case"normal":return JSON.stringify(this,this.serializeReplacer);case"pretty":return JSON.stringify(this,this.serializeReplacer,2);case"destructured":return this.serializeDestructured();default:return JSON.stringify(this,this.serializeReplacer)}};Loki.prototype.toJson=Loki.prototype.serialize;Loki.prototype.serializeDestructured=function(options){var idx,sidx,result,resultlen;var reconstruct=[];var dbcopy;options=options||{};if(!options.hasOwnProperty("partitioned")){options.partitioned=false}if(!options.hasOwnProperty("delimited")){options.delimited=true}if(!options.hasOwnProperty("delimiter")){options.delimiter=this.options.destructureDelimiter}if(options.partitioned===true&&options.hasOwnProperty("partition")&&options.partition>=0){return this.serializeCollection({delimited:options.delimited,delimiter:options.delimiter,collectionIndex:options.partition})}dbcopy=new Loki(this.filename);dbcopy.loadJSONObject(this);for(idx=0;idx<dbcopy.collections.length;idx++){dbcopy.collections[idx].data=[]}if(options.partitioned===true&&options.partition===-1){return dbcopy.serialize({serializationMethod:"normal"})}reconstruct.push(dbcopy.serialize({serializationMethod:"normal"}));dbcopy=null;for(idx=0;idx<this.collections.length;idx++){result=this.serializeCollection({delimited:options.delimited,delimiter:options.delimiter,collectionIndex:idx});if(options.partitioned===false&&options.delimited===false){if(!Array.isArray(result)){throw new Error("a nondelimited, non partitioned collection serialization did not return an expected array")}resultlen=result.length;for(sidx=0;sidx<resultlen;sidx++){reconstruct.push(result[sidx]);result[sidx]=null}reconstruct.push("")}else{reconstruct.push(result)}}if(options.partitioned){if(options.delimited){return reconstruct}else{return reconstruct}}else{if(options.delimited){reconstruct.push("");return reconstruct.join(options.delimiter)}else{reconstruct.push("");return reconstruct}}reconstruct.push("");return reconstruct.join(delim)};Loki.prototype.serializeCollection=function(options){var doccount,docidx,resultlines=[];options=options||{};if(!options.hasOwnProperty("delimited")){options.delimited=true}if(!options.hasOwnProperty("collectionIndex")){throw new Error("serializeCollection called without 'collectionIndex' option")}doccount=this.collections[options.collectionIndex].data.length;resultlines=[];for(docidx=0;docidx<doccount;docidx++){resultlines.push(JSON.stringify(this.collections[options.collectionIndex].data[docidx]))}if(options.delimited){resultlines.push("");return resultlines.join(options.delimiter)}else{return resultlines}};Loki.prototype.deserializeDestructured=function(destructuredSource,options){var workarray=[];var len,cdb;var idx,collIndex=0,collCount,lineIndex=1,done=false;var currLine,currObject;options=options||{};if(!options.hasOwnProperty("partitioned")){options.partitioned=false}if(!options.hasOwnProperty("delimited")){options.delimited=true}if(!options.hasOwnProperty("delimiter")){options.delimiter=this.options.destructureDelimiter}if(options.partitioned){if(options.hasOwnProperty("partition")){if(options.partition===-1){cdb=JSON.parse(destructuredSource[0]);return cdb}return this.deserializeCollection(destructuredSource[options.partition+1],options)}cdb=JSON.parse(destructuredSource[0]);collCount=cdb.collections.length;for(collIndex=0;collIndex<collCount;collIndex++){cdb.collections[collIndex].data=this.deserializeCollection(destructuredSource[collIndex+1],options)}return cdb}if(options.delimited){workarray=destructuredSource.split(options.delimiter);destructuredSource=null;len=workarray.length;if(len===0){return null}}else{workarray=destructuredSource}cdb=JSON.parse(workarray[0]);collCount=cdb.collections.length;workarray[0]=null;while(!done){currLine=workarray[lineIndex];if(workarray[lineIndex]===""){if(++collIndex>collCount){done=true}}else{currObject=JSON.parse(workarray[lineIndex]);cdb.collections[collIndex].data.push(currObject)}workarray[lineIndex++]=null}return cdb};Loki.prototype.deserializeCollection=function(destructuredSource,options){var workarray=[];var idx,len;options=options||{};if(!options.hasOwnProperty("partitioned")){options.partitioned=false}if(!options.hasOwnProperty("delimited")){options.delimited=true}if(!options.hasOwnProperty("delimiter")){options.delimiter=this.options.destructureDelimiter}if(options.delimited){workarray=destructuredSource.split(options.delimiter);workarray.pop()}else{workarray=destructuredSource}len=workarray.length;for(idx=0;idx<len;idx++){workarray[idx]=JSON.parse(workarray[idx])}return workarray};Loki.prototype.loadJSON=function(serializedDb,options){var dbObject;if(serializedDb.length===0){dbObject={}}else{switch(this.options.serializationMethod){case"normal":case"pretty":dbObject=JSON.parse(serializedDb);break;case"destructured":dbObject=this.deserializeDestructured(serializedDb);break;default:dbObject=JSON.parse(serializedDb);break}}this.loadJSONObject(dbObject,options)};Loki.prototype.loadJSONObject=function(dbObject,options){var i=0,len=dbObject.collections?dbObject.collections.length:0,coll,copyColl,clen,j,loader,collObj;this.name=dbObject.name;if(dbObject.hasOwnProperty("throttledSaves")&&options&&!options.hasOwnProperty("throttledSaves")){this.throttledSaves=dbObject.throttledSaves}this.collections=[];function makeLoader(coll){var collOptions=options[coll.name];var inflater;if(collOptions.proto){inflater=collOptions.inflate||Utils.copyProperties;return function(data){var collObj=new collOptions.proto;inflater(data,collObj);return collObj}}return collOptions.inflate}for(i;i<len;i+=1){coll=dbObject.collections[i];copyColl=this.addCollection(coll.name,{disableChangesApi:coll.disableChangesApi,disableDeltaChangesApi:coll.disableDeltaChangesApi,disableMeta:coll.disableMeta});copyColl.adaptiveBinaryIndices=coll.hasOwnProperty("adaptiveBinaryIndices")?coll.adaptiveBinaryIndices===true:false;copyColl.transactional=coll.transactional;copyColl.asyncListeners=coll.asyncListeners;copyColl.cloneObjects=coll.cloneObjects;copyColl.cloneMethod=coll.cloneMethod||"parse-stringify";copyColl.autoupdate=coll.autoupdate;copyColl.changes=coll.changes;if(options&&options.retainDirtyFlags===true){copyColl.dirty=coll.dirty}else{copyColl.dirty=false}clen=coll.data.length;j=0;if(options&&options.hasOwnProperty(coll.name)){loader=makeLoader(coll);for(j;j<clen;j++){collObj=loader(coll.data[j]);copyColl.data[j]=collObj;copyColl.addAutoUpdateObserver(collObj)}}else{for(j;j<clen;j++){copyColl.data[j]=coll.data[j];copyColl.addAutoUpdateObserver(copyColl.data[j])}}copyColl.maxId=typeof coll.maxId==="undefined"?0:coll.maxId;copyColl.idIndex=coll.idIndex;if(typeof coll.binaryIndices!=="undefined"){copyColl.binaryIndices=coll.binaryIndices}if(typeof coll.transforms!=="undefined"){copyColl.transforms=coll.transforms}copyColl.ensureId();copyColl.uniqueNames=[];if(coll.hasOwnProperty("uniqueNames")){copyColl.uniqueNames=coll.uniqueNames;for(j=0;j<copyColl.uniqueNames.length;j++){copyColl.ensureUniqueIndex(copyColl.uniqueNames[j])}}if(typeof coll.DynamicViews==="undefined")continue;for(var idx=0;idx<coll.DynamicViews.length;idx++){var colldv=coll.DynamicViews[idx];var dv=copyColl.addDynamicView(colldv.name,colldv.options);dv.resultdata=colldv.resultdata;dv.resultsdirty=colldv.resultsdirty;dv.filterPipeline=colldv.filterPipeline;dv.sortCriteria=colldv.sortCriteria;dv.sortFunction=null;dv.sortDirty=colldv.sortDirty;dv.resultset.filteredrows=colldv.resultset.filteredrows;dv.resultset.filterInitialized=colldv.resultset.filterInitialized;dv.rematerialize({removeWhereFilters:true})}if(dbObject.databaseVersion<1.5){copyColl.ensureAllIndexes(true);copyColl.dirty=true}}};Loki.prototype.close=function(callback){if(this.autosave){this.autosaveDisable();if(this.autosaveDirty()){this.saveDatabase(callback);callback=undefined}}if(callback){this.on("close",callback)}this.emit("close")};Loki.prototype.generateChangesNotification=function(arrayOfCollectionNames){function getCollName(coll){return coll.name}var changes=[],selectedCollections=arrayOfCollectionNames||this.collections.map(getCollName);this.collections.forEach(function(coll){if(selectedCollections.indexOf(getCollName(coll))!==-1){changes=changes.concat(coll.getChanges())}});return changes};Loki.prototype.serializeChanges=function(collectionNamesArray){return JSON.stringify(this.generateChangesNotification(collectionNamesArray))};Loki.prototype.clearChanges=function(){this.collections.forEach(function(coll){if(coll.flushChanges){coll.flushChanges()}})};function LokiMemoryAdapter(options){this.hashStore={};this.options=options||{};if(!this.options.hasOwnProperty("asyncResponses")){this.options.asyncResponses=false}if(!this.options.hasOwnProperty("asyncTimeout")){this.options.asyncTimeout=50}}LokiMemoryAdapter.prototype.loadDatabase=function(dbname,callback){var self=this;if(this.options.asyncResponses){setTimeout(function(){if(self.hashStore.hasOwnProperty(dbname)){callback(self.hashStore[dbname].value)}else{callback(null)}},this.options.asyncTimeout)}else{if(this.hashStore.hasOwnProperty(dbname)){callback(this.hashStore[dbname].value)}else{callback(null)}}};LokiMemoryAdapter.prototype.saveDatabase=function(dbname,dbstring,callback){var self=this;var saveCount;if(this.options.asyncResponses){setTimeout(function(){saveCount=self.hashStore.hasOwnProperty(dbname)?self.hashStore[dbname].savecount:0;self.hashStore[dbname]={savecount:saveCount+1,lastsave:new Date,value:dbstring};callback()},this.options.asyncTimeout)}else{saveCount=this.hashStore.hasOwnProperty(dbname)?this.hashStore[dbname].savecount:0;this.hashStore[dbname]={savecount:saveCount+1,lastsave:new Date,value:dbstring};callback()}};LokiMemoryAdapter.prototype.deleteDatabase=function(dbname,callback){if(this.hashStore.hasOwnProperty(dbname)){delete this.hashStore[dbname]}if(typeof callback==="function"){callback()}};function LokiPartitioningAdapter(adapter,options){this.mode="reference";this.adapter=null;this.options=options||{};this.dbref=null;this.dbname="";this.pageIterator={};if(adapter){if(adapter.mode==="reference"){throw new Error("LokiPartitioningAdapter cannot be instantiated with a reference mode adapter")}else{this.adapter=adapter}}else{throw new Error("LokiPartitioningAdapter requires a (non-reference mode) adapter on construction")}if(!this.options.hasOwnProperty("paging")){this.options.paging=false}if(!this.options.hasOwnProperty("pageSize")){this.options.pageSize=25*1024*1024}if(!this.options.hasOwnProperty("delimiter")){this.options.delimiter="$<\n"}}LokiPartitioningAdapter.prototype.loadDatabase=function(dbname,callback){var self=this;this.dbname=dbname;this.dbref=new Loki(dbname);this.adapter.loadDatabase(dbname,function(result){if(!result){callback(result);return}if(typeof result!=="string"){callback(new Error("LokiPartitioningAdapter received an unexpected response from inner adapter loadDatabase()"))}var db=JSON.parse(result);self.dbref.loadJSONObject(db);db=null;var clen=self.dbref.collections.length;if(self.dbref.collections.length===0){callback(self.dbref);return}self.pageIterator={collection:0,pageIndex:0};self.loadNextPartition(0,function(){callback(self.dbref)})})};LokiPartitioningAdapter.prototype.loadNextPartition=function(partition,callback){var keyname=this.dbname+"."+partition;var self=this;if(this.options.paging===true){this.pageIterator.pageIndex=0;this.loadNextPage(callback);return}this.adapter.loadDatabase(keyname,function(result){var data=self.dbref.deserializeCollection(result,{delimited:true,collectionIndex:partition});self.dbref.collections[partition].data=data;if(++partition<self.dbref.collections.length){self.loadNextPartition(partition,callback)}else{callback()}})};LokiPartitioningAdapter.prototype.loadNextPage=function(callback){var keyname=this.dbname+"."+this.pageIterator.collection+"."+this.pageIterator.pageIndex;var self=this;this.adapter.loadDatabase(keyname,function(result){var data=result.split(self.options.delimiter);result="";var dlen=data.length;var idx;var isLastPage=data[dlen-1]==="";if(isLastPage){data.pop();dlen=data.length;if(data[dlen-1]===""&&dlen===1){data.pop();dlen=data.length}}for(idx=0;idx<dlen;idx++){self.dbref.collections[self.pageIterator.collection].data.push(JSON.parse(data[idx]));data[idx]=null}data=[];if(isLastPage){if(++self.pageIterator.collection<self.dbref.collections.length){self.loadNextPartition(self.pageIterator.collection,callback)}else{callback()}}else{self.pageIterator.pageIndex++;self.loadNextPage(callback)}})};LokiPartitioningAdapter.prototype.exportDatabase=function(dbname,dbref,callback){var self=this;var idx,clen=dbref.collections.length;this.dbref=dbref;this.dbname=dbname;this.dirtyPartitions=[-1];for(idx=0;idx<clen;idx++){if(dbref.collections[idx].dirty){this.dirtyPartitions.push(idx)}}this.saveNextPartition(function(err){callback(err)})};LokiPartitioningAdapter.prototype.saveNextPartition=function(callback){var self=this;var partition=this.dirtyPartitions.shift();var keyname=this.dbname+(partition===-1?"":"."+partition);if(this.options.paging&&partition!==-1){this.pageIterator={collection:partition,docIndex:0,pageIndex:0};this.saveNextPage(function(err){if(self.dirtyPartitions.length===0){callback(err)}else{self.saveNextPartition(callback)}});return}var result=this.dbref.serializeDestructured({partitioned:true,delimited:true,partition:partition});this.adapter.saveDatabase(keyname,result,function(err){if(err){callback(err);return}if(self.dirtyPartitions.length===0){callback(null)}else{self.saveNextPartition(callback)}})};LokiPartitioningAdapter.prototype.saveNextPage=function(callback){var self=this;var coll=this.dbref.collections[this.pageIterator.collection];var keyname=this.dbname+"."+this.pageIterator.collection+"."+this.pageIterator.pageIndex;var pageLen=0,cdlen=coll.data.length,delimlen=this.options.delimiter.length;var serializedObject="",pageBuilder="";var doneWithPartition=false,doneWithPage=false;var pageSaveCallback=function(err){pageBuilder="";if(err){callback(err)}if(doneWithPartition){callback(null)}else{self.pageIterator.pageIndex++;self.saveNextPage(callback)}};if(coll.data.length===0){doneWithPartition=true}while(true){if(!doneWithPartition){serializedObject=JSON.stringify(coll.data[this.pageIterator.docIndex]);pageBuilder+=serializedObject;pageLen+=serializedObject.length;if(++this.pageIterator.docIndex>=cdlen)doneWithPartition=true}if(pageLen>=this.options.pageSize)doneWithPage=true;if(!doneWithPage||doneWithPartition){pageBuilder+=this.options.delimiter;pageLen+=delimlen}if(doneWithPartition||doneWithPage){this.adapter.saveDatabase(keyname,pageBuilder,pageSaveCallback);return}}};function LokiFsAdapter(){try{this.fs=require("fs")}catch(e){this.fs=null}}LokiFsAdapter.prototype.loadDatabase=function loadDatabase(dbname,callback){var self=this;this.fs.stat(dbname,function(err,stats){if(!err&&stats.isFile()){self.fs.readFile(dbname,{encoding:"utf8"},function readFileCallback(err,data){if(err){callback(new Error(err))}else{callback(data)}})}else{callback(null)}})};LokiFsAdapter.prototype.saveDatabase=function saveDatabase(dbname,dbstring,callback){var self=this;var tmpdbname=dbname+"~";this.fs.writeFile(tmpdbname,dbstring,function writeFileCallback(err){if(err){callback(new Error(err))}else{self.fs.rename(tmpdbname,dbname,callback)}})};LokiFsAdapter.prototype.deleteDatabase=function deleteDatabase(dbname,callback){this.fs.unlink(dbname,function deleteDatabaseCallback(err){if(err){callback(new Error(err))}else{callback()}})};function LokiLocalStorageAdapter(){}
LokiLocalStorageAdapter.prototype.loadDatabase=function loadDatabase(dbname,callback){if(localStorageAvailable()){callback(localStorage.getItem(dbname))}else{callback(new Error("localStorage is not available"))}};LokiLocalStorageAdapter.prototype.saveDatabase=function saveDatabase(dbname,dbstring,callback){if(localStorageAvailable()){localStorage.setItem(dbname,dbstring);callback(null)}else{callback(new Error("localStorage is not available"))}};LokiLocalStorageAdapter.prototype.deleteDatabase=function deleteDatabase(dbname,callback){if(localStorageAvailable()){localStorage.removeItem(dbname);callback(null)}else{callback(new Error("localStorage is not available"))}};Loki.prototype.throttledSaveDrain=function(callback,options){var self=this;var now=(new Date).getTime();if(!this.throttledSaves){callback(true)}options=options||{};if(!options.hasOwnProperty("recursiveWait")){options.recursiveWait=true}if(!options.hasOwnProperty("recursiveWaitLimit")){options.recursiveWaitLimit=false}if(!options.hasOwnProperty("recursiveWaitLimitDuration")){options.recursiveWaitLimitDuration=2e3}if(!options.hasOwnProperty("started")){options.started=(new Date).getTime()}if(this.throttledSaves&&this.throttledSavePending){if(options.recursiveWait){this.throttledCallbacks.push(function(){if(self.throttledSavePending){if(options.recursiveWaitLimit&&now-options.started>options.recursiveWaitLimitDuration){callback(false);return}self.throttledSaveDrain(callback,options);return}else{callback(true);return}})}else{this.throttledCallbacks.push(callback);return}}else{callback(true)}};Loki.prototype.loadDatabaseInternal=function(options,callback){var cFun=callback||function(err,data){if(err){throw err}},self=this;if(this.persistenceAdapter!==null){this.persistenceAdapter.loadDatabase(this.filename,function loadDatabaseCallback(dbString){if(typeof dbString==="string"){var parseSuccess=false;try{self.loadJSON(dbString,options||{});parseSuccess=true}catch(err){cFun(err)}if(parseSuccess){cFun(null);self.emit("loaded","database "+self.filename+" loaded")}}else{if(!dbString){cFun(null);self.emit("loaded","empty database "+self.filename+" loaded");return}if(dbString instanceof Error){cFun(dbString);return}if(typeof dbString==="object"){self.loadJSONObject(dbString,options||{});cFun(null);self.emit("loaded","database "+self.filename+" loaded");return}cFun("unexpected adapter response : "+dbString)}})}else{cFun(new Error("persistenceAdapter not configured"))}};Loki.prototype.loadDatabase=function(options,callback){var self=this;if(!this.throttledSaves){this.loadDatabaseInternal(options,callback);return}this.throttledSaveDrain(function(success){if(success){self.throttledSavePending=true;self.loadDatabaseInternal(options,function(err){if(self.throttledCallbacks.length===0){self.throttledSavePending=false}else{self.saveDatabase()}if(typeof callback==="function"){callback(err)}});return}else{if(typeof callback==="function"){callback(new Error("Unable to pause save throttling long enough to read database"))}}},options)};Loki.prototype.saveDatabaseInternal=function(callback){var cFun=callback||function(err){if(err){throw err}return},self=this;if(this.persistenceAdapter!==null){if(this.persistenceAdapter.mode==="reference"&&typeof this.persistenceAdapter.exportDatabase==="function"){this.persistenceAdapter.exportDatabase(this.filename,this.copy({removeNonSerializable:true}),function exportDatabaseCallback(err){self.autosaveClearFlags();cFun(err)})}else{self.autosaveClearFlags();this.persistenceAdapter.saveDatabase(this.filename,self.serialize(),function saveDatabasecallback(err){cFun(err)})}}else{cFun(new Error("persistenceAdapter not configured"))}};Loki.prototype.saveDatabase=function(callback){if(!this.throttledSaves){this.saveDatabaseInternal(callback);return}if(this.throttledSavePending){this.throttledCallbacks.push(callback);return}var localCallbacks=this.throttledCallbacks;this.throttledCallbacks=[];localCallbacks.unshift(callback);this.throttledSavePending=true;var self=this;this.saveDatabaseInternal(function(err){self.throttledSavePending=false;localCallbacks.forEach(function(pcb){if(typeof pcb==="function"){setTimeout(function(){pcb(err)},1)}});if(self.throttledCallbacks.length>0){self.saveDatabase()}})};Loki.prototype.save=Loki.prototype.saveDatabase;Loki.prototype.deleteDatabase=function(options,callback){var cFun=callback||function(err,data){if(err){throw err}};if(typeof options==="function"&&!callback){cFun=options}if(this.persistenceAdapter!==null){this.persistenceAdapter.deleteDatabase(this.filename,function deleteDatabaseCallback(err){cFun(err)})}else{cFun(new Error("persistenceAdapter not configured"))}};Loki.prototype.autosaveDirty=function(){for(var idx=0;idx<this.collections.length;idx++){if(this.collections[idx].dirty){return true}}return false};Loki.prototype.autosaveClearFlags=function(){for(var idx=0;idx<this.collections.length;idx++){this.collections[idx].dirty=false}};Loki.prototype.autosaveEnable=function(options,callback){this.autosave=true;var delay=5e3,self=this;if(typeof this.autosaveInterval!=="undefined"&&this.autosaveInterval!==null){delay=this.autosaveInterval}this.autosaveHandle=setInterval(function autosaveHandleInterval(){if(self.autosaveDirty()){self.saveDatabase(callback)}},delay)};Loki.prototype.autosaveDisable=function(){if(typeof this.autosaveHandle!=="undefined"&&this.autosaveHandle!==null){clearInterval(this.autosaveHandle);this.autosaveHandle=null}};function Resultset(collection,options){options=options||{};this.collection=collection;this.filteredrows=[];this.filterInitialized=false;return this}Resultset.prototype.reset=function(){if(this.filteredrows.length>0){this.filteredrows=[]}this.filterInitialized=false;return this};Resultset.prototype.toJSON=function(){var copy=this.copy();copy.collection=null;return copy};Resultset.prototype.limit=function(qty){if(!this.filterInitialized&&this.filteredrows.length===0){this.filteredrows=this.collection.prepareFullDocIndex()}var rscopy=new Resultset(this.collection);rscopy.filteredrows=this.filteredrows.slice(0,qty);rscopy.filterInitialized=true;return rscopy};Resultset.prototype.offset=function(pos){if(!this.filterInitialized&&this.filteredrows.length===0){this.filteredrows=this.collection.prepareFullDocIndex()}var rscopy=new Resultset(this.collection);rscopy.filteredrows=this.filteredrows.slice(pos);rscopy.filterInitialized=true;return rscopy};Resultset.prototype.copy=function(){var result=new Resultset(this.collection);if(this.filteredrows.length>0){result.filteredrows=this.filteredrows.slice()}result.filterInitialized=this.filterInitialized;return result};Resultset.prototype.branch=Resultset.prototype.copy;Resultset.prototype.transform=function(transform,parameters){var idx,step,rs=this;if(typeof transform==="string"){if(this.collection.transforms.hasOwnProperty(transform)){transform=this.collection.transforms[transform]}}if(typeof transform!=="object"||!Array.isArray(transform)){throw new Error("Invalid transform")}if(typeof parameters!=="undefined"){transform=Utils.resolveTransformParams(transform,parameters)}for(idx=0;idx<transform.length;idx++){step=transform[idx];switch(step.type){case"find":rs.find(step.value);break;case"where":rs.where(step.value);break;case"simplesort":rs.simplesort(step.property,step.desc||step.options);break;case"compoundsort":rs.compoundsort(step.value);break;case"sort":rs.sort(step.value);break;case"limit":rs=rs.limit(step.value);break;case"offset":rs=rs.offset(step.value);break;case"map":rs=rs.map(step.value,step.dataOptions);break;case"eqJoin":rs=rs.eqJoin(step.joinData,step.leftJoinKey,step.rightJoinKey,step.mapFun,step.dataOptions);break;case"mapReduce":rs=rs.mapReduce(step.mapFunction,step.reduceFunction);break;case"update":rs.update(step.value);break;case"remove":rs.remove();break;default:break}}return rs};Resultset.prototype.sort=function(comparefun){if(!this.filterInitialized&&this.filteredrows.length===0){this.filteredrows=this.collection.prepareFullDocIndex()}var wrappedComparer=function(userComparer,data){return function(a,b){return userComparer(data[a],data[b])}}(comparefun,this.collection.data);this.filteredrows.sort(wrappedComparer);return this};Resultset.prototype.simplesort=function(propname,options){var eff,targetEff=10,dc=this.collection.data.length,frl=this.filteredrows.length,hasBinaryIndex=this.collection.binaryIndices.hasOwnProperty(propname);if(typeof options==="undefined"||options===false){options={desc:false}}if(options===true){options={desc:true}}if(frl===0){if(this.filterInitialized){return this}if(this.collection.binaryIndices.hasOwnProperty(propname)){this.collection.ensureIndex(propname);this.filteredrows=this.collection.binaryIndices[propname].values.slice(0);if(options.desc){this.filteredrows.reverse()}return this}else{this.filteredrows=this.collection.prepareFullDocIndex()}}else{if(!options.disableIndexIntersect&&hasBinaryIndex){eff=dc/frl;if(options.useJavascriptSorting){targetEff=6}if(eff<=targetEff||options.forceIndexIntersect){var idx,fr=this.filteredrows;var io={};for(idx=0;idx<frl;idx++){io[fr[idx]]=true}var pv=this.collection.binaryIndices[propname].values;this.filteredrows=pv.filter(function(n){return io[n]});if(options.desc){this.filteredrows.reverse()}return this}}}if(options.useJavascriptSorting){return this.sort(function(obj1,obj2){if(obj1[propname]===obj2[propname])return 0;if(obj1[propname]>obj2[propname])return 1;if(obj1[propname]<obj2[propname])return-1})}var wrappedComparer=function(prop,desc,data){var val1,val2,arr;return function(a,b){if(~prop.indexOf(".")){arr=prop.split(".");val1=Utils.getIn(data[a],arr,true);val2=Utils.getIn(data[b],arr,true)}else{val1=data[a][prop];val2=data[b][prop]}return sortHelper(val1,val2,desc)}}(propname,options.desc,this.collection.data);this.filteredrows.sort(wrappedComparer);return this};Resultset.prototype.compoundsort=function(properties){if(properties.length===0){throw new Error("Invalid call to compoundsort, need at least one property")}var prop;if(properties.length===1){prop=properties[0];if(Array.isArray(prop)){return this.simplesort(prop[0],prop[1])}return this.simplesort(prop,false)}for(var i=0,len=properties.length;i<len;i+=1){prop=properties[i];if(!Array.isArray(prop)){properties[i]=[prop,false]}}if(!this.filterInitialized&&this.filteredrows.length===0){this.filteredrows=this.collection.prepareFullDocIndex()}var wrappedComparer=function(props,data){return function(a,b){return compoundeval(props,data[a],data[b])}}(properties,this.collection.data);this.filteredrows.sort(wrappedComparer);return this};Resultset.prototype.findOr=function(expressionArray){var fr=null,fri=0,frlen=0,docset=[],idxset=[],idx=0,origCount=this.count();for(var ei=0,elen=expressionArray.length;ei<elen;ei++){fr=this.branch().find(expressionArray[ei]).filteredrows;frlen=fr.length;if(frlen===origCount){return this}for(fri=0;fri<frlen;fri++){idx=fr[fri];if(idxset[idx]===undefined){idxset[idx]=true;docset.push(idx)}}}this.filteredrows=docset;this.filterInitialized=true;return this};Resultset.prototype.$or=Resultset.prototype.findOr;function precompileQuery(operator,value){if(operator==="$regex"){if(Array.isArray(value)){value=new RegExp(value[0],value[1])}else if(!(value instanceof RegExp)){value=new RegExp(value)}}else if(typeof value==="object"){for(var key in value){if(key==="$regex"||typeof value[key]==="object"){value[key]=precompileQuery(key,value[key])}}}return value}Resultset.prototype.findAnd=function(expressionArray){for(var i=0,len=expressionArray.length;i<len;i++){if(this.count()===0){return this}this.find(expressionArray[i])}return this};Resultset.prototype.$and=Resultset.prototype.findAnd;Resultset.prototype.find=function(query,firstOnly){if(this.collection.data.length===0){this.filteredrows=[];this.filterInitialized=true;return this}var queryObject=query||"getAll",p,property,queryObjectOp,obj,operator,value,key,searchByIndex=false,result=[],filters=[],index=null;firstOnly=firstOnly||false;if(typeof queryObject==="object"){for(p in queryObject){obj={};obj[p]=queryObject[p];filters.push(obj);if(hasOwnProperty.call(queryObject,p)){property=p;queryObjectOp=queryObject[p]}}if(filters.length>1){return this.find({$and:filters},firstOnly)}}if(!property||queryObject==="getAll"){if(firstOnly){this.filteredrows=this.collection.data.length>0?[0]:[];this.filterInitialized=true}return this}if(property==="$and"||property==="$or"){this[property](queryObjectOp);if(firstOnly&&this.filteredrows.length>1){this.filteredrows=this.filteredrows.slice(0,1)}return this}if(queryObjectOp===null||(typeof queryObjectOp!=="object"||queryObjectOp instanceof Date)){operator="$eq";value=queryObjectOp}else if(typeof queryObjectOp==="object"){for(key in queryObjectOp){if(hasOwnProperty.call(queryObjectOp,key)){operator=key;value=queryObjectOp[key];break}}}else{throw new Error("Do not know what you want to do.")}if(operator==="$regex"||typeof value==="object"){value=precompileQuery(operator,value)}var usingDotNotation=property.indexOf(".")!==-1;var doIndexCheck=!this.filterInitialized;if(doIndexCheck&&this.collection.binaryIndices[property]&&indexedOps[operator]){if(this.collection.adaptiveBinaryIndices!==true){this.collection.ensureIndex(property)}searchByIndex=true;index=this.collection.binaryIndices[property]}var fun=LokiOps[operator];var t=this.collection.data;var i=0,len=0;var filter,rowIdx=0;if(this.filterInitialized){filter=this.filteredrows;len=filter.length;if(usingDotNotation){property=property.split(".");for(i=0;i<len;i++){rowIdx=filter[i];if(dotSubScan(t[rowIdx],property,fun,value)){result.push(rowIdx)}}}else{for(i=0;i<len;i++){rowIdx=filter[i];if(fun(t[rowIdx][property],value)){result.push(rowIdx)}}}}else{if(!searchByIndex){len=t.length;if(usingDotNotation){property=property.split(".");for(i=0;i<len;i++){if(dotSubScan(t[i],property,fun,value)){result.push(i);if(firstOnly){this.filteredrows=result;this.filterInitialized=true;return this}}}}else{for(i=0;i<len;i++){if(fun(t[i][property],value)){result.push(i);if(firstOnly){this.filteredrows=result;this.filterInitialized=true;return this}}}}}else{var segm=this.collection.calculateRange(operator,property,value);if(operator!=="$in"){for(i=segm[0];i<=segm[1];i++){if(indexedOps[operator]!==true){if(indexedOps[operator](Utils.getIn(t[index.values[i]],property,usingDotNotation),value)){result.push(index.values[i]);if(firstOnly){this.filteredrows=result;this.filterInitialized=true;return this}}}else{result.push(index.values[i]);if(firstOnly){this.filteredrows=result;this.filterInitialized=true;return this}}}}else{for(i=0,len=segm.length;i<len;i++){result.push(index.values[segm[i]]);if(firstOnly){this.filteredrows=result;this.filterInitialized=true;return this}}}}}this.filteredrows=result;this.filterInitialized=true;return this};Resultset.prototype.where=function(fun){var viewFunction,result=[];if("function"===typeof fun){viewFunction=fun}else{throw new TypeError("Argument is not a stored view or a function")}try{if(this.filterInitialized){var j=this.filteredrows.length;while(j--){if(viewFunction(this.collection.data[this.filteredrows[j]])===true){result.push(this.filteredrows[j])}}this.filteredrows=result;return this}else{var k=this.collection.data.length;while(k--){if(viewFunction(this.collection.data[k])===true){result.push(k)}}this.filteredrows=result;this.filterInitialized=true;return this}}catch(err){throw err}};Resultset.prototype.count=function(){if(this.filterInitialized){return this.filteredrows.length}return this.collection.count()};Resultset.prototype.data=function(options){var result=[],data=this.collection.data,obj,len,i,method;options=options||{};if(options.removeMeta&&!options.forceClones){options.forceClones=true;options.forceCloneMethod=options.forceCloneMethod||"shallow"}if(!this.collection.disableDeltaChangesApi){options.forceClones=true;options.forceCloneMethod="parse-stringify"}if(!this.filterInitialized){if(this.filteredrows.length===0){if(this.collection.cloneObjects||options.forceClones){len=data.length;method=options.forceCloneMethod||this.collection.cloneMethod;for(i=0;i<len;i++){obj=clone(data[i],method);if(options.removeMeta){delete obj.$loki;delete obj.meta}result.push(obj)}return result}else{return data.slice()}}else{this.filterInitialized=true}}var fr=this.filteredrows;len=fr.length;if(this.collection.cloneObjects||options.forceClones){method=options.forceCloneMethod||this.collection.cloneMethod;for(i=0;i<len;i++){obj=clone(data[fr[i]],method);if(options.removeMeta){delete obj.$loki;delete obj.meta}result.push(obj)}}else{for(i=0;i<len;i++){result.push(data[fr[i]])}}return result};Resultset.prototype.update=function(updateFunction){if(typeof updateFunction!=="function"){throw new TypeError("Argument is not a function")}if(!this.filterInitialized&&this.filteredrows.length===0){this.filteredrows=this.collection.prepareFullDocIndex()}var obj,len=this.filteredrows.length,rcd=this.collection.data;for(var idx=0;idx<len;idx++){if(this.collection.cloneObjects||!this.collection.disableDeltaChangesApi){obj=clone(rcd[this.filteredrows[idx]],this.collection.cloneMethod);updateFunction(obj);this.collection.update(obj)}else{updateFunction(rcd[this.filteredrows[idx]]);this.collection.update(rcd[this.filteredrows[idx]])}}return this};Resultset.prototype.remove=function(){if(!this.filterInitialized&&this.filteredrows.length===0){this.filteredrows=this.collection.prepareFullDocIndex()}this.collection.removeBatchByPositions(this.filteredrows);this.filteredrows=[];return this};Resultset.prototype.mapReduce=function(mapFunction,reduceFunction){try{return reduceFunction(this.data().map(mapFunction))}catch(err){throw err}};Resultset.prototype.eqJoin=function(joinData,leftJoinKey,rightJoinKey,mapFun,dataOptions){var leftData=[],leftDataLength,rightData=[],rightDataLength,key,result=[],leftKeyisFunction=typeof leftJoinKey==="function",rightKeyisFunction=typeof rightJoinKey==="function",joinMap={};leftData=this.data(dataOptions);leftDataLength=leftData.length;if(joinData instanceof Collection){rightData=joinData.chain().data(dataOptions)}else if(joinData instanceof Resultset){rightData=joinData.data(dataOptions)}else if(Array.isArray(joinData)){rightData=joinData}else{throw new TypeError("joinData needs to be an array or result set")}rightDataLength=rightData.length;for(var i=0;i<rightDataLength;i++){key=rightKeyisFunction?rightJoinKey(rightData[i]):rightData[i][rightJoinKey];joinMap[key]=rightData[i]}if(!mapFun){mapFun=function(left,right){return{left:left,right:right}}}for(var j=0;j<leftDataLength;j++){key=leftKeyisFunction?leftJoinKey(leftData[j]):leftData[j][leftJoinKey];result.push(mapFun(leftData[j],joinMap[key]||{}))}this.collection=new Collection("joinData");this.collection.insert(result);this.filteredrows=[];this.filterInitialized=false;return this};Resultset.prototype.map=function(mapFun,dataOptions){var data=this.data(dataOptions).map(mapFun);this.collection=new Collection("mappedData");this.collection.insert(data);this.filteredrows=[];this.filterInitialized=false;return this};function DynamicView(collection,name,options){this.collection=collection;this.name=name;this.rebuildPending=false;this.options=options||{};if(!this.options.hasOwnProperty("persistent")){this.options.persistent=false}if(!this.options.hasOwnProperty("sortPriority")){this.options.sortPriority="passive"}if(!this.options.hasOwnProperty("minRebuildInterval")){this.options.minRebuildInterval=1}this.resultset=new Resultset(collection);this.resultdata=[];this.resultsdirty=false;this.cachedresultset=null;this.filterPipeline=[];this.sortFunction=null;this.sortCriteria=null;this.sortCriteriaSimple=null;this.sortDirty=false;this.events={rebuild:[]}}DynamicView.prototype=new LokiEventEmitter;DynamicView.prototype.rematerialize=function(options){var fpl,fpi,idx;options=options||{};this.resultdata=[];this.resultsdirty=true;this.resultset=new Resultset(this.collection);if(this.sortFunction||this.sortCriteria||this.sortCriteriaSimple){this.sortDirty=true}if(options.hasOwnProperty("removeWhereFilters")){fpl=this.filterPipeline.length;fpi=fpl;while(fpi--){if(this.filterPipeline[fpi].type==="where"){if(fpi!==this.filterPipeline.length-1){this.filterPipeline[fpi]=this.filterPipeline[this.filterPipeline.length-1]}this.filterPipeline.length--}}}var ofp=this.filterPipeline;this.filterPipeline=[];fpl=ofp.length;for(idx=0;idx<fpl;idx++){this.applyFind(ofp[idx].val)}this.data();this.emit("rebuild",this);return this};DynamicView.prototype.branchResultset=function(transform,parameters){var rs=this.resultset.branch();if(typeof transform==="undefined"){return rs}return rs.transform(transform,parameters)};DynamicView.prototype.toJSON=function(){var copy=new DynamicView(this.collection,this.name,this.options);copy.resultset=this.resultset;copy.resultdata=[];copy.resultsdirty=true;copy.filterPipeline=this.filterPipeline;copy.sortFunction=this.sortFunction;copy.sortCriteria=this.sortCriteria;copy.sortCriteriaSimple=this.sortCriteriaSimple||null;copy.sortDirty=this.sortDirty;copy.collection=null;return copy};DynamicView.prototype.removeFilters=function(options){options=options||{};this.rebuildPending=false;this.resultset.reset();this.resultdata=[];this.resultsdirty=true;this.cachedresultset=null;this.filterPipeline=[];this.sortFunction=null;this.sortCriteria=null;this.sortCriteriaSimple=null;this.sortDirty=false;if(options.queueSortPhase===true){this.queueSortPhase()}};DynamicView.prototype.applySort=function(comparefun){this.sortFunction=comparefun;this.sortCriteria=null;this.sortCriteriaSimple=null;this.queueSortPhase();return this};DynamicView.prototype.applySimpleSort=function(propname,options){this.sortCriteriaSimple={propname:propname,options:options||false};this.sortCriteria=null;this.sortFunction=null;this.queueSortPhase();return this};DynamicView.prototype.applySortCriteria=function(criteria){this.sortCriteria=criteria;this.sortCriteriaSimple=null;this.sortFunction=null;this.queueSortPhase();return this};DynamicView.prototype.startTransaction=function(){this.cachedresultset=this.resultset.copy();return this};DynamicView.prototype.commit=function(){this.cachedresultset=null;return this};DynamicView.prototype.rollback=function(){this.resultset=this.cachedresultset;if(this.options.persistent){this.resultdata=this.resultset.data();this.emit("rebuild",this)}return this};DynamicView.prototype._indexOfFilterWithId=function(uid){if(typeof uid==="string"||typeof uid==="number"){for(var idx=0,len=this.filterPipeline.length;idx<len;idx+=1){if(uid===this.filterPipeline[idx].uid){return idx}}}return-1};DynamicView.prototype._addFilter=function(filter){this.filterPipeline.push(filter);this.resultset[filter.type](filter.val)};DynamicView.prototype.reapplyFilters=function(){this.resultset.reset();this.cachedresultset=null;if(this.options.persistent){this.resultdata=[];this.resultsdirty=true}var filters=this.filterPipeline;this.filterPipeline=[];for(var idx=0,len=filters.length;idx<len;idx+=1){this._addFilter(filters[idx])}if(this.sortFunction||this.sortCriteria||this.sortCriteriaSimple){this.queueSortPhase()}else{this.queueRebuildEvent()}return this};DynamicView.prototype.applyFilter=function(filter){var idx=this._indexOfFilterWithId(filter.uid);if(idx>=0){this.filterPipeline[idx]=filter;return this.reapplyFilters()}this.cachedresultset=null;if(this.options.persistent){this.resultdata=[];this.resultsdirty=true}this._addFilter(filter);if(this.sortFunction||this.sortCriteria||this.sortCriteriaSimple){this.queueSortPhase()}else{this.queueRebuildEvent()}return this};DynamicView.prototype.applyFind=function(query,uid){this.applyFilter({type:"find",val:query,uid:uid});return this};DynamicView.prototype.applyWhere=function(fun,uid){this.applyFilter({type:"where",val:fun,uid:uid});return this};DynamicView.prototype.removeFilter=function(uid){var idx=this._indexOfFilterWithId(uid);if(idx<0){throw new Error("Dynamic view does not contain a filter with ID: "+uid)}this.filterPipeline.splice(idx,1);this.reapplyFilters();return this};DynamicView.prototype.count=function(){if(this.resultsdirty){this.resultdata=this.resultset.data()}return this.resultset.count()};DynamicView.prototype.data=function(options){if(this.sortDirty||this.resultsdirty){this.performSortPhase({suppressRebuildEvent:true})}return this.options.persistent?this.resultdata:this.resultset.data(options)};DynamicView.prototype.queueRebuildEvent=function(){if(this.rebuildPending){return}this.rebuildPending=true;var self=this;setTimeout(function(){if(self.rebuildPending){self.rebuildPending=false;self.emit("rebuild",self)}},this.options.minRebuildInterval)};DynamicView.prototype.queueSortPhase=function(){if(this.sortDirty){return}this.sortDirty=true;var self=this;if(this.options.sortPriority==="active"){setTimeout(function(){self.performSortPhase()},this.options.minRebuildInterval)}else{this.queueRebuildEvent()}};DynamicView.prototype.performSortPhase=function(options){if(!this.sortDirty&&!this.resultsdirty){return}options=options||{};if(this.sortDirty){if(this.sortFunction){this.resultset.sort(this.sortFunction)}else if(this.sortCriteria){this.resultset.compoundsort(this.sortCriteria)}else if(this.sortCriteriaSimple){this.resultset.simplesort(this.sortCriteriaSimple.propname,this.sortCriteriaSimple.options)}this.sortDirty=false}if(this.options.persistent){this.resultdata=this.resultset.data();this.resultsdirty=false}if(!options.suppressRebuildEvent){this.emit("rebuild",this)}};DynamicView.prototype.evaluateDocument=function(objIndex,isNew){if(!this.resultset.filterInitialized){if(this.options.persistent){this.resultdata=this.resultset.data()}if(this.sortFunction||this.sortCriteria||this.sortCriteriaSimple){this.queueSortPhase()}else{this.queueRebuildEvent()}return}var ofr=this.resultset.filteredrows;var oldPos=isNew?-1:ofr.indexOf(+objIndex);var oldlen=ofr.length;var evalResultset=new Resultset(this.collection);evalResultset.filteredrows=[objIndex];evalResultset.filterInitialized=true;var filter;for(var idx=0,len=this.filterPipeline.length;idx<len;idx++){filter=this.filterPipeline[idx];evalResultset[filter.type](filter.val)}var newPos=evalResultset.filteredrows.length===0?-1:0;if(oldPos===-1&&newPos===-1)return;if(oldPos===-1&&newPos!==-1){ofr.push(objIndex);if(this.options.persistent){this.resultdata.push(this.collection.data[objIndex])}if(this.sortFunction||this.sortCriteria||this.sortCriteriaSimple){this.queueSortPhase()}else{this.queueRebuildEvent()}return}if(oldPos!==-1&&newPos===-1){if(oldPos<oldlen-1){ofr.splice(oldPos,1);if(this.options.persistent){this.resultdata.splice(oldPos,1)}}else{ofr.length=oldlen-1;if(this.options.persistent){this.resultdata.length=oldlen-1}}if(this.sortFunction||this.sortCriteria||this.sortCriteriaSimple){this.queueSortPhase()}else{this.queueRebuildEvent()}return}if(oldPos!==-1&&newPos!==-1){if(this.options.persistent){this.resultdata[oldPos]=this.collection.data[objIndex]}if(this.sortFunction||this.sortCriteria||this.sortCriteriaSimple){this.queueSortPhase()}else{this.queueRebuildEvent()}return}};DynamicView.prototype.removeDocument=function(objIndex){var idx,rmidx,rmlen,rxo={},fxo={};var adjels=[];var drs=this.resultset;var fr=this.resultset.filteredrows;var frlen=fr.length;if(!this.resultset.filterInitialized){if(this.options.persistent){this.resultdata=this.resultset.data()}if(this.sortFunction||this.sortCriteria||this.sortCriteriaSimple){this.queueSortPhase()}else{this.queueRebuildEvent()}return}if(!Array.isArray(objIndex)){objIndex=[objIndex]}rmlen=objIndex.length;for(rmidx=0;rmidx<rmlen;rmidx++){rxo[objIndex[rmidx]]=true}for(idx=0;idx<frlen;idx++){if(rxo[fr[idx]])fxo[idx]=true}if(Object.keys(fxo).length>0){this.resultset.filteredrows=this.resultset.filteredrows.filter(function(di,idx){return!fxo[idx]});if(this.options.persistent){this.resultdata=this.resultdata.filter(function(obj,idx){return!fxo[idx]})}if(this.sortFunction||this.sortCriteria||this.sortCriteriaSimple){this.queueSortPhase()}else{this.queueRebuildEvent()}}var filt=function(idx){return function(di){return di<drs.filteredrows[idx]}};frlen=drs.filteredrows.length;for(idx=0;idx<frlen;idx++){adjels=objIndex.filter(filt(idx));drs.filteredrows[idx]-=adjels.length}};DynamicView.prototype.mapReduce=function(mapFunction,reduceFunction){try{return reduceFunction(this.data().map(mapFunction))}catch(err){throw err}};function Collection(name,options){this.name=name;this.data=[];this.idIndex=[];this.binaryIndices={};this.constraints={unique:{},exact:{}};this.uniqueNames=[];this.transforms={};this.objType=name;this.dirty=true;this.cachedIndex=null;this.cachedBinaryIndex=null;this.cachedData=null;var self=this;options=options||{};if(options.hasOwnProperty("unique")){if(!Array.isArray(options.unique)){options.unique=[options.unique]}options.unique.forEach(function(prop){self.uniqueNames.push(prop);self.constraints.unique[prop]=new UniqueIndex(prop)})}if(options.hasOwnProperty("exact")){options.exact.forEach(function(prop){self.constraints.exact[prop]=new ExactIndex(prop)})}this.adaptiveBinaryIndices=options.hasOwnProperty("adaptiveBinaryIndices")?options.adaptiveBinaryIndices:true;this.transactional=options.hasOwnProperty("transactional")?options.transactional:false;this.cloneObjects=options.hasOwnProperty("clone")?options.clone:false;this.cloneMethod=options.hasOwnProperty("cloneMethod")?options.cloneMethod:"parse-stringify";this.asyncListeners=options.hasOwnProperty("asyncListeners")?options.asyncListeners:false;this.disableMeta=options.hasOwnProperty("disableMeta")?options.disableMeta:false;this.disableChangesApi=options.hasOwnProperty("disableChangesApi")?options.disableChangesApi:true;this.disableDeltaChangesApi=options.hasOwnProperty("disableDeltaChangesApi")?options.disableDeltaChangesApi:true;if(this.disableChangesApi){this.disableDeltaChangesApi=true}this.autoupdate=options.hasOwnProperty("autoupdate")?options.autoupdate:false;this.serializableIndices=options.hasOwnProperty("serializableIndices")?options.serializableIndices:true;this.ttl={age:null,ttlInterval:null,daemon:null};this.setTTL(options.ttl||-1,options.ttlInterval);this.maxId=0;this.DynamicViews=[];this.events={insert:[],update:[],"pre-insert":[],"pre-update":[],close:[],flushbuffer:[],error:[],delete:[],warning:[]};this.changes=[];this.ensureId();var indices=[];if(options&&options.indices){if(Object.prototype.toString.call(options.indices)==="[object Array]"){indices=options.indices}else if(typeof options.indices==="string"){indices=[options.indices]}else{throw new TypeError("Indices needs to be a string or an array of strings")}}for(var idx=0;idx<indices.length;idx++){this.ensureIndex(indices[idx])}function observerCallback(changes){var changedObjects=typeof Set==="function"?new Set:[];if(!changedObjects.add)changedObjects.add=function(object){if(this.indexOf(object)===-1)this.push(object);return this};changes.forEach(function(change){changedObjects.add(change.object)});changedObjects.forEach(function(object){if(!hasOwnProperty.call(object,"$loki"))return self.removeAutoUpdateObserver(object);try{self.update(object)}catch(err){}})}this.observerCallback=observerCallback;function getChangeDelta(obj,old){if(old){return getObjectDelta(old,obj)}else{return JSON.parse(JSON.stringify(obj))}}this.getChangeDelta=getChangeDelta;function getObjectDelta(oldObject,newObject){var propertyNames=newObject!==null&&typeof newObject==="object"?Object.keys(newObject):null;if(propertyNames&&propertyNames.length&&["string","boolean","number"].indexOf(typeof newObject)<0){var delta={};for(var i=0;i<propertyNames.length;i++){var propertyName=propertyNames[i];if(newObject.hasOwnProperty(propertyName)){if(!oldObject.hasOwnProperty(propertyName)||self.uniqueNames.indexOf(propertyName)>=0||propertyName=="$loki"||propertyName=="meta"){delta[propertyName]=newObject[propertyName]}else{var propertyDelta=getObjectDelta(oldObject[propertyName],newObject[propertyName]);if(typeof propertyDelta!=="undefined"&&propertyDelta!={}){delta[propertyName]=propertyDelta}}}}
return Object.keys(delta).length===0?undefined:delta}else{return oldObject===newObject?undefined:newObject}}this.getObjectDelta=getObjectDelta;function flushChanges(){self.changes=[]}this.getChanges=function(){return self.changes};this.flushChanges=flushChanges;this.setChangesApi=function(enabled){self.disableChangesApi=!enabled;if(!enabled){self.disableDeltaChangesApi=false}};this.on("delete",function deleteCallback(obj){if(!self.disableChangesApi){self.createChange(self.name,"R",obj)}});this.on("warning",function(warning){self.console.warn(warning)});flushChanges()}Collection.prototype=new LokiEventEmitter;Collection.prototype.createChange=function(name,op,obj,old){this.changes.push({name:name,operation:op,obj:op=="U"&&!this.disableDeltaChangesApi?this.getChangeDelta(obj,old):JSON.parse(JSON.stringify(obj))})};Collection.prototype.insertMeta=function(obj){var len,idx;if(this.disableMeta||!obj){return}if(Array.isArray(obj)){len=obj.length;for(idx=0;idx<len;idx++){if(!obj[idx].hasOwnProperty("meta")){obj[idx].meta={}}obj[idx].meta.created=(new Date).getTime();obj[idx].meta.revision=0}return}if(!obj.meta){obj.meta={}}obj.meta.created=(new Date).getTime();obj.meta.revision=0};Collection.prototype.updateMeta=function(obj){if(this.disableMeta||!obj){return}obj.meta.updated=(new Date).getTime();obj.meta.revision+=1};Collection.prototype.createInsertChange=function(obj){this.createChange(this.name,"I",obj)};Collection.prototype.createUpdateChange=function(obj,old){this.createChange(this.name,"U",obj,old)};Collection.prototype.insertMetaWithChange=function(obj){this.insertMeta(obj);this.createInsertChange(obj)};Collection.prototype.updateMetaWithChange=function(obj,old){this.updateMeta(obj);this.createUpdateChange(obj,old)};Collection.prototype.console={log:function(){},warn:function(){},error:function(){}};Collection.prototype.addAutoUpdateObserver=function(object){if(!this.autoupdate||typeof Object.observe!=="function")return;Object.observe(object,this.observerCallback,["add","update","delete","reconfigure","setPrototype"])};Collection.prototype.removeAutoUpdateObserver=function(object){if(!this.autoupdate||typeof Object.observe!=="function")return;Object.unobserve(object,this.observerCallback)};Collection.prototype.addTransform=function(name,transform){if(this.transforms.hasOwnProperty(name)){throw new Error("a transform by that name already exists")}this.transforms[name]=transform};Collection.prototype.getTransform=function(name){return this.transforms[name]};Collection.prototype.setTransform=function(name,transform){this.transforms[name]=transform};Collection.prototype.removeTransform=function(name){delete this.transforms[name]};Collection.prototype.byExample=function(template){var k,obj,query;query=[];for(k in template){if(!template.hasOwnProperty(k))continue;query.push((obj={},obj[k]=template[k],obj))}return{$and:query}};Collection.prototype.findObject=function(template){return this.findOne(this.byExample(template))};Collection.prototype.findObjects=function(template){return this.find(this.byExample(template))};Collection.prototype.ttlDaemonFuncGen=function(){var collection=this;var age=this.ttl.age;return function ttlDaemon(){var now=Date.now();var toRemove=collection.chain().where(function daemonFilter(member){var timestamp=member.meta.updated||member.meta.created;var diff=now-timestamp;return age<diff});toRemove.remove()}};Collection.prototype.setTTL=function(age,interval){if(age<0){clearInterval(this.ttl.daemon)}else{this.ttl.age=age;this.ttl.ttlInterval=interval;this.ttl.daemon=setInterval(this.ttlDaemonFuncGen(),interval)}};Collection.prototype.prepareFullDocIndex=function(){var len=this.data.length;var indexes=new Array(len);for(var i=0;i<len;i+=1){indexes[i]=i}return indexes};Collection.prototype.configureOptions=function(options){options=options||{};if(options.hasOwnProperty("adaptiveBinaryIndices")){this.adaptiveBinaryIndices=options.adaptiveBinaryIndices;if(this.adaptiveBinaryIndices){this.ensureAllIndexes()}}};Collection.prototype.ensureIndex=function(property,force){if(typeof force==="undefined"){force=false}if(property===null||property===undefined){throw new Error("Attempting to set index without an associated property")}if(this.binaryIndices[property]&&!force){if(!this.binaryIndices[property].dirty)return}if(this.adaptiveBinaryIndices===true&&this.binaryIndices.hasOwnProperty(property)&&!force){return}var index={name:property,dirty:true,values:this.prepareFullDocIndex()};this.binaryIndices[property]=index;var wrappedComparer=function(prop,data){var val1,val2,arr;return function(a,b){if(~prop.indexOf(".")){arr=prop.split(".");val1=Utils.getIn(data[a],arr,true);val2=Utils.getIn(data[b],arr,true)}else{val1=data[a][prop];val2=data[b][prop]}if(val1!==val2){if(Comparators.lt(val1,val2,false))return-1;if(Comparators.gt(val1,val2,false))return 1}return 0}}(property,this.data);index.values.sort(wrappedComparer);index.dirty=false;this.dirty=true};Collection.prototype.checkAllIndexes=function(options){var key,bIndices=this.binaryIndices;var results=[],result;for(key in bIndices){if(hasOwnProperty.call(bIndices,key)){result=this.checkIndex(key,options);if(!result){results.push(key)}}}return results};Collection.prototype.checkIndex=function(property,options){options=options||{};if(options.randomSamplingFactor&&options.randomSampling!==false){options.randomSampling=true}options.randomSamplingFactor=options.randomSamplingFactor||.1;if(options.randomSamplingFactor<0||options.randomSamplingFactor>1){options.randomSamplingFactor=.1}var valid=true,idx,iter,pos,len,biv;if(!this.binaryIndices.hasOwnProperty(property)){throw new Error("called checkIndex on property without an index: "+property)}if(!this.adaptiveBinaryIndices){this.ensureIndex(property)}biv=this.binaryIndices[property].values;len=biv.length;if(len!==this.data.length){if(options.repair){this.ensureIndex(property,true)}return false}if(len===0){return true}var usingDotNotation=property.indexOf(".")!==-1;if(len===1){valid=biv[0]===0}else{if(options.randomSampling){if(!LokiOps.$lte(Utils.getIn(this.data[biv[0]],property,usingDotNotation),Utils.getIn(this.data[biv[1]],property,usingDotNotation))){valid=false}if(!LokiOps.$lte(Utils.getIn(this.data[biv[len-2]],property,usingDotNotation),Utils.getIn(this.data[biv[len-1]],property,usingDotNotation))){valid=false}if(valid){iter=Math.floor((len-1)*options.randomSamplingFactor);for(idx=0;idx<iter-1;idx++){pos=Math.floor(Math.random()*(len-1));if(!LokiOps.$lte(Utils.getIn(this.data[biv[pos]],property,usingDotNotation),Utils.getIn(this.data[biv[pos+1]],property,usingDotNotation))){valid=false;break}}}}else{for(idx=0;idx<len-1;idx++){if(!LokiOps.$lte(Utils.getIn(this.data[biv[idx]],property,usingDotNotation),Utils.getIn(this.data[biv[idx+1]],property,usingDotNotation))){valid=false;break}}}}if(!valid&&options.repair){this.ensureIndex(property,true)}return valid};Collection.prototype.getBinaryIndexValues=function(property){var idx,idxvals=this.binaryIndices[property].values;var result=[];for(idx=0;idx<idxvals.length;idx++){result.push(Utils.getIn(this.data[idxvals[idx]],property,true))}return result};Collection.prototype.ensureUniqueIndex=function(field){var index=this.constraints.unique[field];if(!index){if(this.uniqueNames.indexOf(field)==-1){this.uniqueNames.push(field)}}this.constraints.unique[field]=index=new UniqueIndex(field);this.data.forEach(function(obj){index.set(obj)});return index};Collection.prototype.ensureAllIndexes=function(force){var key,bIndices=this.binaryIndices;for(key in bIndices){if(hasOwnProperty.call(bIndices,key)){this.ensureIndex(key,force)}}};Collection.prototype.flagBinaryIndexesDirty=function(){var key,bIndices=this.binaryIndices;for(key in bIndices){if(hasOwnProperty.call(bIndices,key)){bIndices[key].dirty=true}}};Collection.prototype.flagBinaryIndexDirty=function(index){if(this.binaryIndices[index])this.binaryIndices[index].dirty=true};Collection.prototype.count=function(query){if(!query){return this.data.length}return this.chain().find(query).filteredrows.length};Collection.prototype.ensureId=function(){var len=this.data.length,i=0;this.idIndex=[];for(i;i<len;i+=1){this.idIndex.push(this.data[i].$loki)}};Collection.prototype.ensureIdAsync=function(callback){this.async(function(){this.ensureId()},callback)};Collection.prototype.addDynamicView=function(name,options){var dv=new DynamicView(this,name,options);this.DynamicViews.push(dv);return dv};Collection.prototype.removeDynamicView=function(name){this.DynamicViews=this.DynamicViews.filter(function(dv){return dv.name!==name})};Collection.prototype.getDynamicView=function(name){for(var idx=0;idx<this.DynamicViews.length;idx++){if(this.DynamicViews[idx].name===name){return this.DynamicViews[idx]}}return null};Collection.prototype.findAndUpdate=function(filterObject,updateFunction){if(typeof filterObject==="function"){this.updateWhere(filterObject,updateFunction)}else{this.chain().find(filterObject).update(updateFunction)}};Collection.prototype.findAndRemove=function(filterObject){this.chain().find(filterObject).remove()};Collection.prototype.insert=function(doc){if(!Array.isArray(doc)){return this.insertOne(doc)}var obj;var results=[];this.emit("pre-insert",doc);for(var i=0,len=doc.length;i<len;i++){obj=this.insertOne(doc[i],true);if(!obj){return undefined}results.push(obj)}this.emit("insert",results);results=this.cloneObjects?clone(results,this.cloneMethod):results;return results.length===1?results[0]:results};Collection.prototype.insertOne=function(doc,bulkInsert){var err=null;var returnObj;if(typeof doc!=="object"){err=new TypeError("Document needs to be an object")}else if(doc===null){err=new TypeError("Object cannot be null")}if(err!==null){this.emit("error",err);throw err}var obj=this.cloneObjects?clone(doc,this.cloneMethod):doc;if(!this.disableMeta&&typeof obj.meta==="undefined"){obj.meta={revision:0,created:0}}if(!bulkInsert){this.emit("pre-insert",obj)}if(!this.add(obj)){return undefined}if(this.disableChangesApi){this.insertMeta(obj)}else{this.insertMetaWithChange(obj)}returnObj=this.cloneObjects?clone(obj,this.cloneMethod):obj;if(!bulkInsert){this.emit("insert",returnObj)}this.addAutoUpdateObserver(returnObj);return returnObj};Collection.prototype.clear=function(options){var self=this;options=options||{};this.data=[];this.idIndex=[];this.cachedIndex=null;this.cachedBinaryIndex=null;this.cachedData=null;this.maxId=0;this.DynamicViews=[];this.dirty=true;if(options.removeIndices===true){this.binaryIndices={};this.constraints={unique:{},exact:{}};this.uniqueNames=[]}else{var keys=Object.keys(this.binaryIndices);keys.forEach(function(biname){self.binaryIndices[biname].dirty=false;self.binaryIndices[biname].values=[]});this.constraints={unique:{},exact:{}};this.uniqueNames.forEach(function(uiname){self.ensureUniqueIndex(uiname)})}};Collection.prototype.update=function(doc){var adaptiveBatchOverride,k,len;if(Array.isArray(doc)){len=doc.length;adaptiveBatchOverride=!this.cloneObjects&&this.adaptiveBinaryIndices&&Object.keys(this.binaryIndices).length>0;if(adaptiveBatchOverride){this.adaptiveBinaryIndices=false}try{for(k=0;k<len;k+=1){this.update(doc[k])}}finally{if(adaptiveBatchOverride){this.ensureAllIndexes();this.adaptiveBinaryIndices=true}}return}if(!hasOwnProperty.call(doc,"$loki")){throw new Error("Trying to update unsynced document. Please save the document first by using insert() or addMany()")}try{this.startTransaction();var arr=this.get(doc.$loki,true),oldInternal,newInternal,position,self=this;if(!arr){throw new Error("Trying to update a document not in collection.")}oldInternal=arr[0];position=arr[1];newInternal=this.cloneObjects||!this.disableDeltaChangesApi?clone(doc,this.cloneMethod):doc;this.emit("pre-update",doc);Object.keys(this.constraints.unique).forEach(function(key){self.constraints.unique[key].update(oldInternal,newInternal)});this.data[position]=newInternal;if(newInternal!==doc){this.addAutoUpdateObserver(doc)}for(var idx=0;idx<this.DynamicViews.length;idx++){this.DynamicViews[idx].evaluateDocument(position,false)}var key;if(this.adaptiveBinaryIndices){var bIndices=this.binaryIndices;for(key in bIndices){this.adaptiveBinaryIndexUpdate(position,key)}}else{this.flagBinaryIndexesDirty()}this.idIndex[position]=newInternal.$loki;this.commit();this.dirty=true;if(this.disableChangesApi){this.updateMeta(newInternal,null)}else{this.updateMetaWithChange(newInternal,oldInternal)}var returnObj;if(this.cloneObjects){returnObj=clone(newInternal,this.cloneMethod)}else{returnObj=newInternal}this.emit("update",returnObj,oldInternal);return returnObj}catch(err){this.rollback();this.console.error(err.message);this.emit("error",err);throw err}};Collection.prototype.add=function(obj){if("object"!==typeof obj){throw new TypeError("Object being added needs to be an object")}if(typeof obj.$loki!=="undefined"){throw new Error("Document is already in collection, please use update()")}try{this.startTransaction();this.maxId++;if(isNaN(this.maxId)){this.maxId=this.data[this.data.length-1].$loki+1}obj.$loki=this.maxId;if(!this.disableMeta){obj.meta.version=0}var key,constrUnique=this.constraints.unique;for(key in constrUnique){if(hasOwnProperty.call(constrUnique,key)){constrUnique[key].set(obj)}}this.idIndex.push(obj.$loki);this.data.push(obj);var addedPos=this.data.length-1;var dvlen=this.DynamicViews.length;for(var i=0;i<dvlen;i++){this.DynamicViews[i].evaluateDocument(addedPos,true)}if(this.adaptiveBinaryIndices){var bIndices=this.binaryIndices;for(key in bIndices){this.adaptiveBinaryIndexInsert(addedPos,key)}}else{this.flagBinaryIndexesDirty()}this.commit();this.dirty=true;return this.cloneObjects?clone(obj,this.cloneMethod):obj}catch(err){this.rollback();this.console.error(err.message);this.emit("error",err);throw err}};Collection.prototype.updateWhere=function(filterFunction,updateFunction){var results=this.where(filterFunction),i=0,obj;try{for(i;i<results.length;i++){obj=updateFunction(results[i]);this.update(obj)}}catch(err){this.rollback();this.console.error(err.message)}};Collection.prototype.removeWhere=function(query){var list;if(typeof query==="function"){list=this.data.filter(query);this.remove(list)}else{this.chain().find(query).remove()}};Collection.prototype.removeDataOnly=function(){this.remove(this.data.slice())};Collection.prototype.removeBatchByPositions=function(positions){var len=positions.length;var xo={};var dlen,didx,idx;var bic=Object.keys(this.binaryIndices).length;var uic=Object.keys(this.constraints.unique).length;var adaptiveOverride=this.adaptiveBinaryIndices&&Object.keys(this.binaryIndices).length>0;var doc,self=this;try{this.startTransaction();for(idx=0;idx<len;idx++){xo[this.idIndex[positions[idx]]]=true}dlen=this.DynamicViews.length;if(dlen>0||bic>0||uic>0){if(dlen>0){for(didx=0;didx<dlen;didx++){this.DynamicViews[didx].removeDocument(positions)}}if(this.adaptiveBinaryIndices&&!adaptiveOverride){var key,bIndices=this.binaryIndices;for(key in bIndices){this.adaptiveBinaryIndexRemove(positions,key)}}else{this.flagBinaryIndexesDirty()}if(uic){Object.keys(this.constraints.unique).forEach(function(key){for(idx=0;idx<len;idx++){doc=self.data[positions[idx]];if(doc[key]!==null&&doc[key]!==undefined){self.constraints.unique[key].remove(doc[key])}}})}}if(!this.disableChangesApi||this.events.delete.length>1){for(idx=0;idx<len;idx++){this.emit("delete",this.data[positions[idx]])}}this.data=this.data.filter(function(obj){return!xo[obj.$loki]});this.idIndex=this.idIndex.filter(function(id){return!xo[id]});if(this.adaptiveBinaryIndices&&adaptiveOverride){this.adaptiveBinaryIndices=false;this.ensureAllIndexes(true);this.adaptiveBinaryIndices=true}this.commit();this.dirty=true}catch(err){this.rollback();if(adaptiveOverride){this.adaptiveBinaryIndices=true}this.console.error(err.message);this.emit("error",err);return null}};Collection.prototype.removeBatch=function(batch){var len=batch.length,dlen=this.data.length,idx;var xlt={};var posx=[];for(idx=0;idx<dlen;idx++){xlt[this.data[idx].$loki]=idx}for(idx=0;idx<len;idx++){if(typeof batch[idx]==="object"){posx.push(xlt[batch[idx].$loki])}else{posx.push(xlt[batch[idx]])}}this.removeBatchByPositions(posx)};Collection.prototype.remove=function(doc){if(typeof doc==="number"){doc=this.get(doc)}if("object"!==typeof doc){throw new Error("Parameter is not an object")}if(Array.isArray(doc)){this.removeBatch(doc);return}if(!hasOwnProperty.call(doc,"$loki")){throw new Error("Object is not a document stored in the collection")}try{this.startTransaction();var arr=this.get(doc.$loki,true),position=arr[1];var self=this;Object.keys(this.constraints.unique).forEach(function(key){if(doc[key]!==null&&typeof doc[key]!=="undefined"){self.constraints.unique[key].remove(doc[key])}});for(var idx=0;idx<this.DynamicViews.length;idx++){this.DynamicViews[idx].removeDocument(position)}if(this.adaptiveBinaryIndices){var key,bIndices=this.binaryIndices;for(key in bIndices){this.adaptiveBinaryIndexRemove(position,key)}}else{this.flagBinaryIndexesDirty()}this.data.splice(position,1);this.removeAutoUpdateObserver(doc);this.idIndex.splice(position,1);this.commit();this.dirty=true;this.emit("delete",arr[0]);delete doc.$loki;delete doc.meta;return doc}catch(err){this.rollback();this.console.error(err.message);this.emit("error",err);return null}};Collection.prototype.get=function(id,returnPosition){var retpos=returnPosition||false,data=this.idIndex,max=data.length-1,min=0,mid=min+max>>1;id=typeof id==="number"?id:parseInt(id,10);if(isNaN(id)){throw new TypeError("Passed id is not an integer")}while(data[min]<data[max]){mid=min+max>>1;if(data[mid]<id){min=mid+1}else{max=mid}}if(max===min&&data[min]===id){if(retpos){return[this.data[min],min]}return this.data[min]}return null};Collection.prototype.getBinaryIndexPosition=function(dataPosition,binaryIndexName){var val=Utils.getIn(this.data[dataPosition],binaryIndexName,true);var index=this.binaryIndices[binaryIndexName].values;var range=this.calculateRange("$eq",binaryIndexName,val);if(range[0]===0&&range[1]===-1){return null}var min=range[0];var max=range[1];for(var idx=min;idx<=max;idx++){if(index[idx]===dataPosition)return idx}return null};Collection.prototype.adaptiveBinaryIndexInsert=function(dataPosition,binaryIndexName){var usingDotNotation=binaryIndexName.indexOf(".")!==-1;var index=this.binaryIndices[binaryIndexName].values;var val=Utils.getIn(this.data[dataPosition],binaryIndexName,usingDotNotation);if(this.serializableIndices===true&&val instanceof Date){this.data[dataPosition][binaryIndexName]=val.getTime();val=Utils.getIn(this.data[dataPosition],binaryIndexName)}var idxPos=index.length===0?0:this.calculateRangeStart(binaryIndexName,val,true,usingDotNotation);this.binaryIndices[binaryIndexName].values.splice(idxPos,0,dataPosition)};Collection.prototype.adaptiveBinaryIndexUpdate=function(dataPosition,binaryIndexName){var idxPos,index=this.binaryIndices[binaryIndexName].values,len=index.length;for(idxPos=0;idxPos<len;idxPos++){if(index[idxPos]===dataPosition)break}this.binaryIndices[binaryIndexName].values.splice(idxPos,1);this.adaptiveBinaryIndexInsert(dataPosition,binaryIndexName)};Collection.prototype.adaptiveBinaryIndexRemove=function(dataPosition,binaryIndexName,removedFromIndexOnly){var bi=this.binaryIndices[binaryIndexName];var len,idx,rmidx,rmlen,rxo={};var curr,shift,idxPos;if(Array.isArray(dataPosition)){rmlen=dataPosition.length;if(rmlen===1){dataPosition=dataPosition[0]}else{for(rmidx=0;rmidx<rmlen;rmidx++){rxo[dataPosition[rmidx]]=true}bi.values=bi.values.filter(function(di){return!rxo[di]});if(removedFromIndexOnly===true){return}var sortedPositions=dataPosition.slice();sortedPositions.sort(function(a,b){return a-b});len=bi.values.length;for(idx=0;idx<len;idx++){curr=bi.values[idx];shift=0;for(rmidx=0;rmidx<rmlen&&curr>sortedPositions[rmidx];rmidx++){shift++}bi.values[idx]-=shift}return}}idxPos=this.getBinaryIndexPosition(dataPosition,binaryIndexName);if(idxPos===null){return null}bi.values.splice(idxPos,1);if(removedFromIndexOnly===true){return}len=bi.values.length;for(idx=0;idx<len;idx++){if(bi.values[idx]>dataPosition){bi.values[idx]--}}};Collection.prototype.calculateRangeStart=function(prop,val,adaptive,usingDotNotation){var rcd=this.data;var index=this.binaryIndices[prop].values;var min=0;var max=index.length-1;var mid=0;if(index.length===0){return-1}var minVal=Utils.getIn(rcd[index[min]],prop,usingDotNotation);var maxVal=Utils.getIn(rcd[index[max]],prop,usingDotNotation);while(min<max){mid=min+max>>1;if(Comparators.lt(Utils.getIn(rcd[index[mid]],prop,usingDotNotation),val,false)){min=mid+1}else{max=mid}}var lbound=min;if(Comparators.aeq(val,Utils.getIn(rcd[index[lbound]],prop,usingDotNotation))){return lbound}if(Comparators.lt(val,Utils.getIn(rcd[index[lbound]],prop,usingDotNotation),false)){return adaptive?lbound:lbound-1}return adaptive?lbound+1:lbound};Collection.prototype.calculateRangeEnd=function(prop,val,usingDotNotation){var rcd=this.data;var index=this.binaryIndices[prop].values;var min=0;var max=index.length-1;var mid=0;if(index.length===0){return-1}var minVal=Utils.getIn(rcd[index[min]],prop,usingDotNotation);var maxVal=Utils.getIn(rcd[index[max]],prop,usingDotNotation);while(min<max){mid=min+max>>1;if(Comparators.lt(val,Utils.getIn(rcd[index[mid]],prop,usingDotNotation),false)){max=mid}else{min=mid+1}}var ubound=max;if(Comparators.aeq(val,Utils.getIn(rcd[index[ubound]],prop,usingDotNotation))){return ubound}if(Comparators.gt(val,Utils.getIn(rcd[index[ubound]],prop,usingDotNotation),false)){return ubound+1}if(Comparators.aeq(val,Utils.getIn(rcd[index[ubound-1]],prop,usingDotNotation))){return ubound-1}return ubound};Collection.prototype.calculateRange=function(op,prop,val){var rcd=this.data;var index=this.binaryIndices[prop].values;var min=0;var max=index.length-1;var mid=0;var lbound,lval;var ubound,uval;if(rcd.length===0){return[0,-1]}var usingDotNotation=prop.indexOf(".")!==-1;var minVal=Utils.getIn(rcd[index[min]],prop,usingDotNotation);var maxVal=Utils.getIn(rcd[index[max]],prop,usingDotNotation);switch(op){case"$eq":case"$aeq":if(Comparators.lt(val,minVal,false)||Comparators.gt(val,maxVal,false)){return[0,-1]}break;case"$dteq":if(Comparators.lt(val,minVal,false)||Comparators.gt(val,maxVal,false)){return[0,-1]}break;case"$gt":if(Comparators.gt(val,maxVal,true)){return[0,-1]}if(Comparators.gt(minVal,val,false)){return[min,max]}break;case"$gte":if(Comparators.gt(val,maxVal,false)){return[0,-1]}if(Comparators.gt(minVal,val,true)){return[min,max]}break;case"$lt":if(Comparators.lt(val,minVal,true)){return[0,-1]}if(Comparators.lt(maxVal,val,false)){return[min,max]}break;case"$lte":if(Comparators.lt(val,minVal,false)){return[0,-1]}if(Comparators.lt(maxVal,val,true)){return[min,max]}break;case"$between":if(Comparators.gt(val[0],maxVal,false)){return[0,-1]}if(Comparators.lt(val[1],minVal,false)){return[0,-1]}lbound=this.calculateRangeStart(prop,val[0],false,usingDotNotation);ubound=this.calculateRangeEnd(prop,val[1],usingDotNotation);if(lbound<0)lbound++;if(ubound>max)ubound--;if(!Comparators.gt(Utils.getIn(rcd[index[lbound]],prop,usingDotNotation),val[0],true))lbound++;if(!Comparators.lt(Utils.getIn(rcd[index[ubound]],prop,usingDotNotation),val[1],true))ubound--;if(ubound<lbound)return[0,-1];return[lbound,ubound];case"$in":var idxset=[],segResult=[];for(var j=0,len=val.length;j<len;j++){var seg=this.calculateRange("$eq",prop,val[j]);for(var i=seg[0];i<=seg[1];i++){if(idxset[i]===undefined){idxset[i]=true;segResult.push(i)}}}return segResult}switch(op){case"$eq":case"$aeq":case"$dteq":case"$gte":case"$lt":lbound=this.calculateRangeStart(prop,val,false,usingDotNotation);lval=Utils.getIn(rcd[index[lbound]],prop,usingDotNotation);break;default:break}switch(op){case"$eq":case"$aeq":case"$dteq":case"$lte":case"$gt":ubound=this.calculateRangeEnd(prop,val,usingDotNotation);uval=Utils.getIn(rcd[index[ubound]],prop,usingDotNotation);break;default:break}switch(op){case"$eq":case"$aeq":case"$dteq":if(!Comparators.aeq(lval,val)){return[0,-1]}return[lbound,ubound];case"$gt":if(!Comparators.aeq(Utils.getIn(rcd[index[ubound]],prop,usingDotNotation),val)){return[ubound,max]}return[ubound+1,max];case"$gte":if(!Comparators.aeq(Utils.getIn(rcd[index[lbound]],prop,usingDotNotation),val)){return[lbound+1,max]}return[lbound,max];case"$lt":if(!Comparators.aeq(Utils.getIn(rcd[index[lbound]],prop,usingDotNotation),val)){return[min,lbound]}return[min,lbound-1];case"$lte":if(!Comparators.aeq(Utils.getIn(rcd[index[ubound]],prop,usingDotNotation),val)){return[min,ubound-1]}return[min,ubound];default:return[0,rcd.length-1]}};Collection.prototype.by=function(field,value){var self;if(value===undefined){self=this;return function(value){return self.by(field,value)}}var result=this.constraints.unique[field].get(value);if(!this.cloneObjects){return result}else{return clone(result,this.cloneMethod)}};Collection.prototype.findOne=function(query){query=query||{};var result=this.chain().find(query,true).data();if(Array.isArray(result)&&result.length===0){return null}else{if(!this.cloneObjects){return result[0]}else{return clone(result[0],this.cloneMethod)}}};Collection.prototype.chain=function(transform,parameters){var rs=new Resultset(this);if(typeof transform==="undefined"){return rs}return rs.transform(transform,parameters)};Collection.prototype.find=function(query){return this.chain().find(query).data()};Collection.prototype.findOneUnindexed=function(prop,value){var i=this.data.length,doc;while(i--){if(Utils.getIn(this.data[i],prop,true)===value){doc=this.data[i];return doc}}return null};Collection.prototype.startTransaction=function(){if(this.transactional){this.cachedData=clone(this.data,this.cloneMethod);this.cachedIndex=this.idIndex;this.cachedBinaryIndex=this.binaryIndices;for(var idx=0;idx<this.DynamicViews.length;idx++){this.DynamicViews[idx].startTransaction()}}};Collection.prototype.commit=function(){if(this.transactional){this.cachedData=null;this.cachedIndex=null;this.cachedBinaryIndex=null;for(var idx=0;idx<this.DynamicViews.length;idx++){this.DynamicViews[idx].commit()}}};Collection.prototype.rollback=function(){if(this.transactional){if(this.cachedData!==null&&this.cachedIndex!==null){this.data=this.cachedData;this.idIndex=this.cachedIndex;this.binaryIndices=this.cachedBinaryIndex}for(var idx=0;idx<this.DynamicViews.length;idx++){this.DynamicViews[idx].rollback()}}};Collection.prototype.async=function(fun,callback){setTimeout(function(){if(typeof fun==="function"){fun();callback()}else{throw new TypeError("Argument passed for async execution is not a function")}},0)};Collection.prototype.where=function(fun){return this.chain().where(fun).data()};Collection.prototype.mapReduce=function(mapFunction,reduceFunction){try{return reduceFunction(this.data.map(mapFunction))}catch(err){throw err}};Collection.prototype.eqJoin=function(joinData,leftJoinProp,rightJoinProp,mapFun,dataOptions){return new Resultset(this).eqJoin(joinData,leftJoinProp,rightJoinProp,mapFun,dataOptions)};Collection.prototype.stages={};Collection.prototype.getStage=function(name){if(!this.stages[name]){this.stages[name]={}}return this.stages[name]};Collection.prototype.commitLog=[];Collection.prototype.stage=function(stageName,obj){var copy=JSON.parse(JSON.stringify(obj));this.getStage(stageName)[obj.$loki]=copy;return copy};Collection.prototype.commitStage=function(stageName,message){var stage=this.getStage(stageName),prop,timestamp=(new Date).getTime();for(prop in stage){this.update(stage[prop]);this.commitLog.push({timestamp:timestamp,message:message,data:JSON.parse(JSON.stringify(stage[prop]))})}this.stages[stageName]={}};Collection.prototype.no_op=function(){return};Collection.prototype.extract=function(field){var i=0,len=this.data.length,isDotNotation=isDeepProperty(field),result=[];for(i;i<len;i+=1){result.push(deepProperty(this.data[i],field,isDotNotation))}return result};Collection.prototype.max=function(field){return Math.max.apply(null,this.extract(field))};Collection.prototype.min=function(field){return Math.min.apply(null,this.extract(field))};Collection.prototype.maxRecord=function(field){var i=0,len=this.data.length,deep=isDeepProperty(field),result={index:0,value:undefined},max;for(i;i<len;i+=1){if(max!==undefined){if(max<deepProperty(this.data[i],field,deep)){max=deepProperty(this.data[i],field,deep);result.index=this.data[i].$loki}}else{max=deepProperty(this.data[i],field,deep);result.index=this.data[i].$loki}}result.value=max;return result};Collection.prototype.minRecord=function(field){var i=0,len=this.data.length,deep=isDeepProperty(field),result={index:0,value:undefined},min;for(i;i<len;i+=1){if(min!==undefined){if(min>deepProperty(this.data[i],field,deep)){min=deepProperty(this.data[i],field,deep);result.index=this.data[i].$loki}}else{min=deepProperty(this.data[i],field,deep);result.index=this.data[i].$loki}}result.value=min;return result};Collection.prototype.extractNumerical=function(field){return this.extract(field).map(parseBase10).filter(Number).filter(function(n){return!isNaN(n)})};Collection.prototype.avg=function(field){return average(this.extractNumerical(field))};Collection.prototype.stdDev=function(field){return standardDeviation(this.extractNumerical(field))};Collection.prototype.mode=function(field){var dict={},data=this.extract(field);data.forEach(function(obj){if(dict[obj]){dict[obj]+=1}else{dict[obj]=1}});var max,prop,mode;for(prop in dict){if(max){if(max<dict[prop]){mode=prop}}else{mode=prop;max=dict[prop]}}return mode};Collection.prototype.median=function(field){var values=this.extractNumerical(field);values.sort(sub);var half=Math.floor(values.length/2);if(values.length%2){return values[half]}else{return(values[half-1]+values[half])/2}};function isDeepProperty(field){return field.indexOf(".")!==-1}function parseBase10(num){return parseFloat(num,10)}function isNotUndefined(obj){return obj!==undefined}function add(a,b){return a+b}function sub(a,b){return a-b}function median(values){values.sort(sub);var half=Math.floor(values.length/2);return values.length%2?values[half]:(values[half-1]+values[half])/2}function average(array){return array.reduce(add,0)/array.length}function standardDeviation(values){var avg=average(values);var squareDiffs=values.map(function(value){var diff=value-avg;var sqrDiff=diff*diff;return sqrDiff});var avgSquareDiff=average(squareDiffs);var stdDev=Math.sqrt(avgSquareDiff);return stdDev}function deepProperty(obj,property,isDeep){if(isDeep===false){return obj[property]}var pieces=property.split("."),root=obj;while(pieces.length>0){root=root[pieces.shift()]}return root}function binarySearch(array,item,fun){var lo=0,hi=array.length,compared,mid;while(lo<hi){mid=lo+hi>>1;compared=fun.apply(null,[item,array[mid]]);if(compared===0){return{found:true,index:mid}}else if(compared<0){hi=mid}else{lo=mid+1}}return{found:false,index:hi}}function BSonSort(fun){return function(array,item){return binarySearch(array,item,fun)}}function KeyValueStore(){}KeyValueStore.prototype={keys:[],values:[],sort:function(a,b){return a<b?-1:a>b?1:0},setSort:function(fun){this.bs=new BSonSort(fun)},bs:function(){return new BSonSort(this.sort)},set:function(key,value){var pos=this.bs(this.keys,key);if(pos.found){this.values[pos.index]=value}else{this.keys.splice(pos.index,0,key);this.values.splice(pos.index,0,value)}},get:function(key){return this.values[binarySearch(this.keys,key,this.sort).index]}};function UniqueIndex(uniqueField){this.field=uniqueField;this.keyMap={};this.lokiMap={}}UniqueIndex.prototype.keyMap={};UniqueIndex.prototype.lokiMap={};UniqueIndex.prototype.set=function(obj){var fieldValue=obj[this.field];if(fieldValue!==null&&typeof fieldValue!=="undefined"){if(this.keyMap[fieldValue]){throw new Error("Duplicate key for property "+this.field+": "+fieldValue)}else{this.keyMap[fieldValue]=obj;this.lokiMap[obj.$loki]=fieldValue}}};UniqueIndex.prototype.get=function(key){return this.keyMap[key]};UniqueIndex.prototype.byId=function(id){return this.keyMap[this.lokiMap[id]]}
;UniqueIndex.prototype.update=function(obj,doc){if(this.lokiMap[obj.$loki]!==doc[this.field]){var old=this.lokiMap[obj.$loki];this.set(doc);this.keyMap[old]=undefined}else{this.keyMap[obj[this.field]]=doc}};UniqueIndex.prototype.remove=function(key){var obj=this.keyMap[key];if(obj!==null&&typeof obj!=="undefined"){this.keyMap[key]=undefined;this.lokiMap[obj.$loki]=undefined}else{throw new Error("Key is not in unique index: "+this.field)}};UniqueIndex.prototype.clear=function(){this.keyMap={};this.lokiMap={}};function ExactIndex(exactField){this.index={};this.field=exactField}ExactIndex.prototype={set:function add(key,val){if(this.index[key]){this.index[key].push(val)}else{this.index[key]=[val]}},remove:function remove(key,val){var idxSet=this.index[key];for(var i in idxSet){if(idxSet[i]==val){idxSet.splice(i,1)}}if(idxSet.length<1){this.index[key]=undefined}},get:function get(key){return this.index[key]},clear:function clear(key){this.index={}}};function SortedIndex(sortedField){this.field=sortedField}SortedIndex.prototype={keys:[],values:[],sort:function(a,b){return a<b?-1:a>b?1:0},bs:function(){return new BSonSort(this.sort)},setSort:function(fun){this.bs=new BSonSort(fun)},set:function(key,value){var pos=binarySearch(this.keys,key,this.sort);if(pos.found){this.values[pos.index].push(value)}else{this.keys.splice(pos.index,0,key);this.values.splice(pos.index,0,[value])}},get:function(key){var bsr=binarySearch(this.keys,key,this.sort);if(bsr.found){return this.values[bsr.index]}else{return[]}},getLt:function(key){var bsr=binarySearch(this.keys,key,this.sort);var pos=bsr.index;if(bsr.found)pos--;return this.getAll(key,0,pos)},getGt:function(key){var bsr=binarySearch(this.keys,key,this.sort);var pos=bsr.index;if(bsr.found)pos++;return this.getAll(key,pos,this.keys.length)},getAll:function(key,start,end){var results=[];for(var i=start;i<end;i++){results=results.concat(this.values[i])}return results},getPos:function(key){return binarySearch(this.keys,key,this.sort)},remove:function(key,value){var pos=binarySearch(this.keys,key,this.sort).index;var idxSet=this.values[pos];for(var i in idxSet){if(idxSet[i]==value)idxSet.splice(i,1)}if(idxSet.length<1){this.keys.splice(pos,1);this.values.splice(pos,1)}},clear:function(){this.keys=[];this.values=[]}};Loki.LokiOps=LokiOps;Loki.Collection=Collection;Loki.KeyValueStore=KeyValueStore;Loki.LokiMemoryAdapter=LokiMemoryAdapter;Loki.LokiPartitioningAdapter=LokiPartitioningAdapter;Loki.LokiLocalStorageAdapter=LokiLocalStorageAdapter;Loki.LokiFsAdapter=LokiFsAdapter;Loki.persistenceAdapters={fs:LokiFsAdapter,localStorage:LokiLocalStorageAdapter};Loki.aeq=aeqHelper;Loki.lt=ltHelper;Loki.gt=gtHelper;Loki.Comparators=Comparators;return Loki}()});

define('organizator/Util/FormSerializer',[],function(){
    class Organizator_Util_FormSerializer {
        constructor() {
            this.submitters = /^(?:submit|button|image|reset|file)$/i;
            this.successControls = /^(?:input|select|textarea|keygen)/i;
            this.brackets = /(\[[^\[\]]*\])/g;
        }

    // serializes form fields
    // @param form MUST be an HTMLForm element
    // @param options is an optional argument to configure the serialization. Default output
    // with no options specified is a url encoded string
    //    - hash: [true | false] Configure the output type. If true, the output will
    //    be a js object.
    //    - serializer: [function] Optional serializer to override the default one.
    //    The takes 3 arguments (result, key, value) and should return new result
    //    hash and url encoded str serializers are provided with this module
    //    - disabled: [true | false]. If true serialize disabled fields.
    //    - empty: [true | false]. If true serialize empty fields
        serialize(form, options) {
            if (typeof options != 'object') {
                options = {hash: !!options};
            } else if (options.hash === undefined) {
                options.hash = true;
            }

            var result = (options.hash) ? {} : '';
            var serializer = options.serializer || ((options.hash) ? this.hashSerialize : this.stringSerialize);
            var elements = form && form.elements ? form.elements : [];
            //Object store each radio and set if it's empty or not
            var radioStore = Object.create(null);
            for (var i = 0; i < elements.length; ++i) {
                var element = elements[i];
                // ingore disabled fields
                if ((!options.disabled && element.disabled) || !element.name) {
                    continue;
                }
    // ignore anyhting that is not considered a success field
                if (!this.successControls.test(element.nodeName) ||
                        this.submitters.test(element.type)) {
                    continue;
                }

                var key = element.name;
                var val = element.value;
                // we can't just use element.value for checkboxes cause some browsers lie to us
                // they say "on" for value when the box isn't checked
                if ((element.type === 'checkbox' || element.type === 'radio') && !element.checked) {
                    val = undefined;
                }

    // If we want empty elements
                if (options.empty) {
    // for checkbox
                    if (element.type === 'checkbox' && !element.checked) {
                        val = '';
                    }

    // for radio
                    if (element.type === 'radio') {
                        if (!radioStore[element.name] && !element.checked) {
                            radioStore[element.name] = false;
                        } else if (element.checked) {
                            radioStore[element.name] = true;
                        }
                    }

    // if options empty is true, continue only if its radio
                    if (val == undefined && element.type == 'radio') {
                        continue;
                    }
                } else {
    // value-less fields are ignored unless options.empty is true
                    if (!val) {
                        continue;
                    }
                }

    // multi select boxes
                if (element.type === 'select-multiple') {
                    val = [];
                    var selectOptions = element.options;
                    var isSelectedOptions = false;
                    for (var j = 0; j < selectOptions.length; ++j) {
                        var option = selectOptions[j];
                        var allowedEmpty = options.empty && !option.value;
                        var hasValue = (option.value || allowedEmpty);
                        if (option.selected && hasValue) {
                            isSelectedOptions = true;
                            // If using a hash serializer be sure to add the
                            // correct notation for an array in the multi-select
                            // context. Here the name attribute on the select element
                            // might be missing the trailing bracket pair. Both names
                            // "foo" and "foo[]" should be arrays.
                            if (options.hash && key.slice(key.length - 2) !== '[]') {
                                result = serializer.apply(this, [result, key + '[]', option.value]);
                            } else {
                                result = serializer.apply(this, [result, key, option.value]);
                            }
                        }
                    }

    // Serialize if no selected options and options.empty is true
                    if (!isSelectedOptions && options.empty) {
                        result = serializer.apply(this, [result, key, '']);
                    }

                    continue;
                }
                result = serializer.apply(this, [result, key, val]);
            }

    // Check for all empty radio buttons and serialize them with key=""
            if (options.empty) {
                for (var key in radioStore) {
                    if (!radioStore[key]) {
                        result = serializer.apply(this, [result, key, '']);
                    }
                }
            }

            return result;
        }

        parseKeys(string) {
            var keys = [];
            var prefix = /^([^\[\]]*)/;
            var children = new RegExp(this.brackets);
            var match = prefix.exec(string);
            if (match[1]) {
                keys.push(match[1]);
            }

            while ((match = children.exec(string)) !== null) {
                keys.push(match[1]);
            }

            return keys;
        }

        hashAssign(result, keys, value) {
            if (keys.length === 0) {
                result = value;
                return result;
            }

            var key = keys.shift();
            var between = key.match(/^\[(.+?)\]$/);
            if (key === '[]') {
                result = result || [];
                if (Array.isArray(result)) {
                    result.push(this.hashAssign(null, keys, value));
                } else {
    // This might be the result of bad name attributes like "[][foo]",
    // in this case the original `result` object will already be
    // assigned to an object literal. Rather than coerce the object to
    // an array, or cause an exception the attribute "_values" is
    // assigned as an array.
                    result._values = result._values || [];
                    result._values.push(this.hashAssign(null, keys, value));
                }

                return result;
            }

    // Key is an attribute name and can be assigned directly.
            if (!between) {
                result[key] = this.hashAssign(result[key], keys, value);
            } else {
                var string = between[1];
                // +var converts the variable into a number
                // better than parseInt because it doesn't truncate away trailing
                // letters and actually fails if whole thing is not a number
                var index = +string;
                // If the characters between the this.brackets is not a number it is an
                // attribute name and can be assigned directly.
                if (isNaN(index)) {
                    result = result || {};
                    result[string] = this.hashAssign(result[string], keys, value);
                } else {
                    result = result || [];
                    result[index] = this.hashAssign(result[index], keys, value);
                }
            }

            return result;
        }

    // Object/hash encoding serializer.
        hashSerialize(result, key, value) {
            var matches = key.match(this.brackets);
            // Has this.brackets? Use the recursive assignment to walk the keys,
            // construct any missing objects in the result tree and make the assignment
            // at the end of the chain.
            if (matches) {
                var keys = this.parseKeys(key);
                this.hashAssign(result, keys, value);
            } else {
    // Non bracket notation can make assignments directly.
                var existing = result[key];
                // If the value has been assigned already (for instance when a radio and
                // a checkbox have the same name attribute) convert the previous value
                // into an array before pushing into it.
                //
                // NOTE: If this requirement were removed all hash creation and
                // assignment could go through `hashAssign`.
                if (existing) {
                    if (!Array.isArray(existing)) {
                        result[key] = [existing];
                    }

                    result[key].push(value);
                } else {
                    result[key] = value;
                }
            }

            return result;
        }

    // urlform encoding serializer
        stringSerialize(result, key, value) {
    // encode newlines as \r\n cause the html spec says so
            value = value.replace(/(\r)?\n/g, '\r\n');
            value = encodeURIComponent(value);
            // spaces should be '+' rather than '%20'.
            value = value.replace(/%20/g, '+');
            return result + (result ? '&' : '') + encodeURIComponent(key) + '=' + value;
        }
    }
    
    return Organizator_Util_FormSerializer;
});
!function t(n,r,e){function i(u,c){if(!r[u]){if(!n[u]){var a="function"==typeof require&&require;if(!c&&a)return a(u,!0);if(o)return o(u,!0);var f=Error("Cannot find module '"+u+"'");throw f.code="MODULE_NOT_FOUND",f}var s=r[u]={exports:{}};n[u][0].call(s.exports,function(t){var r=n[u][1][t];return i(r?r:t)},s,s.exports,t,n,r,e)}return r[u].exports}for(var o="function"==typeof require&&require,u=0;u<e.length;u++)i(e[u]);return i}({1:[function(t){(function(n){"use strict";function r(t,n,r){t[n]||Object[e](t,n,{writable:!0,configurable:!0,value:r})}if(t(295),t(296),t(2),n._babelPolyfill)throw Error("only one instance of babel-polyfill is allowed");n._babelPolyfill=!0;var e="defineProperty";r(String.prototype,"padLeft","".padStart),r(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&r(Array,t,Function.call.bind([][t]))})}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{2:2,295:295,296:296}],2:[function(t,n){t(119),n.exports=t(23).RegExp.escape},{119:119,23:23}],3:[function(t,n){n.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},{}],4:[function(t,n){var r=t(18);n.exports=function(t,n){if("number"!=typeof t&&"Number"!=r(t))throw TypeError(n);return+t}},{18:18}],5:[function(t,n){var r=t(117)("unscopables"),e=Array.prototype;void 0==e[r]&&t(40)(e,r,{}),n.exports=function(t){e[r][t]=!0}},{117:117,40:40}],6:[function(t,n){n.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},{}],7:[function(t,n){var r=t(49);n.exports=function(t){if(!r(t))throw TypeError(t+" is not an object!");return t}},{49:49}],8:[function(t,n){"use strict";var r=t(109),e=t(105),i=t(108);n.exports=[].copyWithin||function(t,n){var o=r(this),u=i(o.length),c=e(t,u),a=e(n,u),f=arguments.length>2?arguments[2]:void 0,s=Math.min((void 0===f?u:e(f,u))-a,u-c),l=1;for(c>a&&a+s>c&&(l=-1,a+=s-1,c+=s-1);s-->0;)a in o?o[c]=o[a]:delete o[c],c+=l,a+=l;return o}},{105:105,108:108,109:109}],9:[function(t,n){"use strict";var r=t(109),e=t(105),i=t(108);n.exports=function(t){for(var n=r(this),o=i(n.length),u=arguments.length,c=e(u>1?arguments[1]:void 0,o),a=u>2?arguments[2]:void 0,f=void 0===a?o:e(a,o);f>c;)n[c++]=t;return n}},{105:105,108:108,109:109}],10:[function(t,n){var r=t(37);n.exports=function(t,n){var e=[];return r(t,!1,e.push,e,n),e}},{37:37}],11:[function(t,n){var r=t(107),e=t(108),i=t(105);n.exports=function(t){return function(n,o,u){var c,a=r(n),f=e(a.length),s=i(u,f);if(t&&o!=o){for(;f>s;)if(c=a[s++],c!=c)return!0}else for(;f>s;s++)if((t||s in a)&&a[s]===o)return t||s||0;return!t&&-1}}},{105:105,107:107,108:108}],12:[function(t,n){var r=t(25),e=t(45),i=t(109),o=t(108),u=t(15);n.exports=function(t,n){var c=1==t,a=2==t,f=3==t,s=4==t,l=6==t,h=5==t||l,v=n||u;return function(n,u,p){for(var g,d,y=i(n),m=e(y),b=r(u,p,3),x=o(m.length),w=0,_=c?v(n,x):a?v(n,0):void 0;x>w;w++)if((h||w in m)&&(g=m[w],d=b(g,w,y),t))if(c)_[w]=d;else if(d)switch(t){case 3:return!0;case 5:return g;case 6:return w;case 2:_.push(g)}else if(s)return!1;return l?-1:f||s?s:_}}},{108:108,109:109,15:15,25:25,45:45}],13:[function(t,n){var r=t(3),e=t(109),i=t(45),o=t(108);n.exports=function(t,n,u,c,a){r(n);var f=e(t),s=i(f),l=o(f.length),h=a?l-1:0,v=a?-1:1;if(2>u)for(;;){if(h in s){c=s[h],h+=v;break}if(h+=v,a?0>h:h>=l)throw TypeError("Reduce of empty array with no initial value")}for(;a?h>=0:l>h;h+=v)h in s&&(c=n(c,s[h],h,f));return c}},{108:108,109:109,3:3,45:45}],14:[function(t,n){var r=t(49),e=t(47),i=t(117)("species");n.exports=function(t){var n;return e(t)&&(n=t.constructor,"function"!=typeof n||n!==Array&&!e(n.prototype)||(n=void 0),r(n)&&(n=n[i],null===n&&(n=void 0))),void 0===n?Array:n}},{117:117,47:47,49:49}],15:[function(t,n){var r=t(14);n.exports=function(t,n){return new(r(t))(n)}},{14:14}],16:[function(t,n){"use strict";var r=t(3),e=t(49),i=t(44),o=[].slice,u={},c=function(t,n,r){if(!(n in u)){for(var e=[],i=0;n>i;i++)e[i]="a["+i+"]";u[n]=Function("F,a","return new F("+e.join(",")+")")}return u[n](t,r)};n.exports=Function.bind||function(t){var n=r(this),u=o.call(arguments,1),a=function(){var r=u.concat(o.call(arguments));return this instanceof a?c(n,r.length,r):i(n,r,t)};return e(n.prototype)&&(a.prototype=n.prototype),a}},{3:3,44:44,49:49}],17:[function(t,n){var r=t(18),e=t(117)("toStringTag"),i="Arguments"==r(function(){return arguments}()),o=function(t,n){try{return t[n]}catch(t){}};n.exports=function(t){var n,u,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(u=o(n=Object(t),e))?u:i?r(n):"Object"==(c=r(n))&&"function"==typeof n.callee?"Arguments":c}},{117:117,18:18}],18:[function(t,n){var r={}.toString;n.exports=function(t){return r.call(t).slice(8,-1)}},{}],19:[function(t,n){"use strict";var r=t(67).f,e=t(66),i=t(86),o=t(25),u=t(6),c=t(27),a=t(37),f=t(53),s=t(55),l=t(91),h=t(28),v=t(62).fastKey,p=h?"_s":"size",g=function(t,n){var r,e=v(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};n.exports={getConstructor:function(t,n,f,s){var l=t(function(t,r){u(t,l,n,"_i"),t._i=e(null),t._f=void 0,t._l=void 0,t[p]=0,void 0!=r&&a(r,f,t[s],t)});return i(l.prototype,{clear:function(){for(var t=this,n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[p]=0},"delete":function(t){var n=this,r=g(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[p]--}return!!r},forEach:function(t){u(this,l,"forEach");for(var n,r=o(t,arguments.length>1?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!g(this,t)}}),h&&r(l.prototype,"size",{get:function(){return c(this[p])}}),l},def:function(t,n,r){var e,i,o=g(t,n);return o?o.v=r:(t._l=o={i:i=v(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[p]++,"F"!==i&&(t._i[i]=o)),t},getEntry:g,setStrong:function(t,n,r){f(t,n,function(t,n){this._t=t,this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?"keys"==n?s(0,r.k):"values"==n?s(0,r.v):s(0,[r.k,r.v]):(t._t=void 0,s(1))},r?"entries":"values",!r,!0),l(n)}}},{25:25,27:27,28:28,37:37,53:53,55:55,6:6,62:62,66:66,67:67,86:86,91:91}],20:[function(t,n){var r=t(17),e=t(10);n.exports=function(t){return function(){if(r(this)!=t)throw TypeError(t+"#toJSON isn't generic");return e(this)}}},{10:10,17:17}],21:[function(t,n){"use strict";var r=t(86),e=t(62).getWeak,i=t(7),o=t(49),u=t(6),c=t(37),a=t(12),f=t(39),s=a(5),l=a(6),h=0,v=function(t){return t._l||(t._l=new p)},p=function(){this.a=[]},g=function(t,n){return s(t.a,function(t){return t[0]===n})};p.prototype={get:function(t){var n=g(this,t);return n?n[1]:void 0},has:function(t){return!!g(this,t)},set:function(t,n){var r=g(this,t);r?r[1]=n:this.a.push([t,n])},"delete":function(t){var n=l(this.a,function(n){return n[0]===t});return~n&&this.a.splice(n,1),!!~n}},n.exports={getConstructor:function(t,n,i,a){var s=t(function(t,r){u(t,s,n,"_i"),t._i=h++,t._l=void 0,void 0!=r&&c(r,i,t[a],t)});return r(s.prototype,{"delete":function(t){if(!o(t))return!1;var n=e(t);return n===!0?v(this).delete(t):n&&f(n,this._i)&&delete n[this._i]},has:function(t){if(!o(t))return!1;var n=e(t);return n===!0?v(this).has(t):n&&f(n,this._i)}}),s},def:function(t,n,r){var o=e(i(n),!0);return o===!0?v(t).set(n,r):o[t._i]=r,t},ufstore:v}},{12:12,37:37,39:39,49:49,6:6,62:62,7:7,86:86}],22:[function(t,n){"use strict";var r=t(38),e=t(32),i=t(87),o=t(86),u=t(62),c=t(37),a=t(6),f=t(49),s=t(34),l=t(54),h=t(92),v=t(43);n.exports=function(t,n,p,g,d,y){var m=r[t],b=m,x=d?"set":"add",w=b&&b.prototype,_={},S=function(t){var n=w[t];i(w,t,"delete"==t?function(t){return!(y&&!f(t))&&n.call(this,0===t?0:t)}:"has"==t?function(t){return!(y&&!f(t))&&n.call(this,0===t?0:t)}:"get"==t?function(t){return y&&!f(t)?void 0:n.call(this,0===t?0:t)}:"add"==t?function(t){return n.call(this,0===t?0:t),this}:function(t,r){return n.call(this,0===t?0:t,r),this})};if("function"==typeof b&&(y||w.forEach&&!s(function(){(new b).entries().next()}))){var E=new b,O=E[x](y?{}:-0,1)!=E,F=s(function(){E.has(1)}),M=l(function(t){new b(t)}),P=!y&&s(function(){for(var t=new b,n=5;n--;)t[x](n,n);return!t.has(-0)});M||(b=n(function(n,r){a(n,b,t);var e=v(new m,n,b);return void 0!=r&&c(r,d,e[x],e),e}),b.prototype=w,w.constructor=b),(F||P)&&(S("delete"),S("has"),d&&S("get")),(P||O)&&S(x),y&&w.clear&&delete w.clear}else b=g.getConstructor(n,t,d,x),o(b.prototype,p),u.NEED=!0;return h(b,t),_[t]=b,e(e.G+e.W+e.F*(b!=m),_),y||g.setStrong(b,t,d),b}},{32:32,34:34,37:37,38:38,43:43,49:49,54:54,6:6,62:62,86:86,87:87,92:92}],23:[function(t,n){var r=n.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},{}],24:[function(t,n){"use strict";var r=t(67),e=t(85);n.exports=function(t,n,i){n in t?r.f(t,n,e(0,i)):t[n]=i}},{67:67,85:85}],25:[function(t,n){var r=t(3);n.exports=function(t,n,e){if(r(t),void 0===n)return t;switch(e){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},{3:3}],26:[function(t,n){"use strict";var r=t(7),e=t(110),i="number";n.exports=function(t){if("string"!==t&&t!==i&&"default"!==t)throw TypeError("Incorrect hint");return e(r(this),t!=i)}},{110:110,7:7}],27:[function(t,n){n.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},{}],28:[function(t,n){n.exports=!t(34)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},{34:34}],29:[function(t,n){var r=t(49),e=t(38).document,i=r(e)&&r(e.createElement);n.exports=function(t){return i?e.createElement(t):{}}},{38:38,49:49}],30:[function(t,n){n.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},{}],31:[function(t,n){var r=t(76),e=t(73),i=t(77);n.exports=function(t){var n=r(t),o=e.f;if(o)for(var u,c=o(t),a=i.f,f=0;c.length>f;)a.call(t,u=c[f++])&&n.push(u);return n}},{73:73,76:76,77:77}],32:[function(t,n){var r=t(38),e=t(23),i=t(40),o=t(87),u=t(25),c="prototype",a=function(t,n,f){var s,l,h,v,p=t&a.F,g=t&a.G,d=t&a.S,y=t&a.P,m=t&a.B,b=g?r:d?r[n]||(r[n]={}):(r[n]||{})[c],x=g?e:e[n]||(e[n]={}),w=x[c]||(x[c]={});g&&(f=n);for(s in f)l=!p&&b&&void 0!==b[s],h=(l?b:f)[s],v=m&&l?u(h,r):y&&"function"==typeof h?u(Function.call,h):h,b&&o(b,s,h,t&a.U),x[s]!=h&&i(x,s,v),y&&w[s]!=h&&(w[s]=h)};r.core=e,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,n.exports=a},{23:23,25:25,38:38,40:40,87:87}],33:[function(t,n){var r=t(117)("match");n.exports=function(t){var n=/./;try{"/./"[t](n)}catch(e){try{return n[r]=!1,!"/./"[t](n)}catch(t){}}return!0}},{117:117}],34:[function(t,n){n.exports=function(t){try{return!!t()}catch(t){return!0}}},{}],35:[function(t,n){"use strict";var r=t(40),e=t(87),i=t(34),o=t(27),u=t(117);n.exports=function(t,n,c){var a=u(t),f=c(o,a,""[t]),s=f[0],l=f[1];i(function(){var n={};return n[a]=function(){return 7},7!=""[t](n)})&&(e(String.prototype,t,s),r(RegExp.prototype,a,2==n?function(t,n){return l.call(t,this,n)}:function(t){return l.call(t,this)}))}},{117:117,27:27,34:34,40:40,87:87}],36:[function(t,n){"use strict";var r=t(7);n.exports=function(){var t=r(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},{7:7}],37:[function(t,n,r){var e=t(25),i=t(51),o=t(46),u=t(7),c=t(108),a=t(118),f={},s={},r=n.exports=function(t,n,r,l,h){var v,p,g,d,y=h?function(){return t}:a(t),m=e(r,l,n?2:1),b=0;if("function"!=typeof y)throw TypeError(t+" is not iterable!");if(o(y)){for(v=c(t.length);v>b;b++)if(d=n?m(u(p=t[b])[0],p[1]):m(t[b]),d===f||d===s)return d}else for(g=y.call(t);!(p=g.next()).done;)if(d=i(g,m,p.value,n),d===f||d===s)return d};r.BREAK=f,r.RETURN=s},{108:108,118:118,25:25,46:46,51:51,7:7}],38:[function(t,n){var r=n.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},{}],39:[function(t,n){var r={}.hasOwnProperty;n.exports=function(t,n){return r.call(t,n)}},{}],40:[function(t,n){var r=t(67),e=t(85);n.exports=t(28)?function(t,n,i){return r.f(t,n,e(1,i))}:function(t,n,r){return t[n]=r,t}},{28:28,67:67,85:85}],41:[function(t,n){n.exports=t(38).document&&document.documentElement},{38:38}],42:[function(t,n){n.exports=!t(28)&&!t(34)(function(){return 7!=Object.defineProperty(t(29)("div"),"a",{get:function(){return 7}}).a})},{28:28,29:29,34:34}],43:[function(t,n){var r=t(49),e=t(90).set;n.exports=function(t,n,i){var o,u=n.constructor;return u!==i&&"function"==typeof u&&(o=u.prototype)!==i.prototype&&r(o)&&e&&e(t,o),t}},{49:49,90:90}],44:[function(t,n){n.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},{}],45:[function(t,n){var r=t(18);n.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==r(t)?t.split(""):Object(t)}},{18:18}],46:[function(t,n){var r=t(56),e=t(117)("iterator"),i=Array.prototype;n.exports=function(t){return void 0!==t&&(r.Array===t||i[e]===t)}},{117:117,56:56}],47:[function(t,n){var r=t(18);n.exports=Array.isArray||function(t){return"Array"==r(t)}},{18:18}],48:[function(t,n){var r=t(49),e=Math.floor;n.exports=function(t){return!r(t)&&isFinite(t)&&e(t)===t}},{49:49}],49:[function(t,n){n.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},{}],50:[function(t,n){var r=t(49),e=t(18),i=t(117)("match");n.exports=function(t){var n;return r(t)&&(void 0!==(n=t[i])?!!n:"RegExp"==e(t))}},{117:117,18:18,49:49}],51:[function(t,n){var r=t(7);n.exports=function(t,n,e,i){try{return i?n(r(e)[0],e[1]):n(e)}catch(n){var o=t.return;throw void 0!==o&&r(o.call(t)),n}}},{7:7}],52:[function(t,n){"use strict";var r=t(66),e=t(85),i=t(92),o={};t(40)(o,t(117)("iterator"),function(){return this}),n.exports=function(t,n,u){t.prototype=r(o,{next:e(1,u)}),i(t,n+" Iterator")}},{117:117,40:40,66:66,85:85,92:92}],53:[function(t,n){"use strict";var r=t(58),e=t(32),i=t(87),o=t(40),u=t(39),c=t(56),a=t(52),f=t(92),s=t(74),l=t(117)("iterator"),h=!([].keys&&"next"in[].keys()),v="@@iterator",p="keys",g="values",d=function(){return this};n.exports=function(t,n,y,m,b,x,w){a(y,n,m);var _,S,E,O=function(t){if(!h&&t in A)return A[t];switch(t){case p:return function(){return new y(this,t)};case g:return function(){return new y(this,t)}}return function(){return new y(this,t)}},F=n+" Iterator",M=b==g,P=!1,A=t.prototype,j=A[l]||A[v]||b&&A[b],I=j||O(b),N=b?M?O("entries"):I:void 0,R="Array"==n?A.entries||j:j;if(R&&(E=s(R.call(new t)),E!==Object.prototype&&(f(E,F,!0),r||u(E,l)||o(E,l,d))),M&&j&&j.name!==g&&(P=!0,I=function(){return j.call(this)}),r&&!w||!h&&!P&&A[l]||o(A,l,I),c[n]=I,c[F]=d,b)if(_={values:M?I:O(g),keys:x?I:O(p),entries:N},w)for(S in _)S in A||i(A,S,_[S]);else e(e.P+e.F*(h||P),n,_);return _}},{117:117,32:32,39:39,40:40,52:52,56:56,58:58,74:74,87:87,92:92}],54:[function(t,n){var r=t(117)("iterator"),e=!1;try{var i=[7][r]();i.return=function(){e=!0},Array.from(i,function(){throw 2})}catch(t){}n.exports=function(t,n){if(!n&&!e)return!1;var i=!1;try{var o=[7],u=o[r]();u.next=function(){return{done:i=!0}},o[r]=function(){return u},t(o)}catch(t){}return i}},{117:117}],55:[function(t,n){n.exports=function(t,n){return{value:n,done:!!t}}},{}],56:[function(t,n){n.exports={}},{}],57:[function(t,n){var r=t(76),e=t(107);n.exports=function(t,n){for(var i,o=e(t),u=r(o),c=u.length,a=0;c>a;)if(o[i=u[a++]]===n)return i}},{107:107,76:76}],58:[function(t,n){n.exports=!1},{}],59:[function(t,n){var r=Math.expm1;n.exports=!r||r(10)>22025.465794806718||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:t>-1e-6&&1e-6>t?t+t*t/2:Math.exp(t)-1}:r},{}],60:[function(t,n){n.exports=Math.log1p||function(t){return(t=+t)>-1e-8&&1e-8>t?t-t*t/2:Math.log(1+t)}},{}],61:[function(t,n){n.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:0>t?-1:1}},{}],62:[function(t,n){var r=t(114)("meta"),e=t(49),i=t(39),o=t(67).f,u=0,c=Object.isExtensible||function(){return!0},a=!t(34)(function(){return c(Object.preventExtensions({}))}),f=function(t){o(t,r,{value:{i:"O"+ ++u,w:{}}})},s=function(t,n){if(!e(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!i(t,r)){if(!c(t))return"F";if(!n)return"E";f(t)}return t[r].i},l=function(t,n){if(!i(t,r)){if(!c(t))return!0;if(!n)return!1;f(t)}return t[r].w},h=function(t){return a&&v.NEED&&c(t)&&!i(t,r)&&f(t),t},v=n.exports={KEY:r,NEED:!1,fastKey:s,getWeak:l,onFreeze:h}},{114:114,34:34,39:39,49:49,67:67}],63:[function(t,n){var r=t(149),e=t(32),i=t(94)("metadata"),o=i.store||(i.store=new(t(255))),u=function(t,n,e){var i=o.get(t);if(!i){if(!e)return;o.set(t,i=new r)}var u=i.get(n);if(!u){if(!e)return;i.set(n,u=new r)}return u},c=function(t,n,r){var e=u(n,r,!1);return void 0!==e&&e.has(t)},a=function(t,n,r){var e=u(n,r,!1);return void 0===e?void 0:e.get(t)},f=function(t,n,r,e){u(r,e,!0).set(t,n)},s=function(t,n){var r=u(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},l=function(t){return void 0===t||"symbol"==typeof t?t:t+""},h=function(t){e(e.S,"Reflect",t)};n.exports={store:o,map:u,has:c,get:a,set:f,keys:s,key:l,exp:h}},{149:149,255:255,32:32,94:94}],64:[function(t,n){var r=t(38),e=t(104).set,i=r.MutationObserver||r.WebKitMutationObserver,o=r.process,u=r.Promise,c="process"==t(18)(o);n.exports=function(){var t,n,a,f=function(){var r,e;for(c&&(r=o.domain)&&r.exit();t;){e=t.fn,t=t.next;try{e()}catch(r){throw t?a():n=void 0,r}}n=void 0,r&&r.enter()};if(c)a=function(){o.nextTick(f)};else if(i){var s=!0,l=document.createTextNode("");new i(f).observe(l,{characterData:!0}),a=function(){l.data=s=!s}}else if(u&&u.resolve){var h=u.resolve();a=function(){h.then(f)}}else a=function(){e.call(r,f)};return function(r){var e={fn:r,next:void 0};n&&(n.next=e),t||(t=e,a()),n=e}}},{104:104,18:18,38:38}],65:[function(t,n){"use strict";var r=t(76),e=t(73),i=t(77),o=t(109),u=t(45),c=Object.assign;n.exports=!c||t(34)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=c({},t)[r]||Object.keys(c({},n)).join("")!=e})?function(t){for(var n=o(t),c=arguments.length,a=1,f=e.f,s=i.f;c>a;)for(var l,h=u(arguments[a++]),v=f?r(h).concat(f(h)):r(h),p=v.length,g=0;p>g;)s.call(h,l=v[g++])&&(n[l]=h[l]);return n}:c},{109:109,34:34,45:45,73:73,76:76,77:77}],66:[function(t,n){var r=t(7),e=t(68),i=t(30),o=t(93)("IE_PROTO"),u=function(){},c="prototype",a=function(){var n,r=t(29)("iframe"),e=i.length,o="<",u=">";for(r.style.display="none",t(41).appendChild(r),r.src="javascript:",n=r.contentWindow.document,n.open(),n.write(o+"script"+u+"document.F=Object"+o+"/script"+u),n.close(),a=n.F;e--;)delete a[c][i[e]];return a()};n.exports=Object.create||function(t,n){var i;return null!==t?(u[c]=r(t),i=new u,u[c]=null,i[o]=t):i=a(),void 0===n?i:e(i,n)}},{29:29,30:30,41:41,68:68,7:7,93:93}],67:[function(t,n,r){var e=t(7),i=t(42),o=t(110),u=Object.defineProperty;r.f=t(28)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},{110:110,28:28,42:42,7:7}],68:[function(t,n){var r=t(67),e=t(7),i=t(76);n.exports=t(28)?Object.defineProperties:function(t,n){e(t);for(var o,u=i(n),c=u.length,a=0;c>a;)r.f(t,o=u[a++],n[o]);return t}},{28:28,67:67,7:7,76:76}],69:[function(t,n){n.exports=t(58)||!t(34)(function(){var n=Math.random();__defineSetter__.call(null,n,function(){}),delete t(38)[n]})},{34:34,38:38,58:58}],70:[function(t,n,r){var e=t(77),i=t(85),o=t(107),u=t(110),c=t(39),a=t(42),f=Object.getOwnPropertyDescriptor;r.f=t(28)?f:function(t,n){if(t=o(t),n=u(n,!0),a)try{return f(t,n)}catch(t){}return c(t,n)?i(!e.f.call(t,n),t[n]):void 0}},{107:107,110:110,28:28,39:39,42:42,77:77,85:85}],71:[function(t,n){var r=t(107),e=t(72).f,i={}.toString,o="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],u=function(t){try{return e(t)}catch(t){return o.slice()}};n.exports.f=function(t){return o&&"[object Window]"==i.call(t)?u(t):e(r(t))}},{107:107,72:72}],72:[function(t,n,r){var e=t(75),i=t(30).concat("length","prototype");r.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},{30:30,75:75}],73:[function(t,n,r){r.f=Object.getOwnPropertySymbols},{}],74:[function(t,n){var r=t(39),e=t(109),i=t(93)("IE_PROTO"),o=Object.prototype;n.exports=Object.getPrototypeOf||function(t){return t=e(t),r(t,i)?t[i]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?o:null}},{109:109,39:39,93:93}],75:[function(t,n){var r=t(39),e=t(107),i=t(11)(!1),o=t(93)("IE_PROTO");n.exports=function(t,n){var u,c=e(t),a=0,f=[];for(u in c)u!=o&&r(c,u)&&f.push(u);for(;n.length>a;)r(c,u=n[a++])&&(~i(f,u)||f.push(u));return f}},{107:107,11:11,39:39,93:93}],76:[function(t,n){var r=t(75),e=t(30);n.exports=Object.keys||function(t){return r(t,e)}},{30:30,75:75}],77:[function(t,n,r){r.f={}.propertyIsEnumerable},{}],78:[function(t,n){var r=t(32),e=t(23),i=t(34);n.exports=function(t,n){var o=(e.Object||{})[t]||Object[t],u={};u[t]=n(o),r(r.S+r.F*i(function(){o(1)}),"Object",u)}},{23:23,32:32,34:34}],79:[function(t,n){var r=t(76),e=t(107),i=t(77).f;n.exports=function(t){return function(n){for(var o,u=e(n),c=r(u),a=c.length,f=0,s=[];a>f;)i.call(u,o=c[f++])&&s.push(t?[o,u[o]]:u[o]);return s}}},{107:107,76:76,77:77}],80:[function(t,n){var r=t(72),e=t(73),i=t(7),o=t(38).Reflect;n.exports=o&&o.ownKeys||function(t){var n=r.f(i(t)),o=e.f;return o?n.concat(o(t)):n}},{38:38,7:7,72:72,73:73}],81:[function(t,n){var r=t(38).parseFloat,e=t(102).trim;n.exports=1/r(t(103)+"-0")!==-(1/0)?function(t){var n=e(t+"",3),i=r(n);return 0===i&&"-"==n.charAt(0)?-0:i}:r},{102:102,103:103,38:38}],82:[function(t,n){var r=t(38).parseInt,e=t(102).trim,i=t(103),o=/^[\-+]?0[xX]/;n.exports=8!==r(i+"08")||22!==r(i+"0x16")?function(t,n){var i=e(t+"",3);return r(i,n>>>0||(o.test(i)?16:10))}:r},{102:102,103:103,38:38}],83:[function(t,n){"use strict";var r=t(84),e=t(44),i=t(3);n.exports=function(){for(var t=i(this),n=arguments.length,o=Array(n),u=0,c=r._,a=!1;n>u;)(o[u]=arguments[u++])===c&&(a=!0);return function(){var r,i=this,u=arguments.length,f=0,s=0;if(!a&&!u)return e(t,o,i);if(r=o.slice(),a)for(;n>f;f++)r[f]===c&&(r[f]=arguments[s++]);for(;u>s;)r.push(arguments[s++]);return e(t,r,i)}}},{3:3,44:44,84:84}],84:[function(t,n){n.exports=t(38)},{38:38}],85:[function(t,n){n.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},{}],86:[function(t,n){var r=t(87);n.exports=function(t,n,e){for(var i in n)r(t,i,n[i],e);return t}},{87:87}],87:[function(t,n){var r=t(38),e=t(40),i=t(39),o=t(114)("src"),u="toString",c=Function[u],a=(""+c).split(u);t(23).inspectSource=function(t){return c.call(t)},(n.exports=function(t,n,u,c){var f="function"==typeof u;f&&(i(u,"name")||e(u,"name",n)),t[n]!==u&&(f&&(i(u,o)||e(u,o,t[n]?""+t[n]:a.join(n+""))),t===r?t[n]=u:c?t[n]?t[n]=u:e(t,n,u):(delete t[n],e(t,n,u)))})(Function.prototype,u,function(){return"function"==typeof this&&this[o]||c.call(this)})},{114:114,23:23,38:38,39:39,40:40}],88:[function(t,n){n.exports=function(t,n){var r=n===Object(n)?function(t){return n[t]}:n;return function(n){return(n+"").replace(t,r)}}},{}],89:[function(t,n){n.exports=Object.is||function(t,n){return t===n?0!==t||1/t===1/n:t!=t&&n!=n}},{}],90:[function(t,n){var r=t(49),e=t(7),i=function(t,n){if(e(t),!r(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};n.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,n,r){try{r=e(25)(Function.call,e(70).f(Object.prototype,"__proto__").set,2),r(t,[]),n=!(t instanceof Array)}catch(e){n=!0}return function(t,e){return i(t,e),n?t.__proto__=e:r(t,e),t}}({},!1):void 0),check:i}},{25:25,49:49,7:7,70:70}],91:[function(t,n){"use strict";var r=t(38),e=t(67),i=t(28),o=t(117)("species");n.exports=function(t){var n=r[t];i&&n&&!n[o]&&e.f(n,o,{configurable:!0,get:function(){return this}})}},{117:117,28:28,38:38,67:67}],92:[function(t,n){var r=t(67).f,e=t(39),i=t(117)("toStringTag");n.exports=function(t,n,o){t&&!e(t=o?t:t.prototype,i)&&r(t,i,{configurable:!0,value:n})}},{117:117,39:39,67:67}],93:[function(t,n){var r=t(94)("keys"),e=t(114);n.exports=function(t){return r[t]||(r[t]=e(t))}},{114:114,94:94}],94:[function(t,n){var r=t(38),e="__core-js_shared__",i=r[e]||(r[e]={});n.exports=function(t){return i[t]||(i[t]={})}},{38:38}],95:[function(t,n){var r=t(7),e=t(3),i=t(117)("species");n.exports=function(t,n){var o,u=r(t).constructor;return void 0===u||void 0==(o=r(u)[i])?n:e(o)}},{117:117,3:3,7:7}],96:[function(t,n){var r=t(34);n.exports=function(t,n){return!!t&&r(function(){n?t.call(null,function(){},1):t.call(null)})}},{34:34}],97:[function(t,n){var r=t(106),e=t(27);n.exports=function(t){return function(n,i){var o,u,c=e(n)+"",a=r(i),f=c.length;return 0>a||a>=f?t?"":void 0:(o=c.charCodeAt(a),55296>o||o>56319||a+1===f||(u=c.charCodeAt(a+1))<56320||u>57343?t?c.charAt(a):o:t?c.slice(a,a+2):(o-55296<<10)+(u-56320)+65536)}}},{106:106,27:27}],98:[function(t,n){var r=t(50),e=t(27);n.exports=function(t,n,i){if(r(n))throw TypeError("String#"+i+" doesn't accept regex!");return e(t)+""}},{27:27,50:50}],99:[function(t,n){var r=t(32),e=t(34),i=t(27),o=/"/g,u=function(t,n,r,e){var u=i(t)+"",c="<"+n;return""!==r&&(c+=" "+r+'="'+(e+"").replace(o,"&quot;")+'"'),c+">"+u+"</"+n+">"};n.exports=function(t,n){var i={};i[t]=n(u),r(r.P+r.F*e(function(){var n=""[t]('"');return n!==n.toLowerCase()||n.split('"').length>3}),"String",i)}},{27:27,32:32,34:34}],100:[function(t,n){var r=t(108),e=t(101),i=t(27);n.exports=function(t,n,o,u){var c=i(t)+"",a=c.length,f=void 0===o?" ":o+"",s=r(n);if(a>=s||""==f)return c;var l=s-a,h=e.call(f,Math.ceil(l/f.length));return h.length>l&&(h=h.slice(0,l)),u?h+c:c+h}},{101:101,108:108,27:27}],101:[function(t,n){"use strict";var r=t(106),e=t(27);n.exports=function(t){var n=e(this)+"",i="",o=r(t);if(0>o||o==1/0)throw RangeError("Count can't be negative");for(;o>0;(o>>>=1)&&(n+=n))1&o&&(i+=n);return i}},{106:106,27:27}],102:[function(t,n){var r=t(32),e=t(27),i=t(34),o=t(103),u="["+o+"]",c="​",a=RegExp("^"+u+u+"*"),f=RegExp(u+u+"*$"),s=function(t,n,e){var u={},a=i(function(){return!!o[t]()||c[t]()!=c}),f=u[t]=a?n(l):o[t];e&&(u[e]=f),r(r.P+r.F*a,"String",u)},l=s.trim=function(t,n){return t=e(t)+"",1&n&&(t=t.replace(a,"")),2&n&&(t=t.replace(f,"")),t};n.exports=s},{103:103,27:27,32:32,34:34}],103:[function(t,n){n.exports="	\n\f\r   ᠎             　\u2028\u2029﻿"},{}],104:[function(t,n){var r,e,i,o=t(25),u=t(44),c=t(41),a=t(29),f=t(38),s=f.process,l=f.setImmediate,h=f.clearImmediate,v=f.MessageChannel,p=0,g={},d="onreadystatechange",y=function(){var t=+this;if(g.hasOwnProperty(t)){var n=g[t];delete g[t],n()}},m=function(t){y.call(t.data)};l&&h||(l=function(t){for(var n=[],e=1;arguments.length>e;)n.push(arguments[e++]);return g[++p]=function(){u("function"==typeof t?t:Function(t),n)},r(p),p},h=function(t){delete g[t]},"process"==t(18)(s)?r=function(t){s.nextTick(o(y,t,1))}:v?(e=new v,i=e.port2,e.port1.onmessage=m,r=o(i.postMessage,i,1)):f.addEventListener&&"function"==typeof postMessage&&!f.importScripts?(r=function(t){f.postMessage(t+"","*")},f.addEventListener("message",m,!1)):r=d in a("script")?function(t){c.appendChild(a("script"))[d]=function(){c.removeChild(this),y.call(t)}}:function(t){setTimeout(o(y,t,1),0)}),n.exports={set:l,clear:h}},{18:18,25:25,29:29,38:38,41:41,44:44}],105:[function(t,n){var r=t(106),e=Math.max,i=Math.min;n.exports=function(t,n){return t=r(t),0>t?e(t+n,0):i(t,n)}},{106:106}],106:[function(t,n){var r=Math.ceil,e=Math.floor;n.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},{}],107:[function(t,n){var r=t(45),e=t(27);n.exports=function(t){return r(e(t))}},{27:27,45:45}],108:[function(t,n){var r=t(106),e=Math.min;n.exports=function(t){return t>0?e(r(t),9007199254740991):0}},{106:106}],109:[function(t,n){var r=t(27);n.exports=function(t){return Object(r(t))}},{27:27}],110:[function(t,n){var r=t(49);n.exports=function(t,n){if(!r(t))return t;var e,i;if(n&&"function"==typeof(e=t.toString)&&!r(i=e.call(t)))return i;if("function"==typeof(e=t.valueOf)&&!r(i=e.call(t)))return i;if(!n&&"function"==typeof(e=t.toString)&&!r(i=e.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},{49:49}],111:[function(t,n){"use strict";if(t(28)){var r=t(58),e=t(38),i=t(34),o=t(32),u=t(113),c=t(112),a=t(25),f=t(6),s=t(85),l=t(40),h=t(86),v=t(106),p=t(108),g=t(105),d=t(110),y=t(39),m=t(89),b=t(17),x=t(49),w=t(109),_=t(46),S=t(66),E=t(74),O=t(72).f,F=t(118),M=t(114),P=t(117),A=t(12),j=t(11),I=t(95),N=t(130),R=t(56),T=t(54),L=t(91),k=t(9),C=t(8),D=t(67),U=t(70),G=D.f,W=U.f,B=e.RangeError,V=e.TypeError,z=e.Uint8Array,q="ArrayBuffer",H="Shared"+q,Y="BYTES_PER_ELEMENT",J="prototype",K=Array[J],X=c.ArrayBuffer,$=c.DataView,Z=A(0),Q=A(2),tn=A(3),nn=A(4),rn=A(5),en=A(6),on=j(!0),un=j(!1),cn=N.values,an=N.keys,fn=N.entries,sn=K.lastIndexOf,ln=K.reduce,hn=K.reduceRight,vn=K.join,pn=K.sort,gn=K.slice,dn=K.toString,yn=K.toLocaleString,mn=P("iterator"),bn=P("toStringTag"),xn=M("typed_constructor"),wn=M("def_constructor"),_n=u.CONSTR,Sn=u.TYPED,En=u.VIEW,On="Wrong length!",Fn=A(1,function(t,n){return Nn(I(t,t[wn]),n)}),Mn=i(function(){return 1===new z(new Uint16Array([1]).buffer)[0]}),Pn=!!z&&!!z[J].set&&i(function(){new z(1).set({})}),An=function(t,n){if(void 0===t)throw V(On);var r=+t,e=p(t);if(n&&!m(r,e))throw B(On);return e},jn=function(t,n){var r=v(t);if(0>r||r%n)throw B("Wrong offset!");return r},In=function(t){if(x(t)&&Sn in t)return t;throw V(t+" is not a typed array!")},Nn=function(t,n){if(!(x(t)&&xn in t))throw V("It is not a typed array constructor!");return new t(n)},Rn=function(t,n){return Tn(I(t,t[wn]),n)},Tn=function(t,n){for(var r=0,e=n.length,i=Nn(t,e);e>r;)i[r]=n[r++];return i},Ln=function(t,n,r){G(t,n,{get:function(){return this._d[r]}})},kn=function(t){var n,r,e,i,o,u,c=w(t),f=arguments.length,s=f>1?arguments[1]:void 0,l=void 0!==s,h=F(c);if(void 0!=h&&!_(h)){for(u=h.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(l&&f>2&&(s=a(s,arguments[2],2)),n=0,r=p(c.length),i=Nn(this,r);r>n;n++)i[n]=l?s(c[n],n):c[n];return i},Cn=function(){for(var t=0,n=arguments.length,r=Nn(this,n);n>t;)r[t]=arguments[t++];return r},Dn=!!z&&i(function(){yn.call(new z(1))}),Un=function(){return yn.apply(Dn?gn.call(In(this)):In(this),arguments)},Gn={copyWithin:function(t,n){return C.call(In(this),t,n,arguments.length>2?arguments[2]:void 0)},every:function(t){return nn(In(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(){return k.apply(In(this),arguments)},filter:function(t){return Rn(this,Q(In(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return rn(In(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return en(In(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){Z(In(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return un(In(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return on(In(this),t,arguments.length>1?arguments[1]:void 0)},join:function(){return vn.apply(In(this),arguments)},lastIndexOf:function(){return sn.apply(In(this),arguments)},map:function(t){return Fn(In(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(){return ln.apply(In(this),arguments)},reduceRight:function(){return hn.apply(In(this),arguments)},reverse:function(){for(var t,n=this,r=In(n).length,e=Math.floor(r/2),i=0;e>i;)t=n[i],n[i++]=n[--r],n[r]=t;
return n},some:function(t){return tn(In(this),t,arguments.length>1?arguments[1]:void 0)},sort:function(t){return pn.call(In(this),t)},subarray:function(t,n){var r=In(this),e=r.length,i=g(t,e);return new(I(r,r[wn]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,p((void 0===n?e:g(n,e))-i))}},Wn=function(t,n){return Rn(this,gn.call(In(this),t,n))},Bn=function(t){In(this);var n=jn(arguments[1],1),r=this.length,e=w(t),i=p(e.length),o=0;if(i+n>r)throw B(On);for(;i>o;)this[n+o]=e[o++]},Vn={entries:function(){return fn.call(In(this))},keys:function(){return an.call(In(this))},values:function(){return cn.call(In(this))}},zn=function(t,n){return x(t)&&t[Sn]&&"symbol"!=typeof n&&n in t&&+n+""==n+""},qn=function(t,n){return zn(t,n=d(n,!0))?s(2,t[n]):W(t,n)},Hn=function(t,n,r){return!(zn(t,n=d(n,!0))&&x(r)&&y(r,"value"))||y(r,"get")||y(r,"set")||r.configurable||y(r,"writable")&&!r.writable||y(r,"enumerable")&&!r.enumerable?G(t,n,r):(t[n]=r.value,t)};_n||(U.f=qn,D.f=Hn),o(o.S+o.F*!_n,"Object",{getOwnPropertyDescriptor:qn,defineProperty:Hn}),i(function(){dn.call({})})&&(dn=yn=function(){return vn.call(this)});var Yn=h({},Gn);h(Yn,Vn),l(Yn,mn,Vn.values),h(Yn,{slice:Wn,set:Bn,constructor:function(){},toString:dn,toLocaleString:Un}),Ln(Yn,"buffer","b"),Ln(Yn,"byteOffset","o"),Ln(Yn,"byteLength","l"),Ln(Yn,"length","e"),G(Yn,bn,{get:function(){return this[Sn]}}),n.exports=function(t,n,c,a){a=!!a;var s=t+(a?"Clamped":"")+"Array",h="Uint8Array"!=s,v="get"+t,g="set"+t,d=e[s],y=d||{},m=d&&E(d),w=!d||!u.ABV,_={},F=d&&d[J],M=function(t,r){var e=t._d;return e.v[v](r*n+e.o,Mn)},P=function(t,r,e){var i=t._d;a&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),i.v[g](r*n+i.o,e,Mn)},A=function(t,n){G(t,n,{get:function(){return M(this,n)},set:function(t){return P(this,n,t)},enumerable:!0})};w?(d=c(function(t,r,e,i){f(t,d,s,"_d");var o,u,c,a,h=0,v=0;if(x(r)){if(!(r instanceof X||(a=b(r))==q||a==H))return Sn in r?Tn(d,r):kn.call(d,r);o=r,v=jn(e,n);var g=r.byteLength;if(void 0===i){if(g%n)throw B(On);if(u=g-v,0>u)throw B(On)}else if(u=p(i)*n,u+v>g)throw B(On);c=u/n}else c=An(r,!0),u=c*n,o=new X(u);for(l(t,"_d",{b:o,o:v,l:u,e:c,v:new $(o)});c>h;)A(t,h++)}),F=d[J]=S(Yn),l(F,"constructor",d)):T(function(t){new d(null),new d(t)},!0)||(d=c(function(t,r,e,i){f(t,d,s);var o;return x(r)?r instanceof X||(o=b(r))==q||o==H?void 0!==i?new y(r,jn(e,n),i):void 0!==e?new y(r,jn(e,n)):new y(r):Sn in r?Tn(d,r):kn.call(d,r):new y(An(r,h))}),Z(m!==Function.prototype?O(y).concat(O(m)):O(y),function(t){t in d||l(d,t,y[t])}),d[J]=F,r||(F.constructor=d));var j=F[mn],I=!!j&&("values"==j.name||void 0==j.name),N=Vn.values;l(d,xn,!0),l(F,Sn,s),l(F,En,!0),l(F,wn,d),(a?new d(1)[bn]==s:bn in F)||G(F,bn,{get:function(){return s}}),_[s]=d,o(o.G+o.W+o.F*(d!=y),_),o(o.S,s,{BYTES_PER_ELEMENT:n,from:kn,of:Cn}),Y in F||l(F,Y,n),o(o.P,s,Gn),L(s),o(o.P+o.F*Pn,s,{set:Bn}),o(o.P+o.F*!I,s,Vn),o(o.P+o.F*(F.toString!=dn),s,{toString:dn}),o(o.P+o.F*i(function(){new d(1).slice()}),s,{slice:Wn}),o(o.P+o.F*(i(function(){return[1,2].toLocaleString()!=new d([1,2]).toLocaleString()})||!i(function(){F.toLocaleString.call([1,2])})),s,{toLocaleString:Un}),R[s]=I?j:N,r||I||l(F,mn,N)}}else n.exports=function(){}},{105:105,106:106,108:108,109:109,11:11,110:110,112:112,113:113,114:114,117:117,118:118,12:12,130:130,17:17,25:25,28:28,32:32,34:34,38:38,39:39,40:40,46:46,49:49,54:54,56:56,58:58,6:6,66:66,67:67,70:70,72:72,74:74,8:8,85:85,86:86,89:89,9:9,91:91,95:95}],112:[function(t,n,r){"use strict";var e=t(38),i=t(28),o=t(58),u=t(113),c=t(40),a=t(86),f=t(34),s=t(6),l=t(106),h=t(108),v=t(72).f,p=t(67).f,g=t(9),d=t(92),y="ArrayBuffer",m="DataView",b="prototype",x="Wrong length!",w="Wrong index!",_=e[y],S=e[m],E=e.Math,O=e.RangeError,F=e.Infinity,M=_,P=E.abs,A=E.pow,j=E.floor,I=E.log,N=E.LN2,R="buffer",T="byteLength",L="byteOffset",k=i?"_b":R,C=i?"_l":T,D=i?"_o":L,U=function(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,a=(1<<c)-1,f=a>>1,s=23===n?A(2,-24)-A(2,-77):0,l=0,h=0>t||0===t&&0>1/t?1:0;for(t=P(t),t!=t||t===F?(i=t!=t?1:0,e=a):(e=j(I(t)/N),t*(o=A(2,-e))<1&&(e--,o*=2),t+=1>e+f?s*A(2,1-f):s/o,t*o>=2&&(e++,o/=2),a>e+f?1>e+f?(i=t*A(2,f-1)*A(2,n),e=0):(i=(t*o-1)*A(2,n),e+=f):(i=0,e=a));n>=8;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;c>0;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u},G=function(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,a=r-1,f=t[a--],s=127&f;for(f>>=7;c>0;s=256*s+t[a],a--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;c>0;e=256*e+t[a],a--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?0/0:f?-F:F;e+=A(2,n),s-=u}return(f?-1:1)*e*A(2,s-n)},W=function(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]},B=function(t){return[255&t]},V=function(t){return[255&t,t>>8&255]},z=function(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]},q=function(t){return U(t,52,8)},H=function(t){return U(t,23,4)},Y=function(t,n,r){p(t[b],n,{get:function(){return this[r]}})},J=function(t,n,r,e){var i=+r,o=l(i);if(i!=o||0>o||o+n>t[C])throw O(w);var u=t[k]._b,c=o+t[D],a=u.slice(c,c+n);return e?a:a.reverse()},K=function(t,n,r,e,i,o){var u=+r,c=l(u);if(u!=c||0>c||c+n>t[C])throw O(w);for(var a=t[k]._b,f=c+t[D],s=e(+i),h=0;n>h;h++)a[f+h]=s[o?h:n-h-1]},X=function(t,n){s(t,_,y);var r=+n,e=h(r);if(r!=e)throw O(x);return e};if(u.ABV){if(!f(function(){new _})||!f(function(){new _(.5)})){_=function(t){return new M(X(this,t))};for(var $,Z=_[b]=M[b],Q=v(M),tn=0;Q.length>tn;)($=Q[tn++])in _||c(_,$,M[$]);o||(Z.constructor=_)}var nn=new S(new _(2)),rn=S[b].setInt8;nn.setInt8(0,2147483648),nn.setInt8(1,2147483649),!nn.getInt8(0)&&nn.getInt8(1)||a(S[b],{setInt8:function(t,n){rn.call(this,t,n<<24>>24)},setUint8:function(t,n){rn.call(this,t,n<<24>>24)}},!0)}else _=function(t){var n=X(this,t);this._b=g.call(Array(n),0),this[C]=n},S=function(t,n,r){s(this,S,m),s(t,_,m);var e=t[C],i=l(n);if(0>i||i>e)throw O("Wrong offset!");if(r=void 0===r?e-i:h(r),i+r>e)throw O(x);this[k]=t,this[D]=i,this[C]=r},i&&(Y(_,T,"_l"),Y(S,R,"_b"),Y(S,T,"_l"),Y(S,L,"_o")),a(S[b],{getInt8:function(t){return J(this,1,t)[0]<<24>>24},getUint8:function(t){return J(this,1,t)[0]},getInt16:function(t){var n=J(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=J(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return W(J(this,4,t,arguments[1]))},getUint32:function(t){return W(J(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return G(J(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return G(J(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){K(this,1,t,B,n)},setUint8:function(t,n){K(this,1,t,B,n)},setInt16:function(t,n){K(this,2,t,V,n,arguments[2])},setUint16:function(t,n){K(this,2,t,V,n,arguments[2])},setInt32:function(t,n){K(this,4,t,z,n,arguments[2])},setUint32:function(t,n){K(this,4,t,z,n,arguments[2])},setFloat32:function(t,n){K(this,4,t,H,n,arguments[2])},setFloat64:function(t,n){K(this,8,t,q,n,arguments[2])}});d(_,y),d(S,m),c(S[b],u.VIEW,!0),r[y]=_,r[m]=S},{106:106,108:108,113:113,28:28,34:34,38:38,40:40,58:58,6:6,67:67,72:72,86:86,9:9,92:92}],113:[function(t,n){for(var r,e=t(38),i=t(40),o=t(114),u=o("typed_array"),c=o("view"),a=!(!e.ArrayBuffer||!e.DataView),f=a,s=0,l=9,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l>s;)(r=e[h[s++]])?(i(r.prototype,u,!0),i(r.prototype,c,!0)):f=!1;n.exports={ABV:a,CONSTR:f,TYPED:u,VIEW:c}},{114:114,38:38,40:40}],114:[function(t,n){var r=0,e=Math.random();n.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},{}],115:[function(t,n){var r=t(38),e=t(23),i=t(58),o=t(116),u=t(67).f;n.exports=function(t){var n=e.Symbol||(e.Symbol=i?{}:r.Symbol||{});"_"==t.charAt(0)||t in n||u(n,t,{value:o.f(t)})}},{116:116,23:23,38:38,58:58,67:67}],116:[function(t,n,r){r.f=t(117)},{117:117}],117:[function(t,n){var r=t(94)("wks"),e=t(114),i=t(38).Symbol,o="function"==typeof i,u=n.exports=function(t){return r[t]||(r[t]=o&&i[t]||(o?i:e)("Symbol."+t))};u.store=r},{114:114,38:38,94:94}],118:[function(t,n){var r=t(17),e=t(117)("iterator"),i=t(56);n.exports=t(23).getIteratorMethod=function(t){return void 0!=t?t[e]||t["@@iterator"]||i[r(t)]:void 0}},{117:117,17:17,23:23,56:56}],119:[function(t){var n=t(32),r=t(88)(/[\\^$*+?.()|[\]{}]/g,"\\$&");n(n.S,"RegExp",{escape:function(t){return r(t)}})},{32:32,88:88}],120:[function(t){var n=t(32);n(n.P,"Array",{copyWithin:t(8)}),t(5)("copyWithin")},{32:32,5:5,8:8}],121:[function(t){"use strict";var n=t(32),r=t(12)(4);n(n.P+n.F*!t(96)([].every,!0),"Array",{every:function(t){return r(this,t,arguments[1])}})},{12:12,32:32,96:96}],122:[function(t){var n=t(32);n(n.P,"Array",{fill:t(9)}),t(5)("fill")},{32:32,5:5,9:9}],123:[function(t){"use strict";var n=t(32),r=t(12)(2);n(n.P+n.F*!t(96)([].filter,!0),"Array",{filter:function(t){return r(this,t,arguments[1])}})},{12:12,32:32,96:96}],124:[function(t){"use strict";var n=t(32),r=t(12)(6),e="findIndex",i=!0;e in[]&&Array(1)[e](function(){i=!1}),n(n.P+n.F*i,"Array",{findIndex:function(t){return r(this,t,arguments.length>1?arguments[1]:void 0)}}),t(5)(e)},{12:12,32:32,5:5}],125:[function(t){"use strict";var n=t(32),r=t(12)(5),e="find",i=!0;e in[]&&Array(1)[e](function(){i=!1}),n(n.P+n.F*i,"Array",{find:function(t){return r(this,t,arguments.length>1?arguments[1]:void 0)}}),t(5)(e)},{12:12,32:32,5:5}],126:[function(t){"use strict";var n=t(32),r=t(12)(0),e=t(96)([].forEach,!0);n(n.P+n.F*!e,"Array",{forEach:function(t){return r(this,t,arguments[1])}})},{12:12,32:32,96:96}],127:[function(t){"use strict";var n=t(25),r=t(32),e=t(109),i=t(51),o=t(46),u=t(108),c=t(24),a=t(118);r(r.S+r.F*!t(54)(function(t){Array.from(t)}),"Array",{from:function(t){var r,f,s,l,h=e(t),v="function"==typeof this?this:Array,p=arguments.length,g=p>1?arguments[1]:void 0,d=void 0!==g,y=0,m=a(h);if(d&&(g=n(g,p>2?arguments[2]:void 0,2)),void 0==m||v==Array&&o(m))for(r=u(h.length),f=new v(r);r>y;y++)c(f,y,d?g(h[y],y):h[y]);else for(l=m.call(h),f=new v;!(s=l.next()).done;y++)c(f,y,d?i(l,g,[s.value,y],!0):s.value);return f.length=y,f}})},{108:108,109:109,118:118,24:24,25:25,32:32,46:46,51:51,54:54}],128:[function(t){"use strict";var n=t(32),r=t(11)(!1),e=[].indexOf,i=!!e&&1/[1].indexOf(1,-0)<0;n(n.P+n.F*(i||!t(96)(e)),"Array",{indexOf:function(t){return i?e.apply(this,arguments)||0:r(this,t,arguments[1])}})},{11:11,32:32,96:96}],129:[function(t){var n=t(32);n(n.S,"Array",{isArray:t(47)})},{32:32,47:47}],130:[function(t,n){"use strict";var r=t(5),e=t(55),i=t(56),o=t(107);n.exports=t(53)(Array,"Array",function(t,n){this._t=o(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return t&&r<t.length?"keys"==n?e(0,r):"values"==n?e(0,t[r]):e(0,[r,t[r]]):(this._t=void 0,e(1))},"values"),i.Arguments=i.Array,r("keys"),r("values"),r("entries")},{107:107,5:5,53:53,55:55,56:56}],131:[function(t){"use strict";var n=t(32),r=t(107),e=[].join;n(n.P+n.F*(t(45)!=Object||!t(96)(e)),"Array",{join:function(t){return e.call(r(this),void 0===t?",":t)}})},{107:107,32:32,45:45,96:96}],132:[function(t){"use strict";var n=t(32),r=t(107),e=t(106),i=t(108),o=[].lastIndexOf,u=!!o&&1/[1].lastIndexOf(1,-0)<0;n(n.P+n.F*(u||!t(96)(o)),"Array",{lastIndexOf:function(t){if(u)return o.apply(this,arguments)||0;var n=r(this),c=i(n.length),a=c-1;for(arguments.length>1&&(a=Math.min(a,e(arguments[1]))),0>a&&(a=c+a);a>=0;a--)if(a in n&&n[a]===t)return a||0;return-1}})},{106:106,107:107,108:108,32:32,96:96}],133:[function(t){"use strict";var n=t(32),r=t(12)(1);n(n.P+n.F*!t(96)([].map,!0),"Array",{map:function(t){return r(this,t,arguments[1])}})},{12:12,32:32,96:96}],134:[function(t){"use strict";var n=t(32),r=t(24);n(n.S+n.F*t(34)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,e=new("function"==typeof this?this:Array)(n);n>t;)r(e,t,arguments[t++]);return e.length=n,e}})},{24:24,32:32,34:34}],135:[function(t){"use strict";var n=t(32),r=t(13);n(n.P+n.F*!t(96)([].reduceRight,!0),"Array",{reduceRight:function(t){return r(this,t,arguments.length,arguments[1],!0)}})},{13:13,32:32,96:96}],136:[function(t){"use strict";var n=t(32),r=t(13);n(n.P+n.F*!t(96)([].reduce,!0),"Array",{reduce:function(t){return r(this,t,arguments.length,arguments[1],!1)}})},{13:13,32:32,96:96}],137:[function(t){"use strict";var n=t(32),r=t(41),e=t(18),i=t(105),o=t(108),u=[].slice;n(n.P+n.F*t(34)(function(){r&&u.call(r)}),"Array",{slice:function(t,n){var r=o(this.length),c=e(this);if(n=void 0===n?r:n,"Array"==c)return u.call(this,t,n);for(var a=i(t,r),f=i(n,r),s=o(f-a),l=Array(s),h=0;s>h;h++)l[h]="String"==c?this.charAt(a+h):this[a+h];return l}})},{105:105,108:108,18:18,32:32,34:34,41:41}],138:[function(t){"use strict";var n=t(32),r=t(12)(3);n(n.P+n.F*!t(96)([].some,!0),"Array",{some:function(t){return r(this,t,arguments[1])}})},{12:12,32:32,96:96}],139:[function(t){"use strict";var n=t(32),r=t(3),e=t(109),i=t(34),o=[].sort,u=[1,2,3];n(n.P+n.F*(i(function(){u.sort(void 0)})||!i(function(){u.sort(null)})||!t(96)(o)),"Array",{sort:function(t){return void 0===t?o.call(e(this)):o.call(e(this),r(t))}})},{109:109,3:3,32:32,34:34,96:96}],140:[function(t){t(91)("Array")},{91:91}],141:[function(t){var n=t(32);n(n.S,"Date",{now:function(){return(new Date).getTime()}})},{32:32}],142:[function(t){"use strict";var n=t(32),r=t(34),e=Date.prototype.getTime,i=function(t){return t>9?t:"0"+t};n(n.P+n.F*(r(function(){return"0385-07-25T07:06:39.999Z"!=new Date(-5e13-1).toISOString()})||!r(function(){new Date(0/0).toISOString()})),"Date",{toISOString:function(){if(!isFinite(e.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),o=0>n?"-":n>9999?"+":"";return o+("00000"+Math.abs(n)).slice(o?-6:-4)+"-"+i(t.getUTCMonth()+1)+"-"+i(t.getUTCDate())+"T"+i(t.getUTCHours())+":"+i(t.getUTCMinutes())+":"+i(t.getUTCSeconds())+"."+(r>99?r:"0"+i(r))+"Z"}})},{32:32,34:34}],143:[function(t){"use strict";var n=t(32),r=t(109),e=t(110);n(n.P+n.F*t(34)(function(){return null!==new Date(0/0).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(){var t=r(this),n=e(t);return"number"!=typeof n||isFinite(n)?t.toISOString():null}})},{109:109,110:110,32:32,34:34}],144:[function(t){var n=t(117)("toPrimitive"),r=Date.prototype;n in r||t(40)(r,n,t(26))},{117:117,26:26,40:40}],145:[function(t){var n=Date.prototype,r="Invalid Date",e="toString",i=n[e],o=n.getTime;new Date(0/0)+""!=r&&t(87)(n,e,function(){var t=o.call(this);return t===t?i.call(this):r})},{87:87}],146:[function(t){var n=t(32);n(n.P,"Function",{bind:t(16)})},{16:16,32:32}],147:[function(t){"use strict";var n=t(49),r=t(74),e=t(117)("hasInstance"),i=Function.prototype;e in i||t(67).f(i,e,{value:function(t){if("function"!=typeof this||!n(t))return!1;if(!n(this.prototype))return t instanceof this;for(;t=r(t);)if(this.prototype===t)return!0;return!1}})},{117:117,49:49,67:67,74:74}],148:[function(t){var n=t(67).f,r=t(85),e=t(39),i=Function.prototype,o=/^\s*function ([^ (]*)/,u="name",c=Object.isExtensible||function(){return!0};u in i||t(28)&&n(i,u,{configurable:!0,get:function(){try{var t=this,i=(""+t).match(o)[1];return e(t,u)||!c(t)||n(t,u,r(5,i)),i}catch(t){return""}}})},{28:28,39:39,67:67,85:85}],149:[function(t,n){"use strict";var r=t(19);n.exports=t(22)("Map",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var n=r.getEntry(this,t);return n&&n.v},set:function(t,n){return r.def(this,0===t?0:t,n)}},r,!0)},{19:19,22:22}],150:[function(t){var n=t(32),r=t(60),e=Math.sqrt,i=Math.acosh;n(n.S+n.F*!(i&&710==Math.floor(i(Number.MAX_VALUE))&&i(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?0/0:t>94906265.62425156?Math.log(t)+Math.LN2:r(t-1+e(t-1)*e(t+1))}})},{32:32,60:60}],151:[function(t){function n(t){return isFinite(t=+t)&&0!=t?0>t?-n(-t):Math.log(t+Math.sqrt(t*t+1)):t}var r=t(32),e=Math.asinh;r(r.S+r.F*!(e&&1/e(0)>0),"Math",{asinh:n})},{32:32}],152:[function(t){var n=t(32),r=Math.atanh;n(n.S+n.F*!(r&&1/r(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},{32:32}],153:[function(t){var n=t(32),r=t(61);n(n.S,"Math",{cbrt:function(t){return r(t=+t)*Math.pow(Math.abs(t),1/3)}})},{32:32,61:61}],154:[function(t){var n=t(32);n(n.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},{32:32}],155:[function(t){var n=t(32),r=Math.exp;n(n.S,"Math",{cosh:function(t){return(r(t=+t)+r(-t))/2}})},{32:32}],156:[function(t){var n=t(32),r=t(59);n(n.S+n.F*(r!=Math.expm1),"Math",{expm1:r})},{32:32,59:59}],157:[function(t){var n=t(32),r=t(61),e=Math.pow,i=e(2,-52),o=e(2,-23),u=e(2,127)*(2-o),c=e(2,-126),a=function(t){return t+1/i-1/i};n(n.S,"Math",{fround:function(t){var n,e,f=Math.abs(t),s=r(t);return c>f?s*a(f/c/o)*c*o:(n=(1+o/i)*f,e=n-(n-f),e>u||e!=e?s*(1/0):s*e)}})},{32:32,61:61}],158:[function(t){var n=t(32),r=Math.abs;n(n.S,"Math",{hypot:function(){for(var t,n,e=0,i=0,o=arguments.length,u=0;o>i;)t=r(arguments[i++]),t>u?(n=u/t,e=e*n*n+1,u=t):t>0?(n=t/u,e+=n*n):e+=t;return u===1/0?1/0:u*Math.sqrt(e)}})},{32:32}],159:[function(t){var n=t(32),r=Math.imul;n(n.S+n.F*t(34)(function(){return-5!=r(4294967295,5)||2!=r.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},{32:32,34:34}],160:[function(t){var n=t(32);n(n.S,"Math",{log10:function(t){return Math.log(t)/Math.LN10}})},{32:32}],161:[function(t){var n=t(32);n(n.S,"Math",{log1p:t(60)})},{32:32,60:60}],162:[function(t){var n=t(32);n(n.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},{32:32}],163:[function(t){var n=t(32);n(n.S,"Math",{sign:t(61)})},{32:32,61:61}],164:[function(t){var n=t(32),r=t(59),e=Math.exp;n(n.S+n.F*t(34)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(r(t)-r(-t))/2:(e(t-1)-e(-t-1))*(Math.E/2)}})},{32:32,34:34,59:59}],165:[function(t){var n=t(32),r=t(59),e=Math.exp;n(n.S,"Math",{tanh:function(t){var n=r(t=+t),i=r(-t);return n==1/0?1:i==1/0?-1:(n-i)/(e(t)+e(-t))}})},{32:32,59:59}],166:[function(t){var n=t(32);n(n.S,"Math",{trunc:function(t){return(t>0?Math.floor:Math.ceil)(t)}})},{32:32}],167:[function(t){"use strict";var n=t(38),r=t(39),e=t(18),i=t(43),o=t(110),u=t(34),c=t(72).f,a=t(70).f,f=t(67).f,s=t(102).trim,l="Number",h=n[l],v=h,p=h.prototype,g=e(t(66)(p))==l,d="trim"in String.prototype,y=function(t){var n=o(t,!1);if("string"==typeof n&&n.length>2){n=d?n.trim():s(n,3);var r,e,i,u=n.charCodeAt(0);if(43===u||45===u){if(r=n.charCodeAt(2),88===r||120===r)return 0/0}else if(48===u){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var c,a=n.slice(2),f=0,l=a.length;l>f;f++)if(c=a.charCodeAt(f),48>c||c>i)return 0/0;return parseInt(a,e)}}return+n};if(!h(" 0o1")||!h("0b1")||h("+0x1")){h=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof h&&(g?u(function(){p.valueOf.call(r)}):e(r)!=l)?i(new v(y(n)),r,h):y(n)};for(var m,b=t(28)?c(v):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),x=0;b.length>x;x++)r(v,m=b[x])&&!r(h,m)&&f(h,m,a(v,m));h.prototype=p,p.constructor=h,t(87)(n,l,h)}},{102:102,110:110,18:18,28:28,34:34,38:38,39:39,43:43,66:66,67:67,70:70,72:72,87:87}],168:[function(t){var n=t(32);n(n.S,"Number",{EPSILON:Math.pow(2,-52)})},{32:32}],169:[function(t){var n=t(32),r=t(38).isFinite;n(n.S,"Number",{isFinite:function(t){return"number"==typeof t&&r(t)}})},{32:32,38:38}],170:[function(t){var n=t(32);n(n.S,"Number",{isInteger:t(48)})},{32:32,48:48}],171:[function(t){var n=t(32);n(n.S,"Number",{isNaN:function(t){return t!=t}})},{32:32}],172:[function(t){var n=t(32),r=t(48),e=Math.abs;n(n.S,"Number",{isSafeInteger:function(t){return r(t)&&e(t)<=9007199254740991}})},{32:32,48:48}],173:[function(t){var n=t(32);n(n.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},{32:32}],174:[function(t){var n=t(32);n(n.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},{32:32}],175:[function(t){var n=t(32),r=t(81);n(n.S+n.F*(Number.parseFloat!=r),"Number",{parseFloat:r})},{32:32,81:81}],176:[function(t){var n=t(32),r=t(82);n(n.S+n.F*(Number.parseInt!=r),"Number",{parseInt:r})},{32:32,82:82}],177:[function(t){"use strict";var n=t(32),r=t(106),e=t(4),i=t(101),o=1..toFixed,u=Math.floor,c=[0,0,0,0,0,0],a="Number.toFixed: incorrect invocation!",f="0",s=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*c[r],c[r]=e%1e7,e=u(e/1e7)},l=function(t){for(var n=6,r=0;--n>=0;)r+=c[n],c[n]=u(r/t),r=r%t*1e7},h=function(){for(var t=6,n="";--t>=0;)if(""!==n||0===t||0!==c[t]){var r=c[t]+"";n=""===n?r:n+i.call(f,7-r.length)+r}return n},v=function(t,n,r){return 0===n?r:n%2===1?v(t,n-1,r*t):v(t*t,n/2,r)},p=function(t){for(var n=0,r=t;r>=4096;)n+=12,r/=4096;for(;r>=2;)n+=1,r/=2;return n};n(n.P+n.F*(!!o&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==0xde0b6b3a7640080.toFixed(0))||!t(34)(function(){o.call({})})),"Number",{toFixed:function(t){var n,o,u,c,g=e(this,a),d=r(t),y="",m=f;if(0>d||d>20)throw RangeError(a);if(g!=g)return"NaN";if(-1e21>=g||g>=1e21)return g+"";if(0>g&&(y="-",g=-g),g>1e-21)if(n=p(g*v(2,69,1))-69,o=0>n?g*v(2,-n,1):g/v(2,n,1),o*=4503599627370496,n=52-n,n>0){for(s(0,o),u=d;u>=7;)s(1e7,0),u-=7;for(s(v(10,u,1),0),u=n-1;u>=23;)l(1<<23),u-=23;l(1<<u),s(1,1),l(2),m=h()}else s(0,o),s(1<<-n,0),m=h()+i.call(f,d);return d>0?(c=m.length,m=y+(c>d?m.slice(0,c-d)+"."+m.slice(c-d):"0."+i.call(f,d-c)+m)):m=y+m,m}})},{101:101,106:106,32:32,34:34,4:4}],178:[function(t){"use strict";var n=t(32),r=t(34),e=t(4),i=1..toPrecision;n(n.P+n.F*(r(function(){return"1"!==i.call(1,void 0)})||!r(function(){i.call({})})),"Number",{toPrecision:function(t){var n=e(this,"Number#toPrecision: incorrect invocation!");return void 0===t?i.call(n):i.call(n,t)}})},{32:32,34:34,4:4}],179:[function(t){var n=t(32);n(n.S+n.F,"Object",{assign:t(65)})},{32:32,65:65}],180:[function(t){var n=t(32);n(n.S,"Object",{create:t(66)})},{32:32,66:66}],181:[function(t){var n=t(32);n(n.S+n.F*!t(28),"Object",{defineProperties:t(68)})},{28:28,32:32,68:68}],182:[function(t){var n=t(32);n(n.S+n.F*!t(28),"Object",{defineProperty:t(67).f})},{28:28,32:32,67:67}],183:[function(t){var n=t(49),r=t(62).onFreeze;t(78)("freeze",function(t){return function(e){return t&&n(e)?t(r(e)):e}})},{49:49,62:62,78:78}],184:[function(t){var n=t(107),r=t(70).f;t(78)("getOwnPropertyDescriptor",function(){return function(t,e){return r(n(t),e)}})},{107:107,70:70,78:78}],185:[function(t){t(78)("getOwnPropertyNames",function(){return t(71).f})},{71:71,78:78}],186:[function(t){var n=t(109),r=t(74);t(78)("getPrototypeOf",function(){return function(t){return r(n(t))}})},{109:109,74:74,78:78}],187:[function(t){var n=t(49);t(78)("isExtensible",function(t){return function(r){return!!n(r)&&(!t||t(r))}})},{49:49,78:78}],188:[function(t){var n=t(49);t(78)("isFrozen",function(t){return function(r){return!n(r)||!!t&&t(r)}})},{49:49,78:78}],189:[function(t){var n=t(49);t(78)("isSealed",function(t){return function(r){return!n(r)||!!t&&t(r)}})},{49:49,78:78}],190:[function(t){var n=t(32);n(n.S,"Object",{is:t(89)})},{32:32,89:89}],191:[function(t){var n=t(109),r=t(76);t(78)("keys",function(){return function(t){return r(n(t))}})},{109:109,76:76,78:78}],192:[function(t){var n=t(49),r=t(62).onFreeze;t(78)("preventExtensions",function(t){return function(e){return t&&n(e)?t(r(e)):e}})},{49:49,62:62,78:78}],193:[function(t){var n=t(49),r=t(62).onFreeze;t(78)("seal",function(t){return function(e){return t&&n(e)?t(r(e)):e}})},{49:49,62:62,78:78}],194:[function(t){var n=t(32);n(n.S,"Object",{setPrototypeOf:t(90).set})},{32:32,90:90}],195:[function(t){"use strict";var n=t(17),r={};r[t(117)("toStringTag")]="z",r+""!="[object z]"&&t(87)(Object.prototype,"toString",function(){return"[object "+n(this)+"]"},!0)},{117:117,17:17,87:87}],196:[function(t){var n=t(32),r=t(81);n(n.G+n.F*(parseFloat!=r),{parseFloat:r})},{32:32,81:81}],197:[function(t){var n=t(32),r=t(82);n(n.G+n.F*(parseInt!=r),{parseInt:r})},{32:32,82:82}],198:[function(t){"use strict";var n,r,e,i=t(58),o=t(38),u=t(25),c=t(17),a=t(32),f=t(49),s=t(3),l=t(6),h=t(37),v=t(95),p=t(104).set,g=t(64)(),d="Promise",y=o.TypeError,m=o.process,b=o[d],m=o.process,x="process"==c(m),w=function(){},_=!!function(){try{var t=b.resolve(1),n=(t.constructor={})[r(117)("species")]=function(t){t(w,w)};return(x||"function"==typeof PromiseRejectionEvent)&&t.then(w)instanceof n}catch(r){}}(),S=function(t,n){return t===n||t===b&&n===e},E=function(t){var n;return!(!f(t)||"function"!=typeof(n=t.then))&&n},O=function(t){return S(b,t)?new F(t):new r(t)},F=r=function(t){var n,r;this.promise=new t(function(t,e){if(void 0!==n||void 0!==r)throw y("Bad Promise constructor");n=t,r=e}),this.resolve=s(n),this.reject=s(r)},M=function(t){try{t()}catch(t){return{error:t}}},P=function(t,n){if(!t._n){t._n=!0;var r=t._c;g(function(){for(var e=t._v,i=1==t._s,o=0,u=function(t){var n,r,o=i?t.ok:t.fail,u=t.resolve,c=t.reject,a=t.domain;try{o?(i||(2==f._h&&I(f),f._h=1),o===!0?n=e:(a&&a.enter(),n=o(e),a&&a.exit()),n===t.promise?c(y("Promise-chain cycle")):(r=E(n))?r.call(n,u,c):u(n)):c(e)}catch(f){c(f)}};r.length>o;)u(r[o++]);t._c=[],t._n=!1,n&&!t._h&&A(t)})}},A=function(t){p.call(o,function(){var n,r,e,i=t._v;if(j(t)&&(n=M(function(){x?m.emit("unhandledRejection",i,t):(r=o.onunhandledrejection)?r({promise:t,reason:i}):(e=o.console)&&e.error&&e.error("Unhandled promise rejection",i)}),t._h=x||j(t)?2:1),t._a=void 0,n)throw n.error})},j=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if(n=r[e++],n.fail||!j(n.promise))return!1;return!0},I=function(t){p.call(o,function(){var n;x?m.emit("rejectionHandled",t):(n=o.onrejectionhandled)&&n({promise:t,reason:t._v})})},N=function(t){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=t,n._s=2,n._a||(n._a=n._c.slice()),P(n,!0))},R=function(t){var n,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===t)throw y("Promise can't be resolved itself");(n=E(t))?g(function(){var t={_w:r,_d:!1};try{n.call(e,u(R,t,1),u(N,t,1))}catch(e){N.call(t,e)}}):(r._v=t,r._s=1,P(r,!1))}catch(t){N.call({_w:r,_d:!1},t)}}};_||(b=function(t){l(this,b,d,"_h"),s(t),n.call(this);try{t(u(R,this,1),u(N,this,1))}catch(t){N.call(this,t)}},n=function(){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},n.prototype=t(86)(b.prototype,{then:function(t,n){var r=O(v(this,b));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=x?m.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&P(this,!1),r.promise},"catch":function(t){return this.then(void 0,t)}}),F=function(){var t=new n;this.promise=t,this.resolve=u(R,t,1),this.reject=u(N,t,1)}),a(a.G+a.W+a.F*!_,{Promise:b}),t(92)(b,d),t(91)(d),e=t(23)[d],a(a.S+a.F*!_,d,{reject:function(t){var n=O(this),r=n.reject;return r(t),n.promise}}),a(a.S+a.F*(i||!_),d,{resolve:function(t){if(t instanceof b&&S(t.constructor,this))return t;var n=O(this),r=n.resolve;return r(t),n.promise}}),a(a.S+a.F*!(_&&t(54)(function(t){b.all(t).catch(w)})),d,{all:function(t){var n=this,r=O(n),e=r.resolve,i=r.reject,o=M(function(){var r=[],o=0,u=1;h(t,!1,function(t){var c=o++,a=!1;r.push(void 0),u++,n.resolve(t).then(function(t){a||(a=!0,r[c]=t,--u||e(r))},i)}),--u||e(r)});return o&&i(o.error),r.promise},race:function(t){var n=this,r=O(n),e=r.reject,i=M(function(){h(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i&&e(i.error),r.promise}})},{104:104,117:117,17:17,23:23,25:25,3:3,32:32,37:37,38:38,49:49,54:54,58:58,6:6,64:64,86:86,91:91,92:92,95:95}],199:[function(t){var n=t(32),r=t(3),e=t(7),i=(t(38).Reflect||{}).apply,o=Function.apply;n(n.S+n.F*!t(34)(function(){i(function(){})}),"Reflect",{apply:function(t,n,u){var c=r(t),a=e(u);return i?i(c,n,a):o.call(c,n,a)}})},{3:3,32:32,34:34,38:38,7:7}],200:[function(t){var n=t(32),r=t(66),e=t(3),i=t(7),o=t(49),u=t(34),c=t(16),a=(t(38).Reflect||{}).construct,f=u(function(){function t(){}return!(a(function(){},[],t)instanceof t)}),s=!u(function(){a(function(){})});n(n.S+n.F*(f||s),"Reflect",{construct:function(t,n){e(t),i(n);var u=arguments.length<3?t:e(arguments[2]);if(s&&!f)return a(t,n,u);if(t==u){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var l=[null];return l.push.apply(l,n),new(c.apply(t,l))}var h=u.prototype,v=r(o(h)?h:Object.prototype),p=Function.apply.call(t,v,n);return o(p)?p:v}})},{16:16,3:3,32:32,34:34,38:38,49:49,66:66,7:7}],201:[function(t){var n=t(67),r=t(32),e=t(7),i=t(110);r(r.S+r.F*t(34)(function(){Reflect.defineProperty(n.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,r,o){e(t),r=i(r,!0),e(o);try{return n.f(t,r,o),!0}catch(t){return!1}}})},{110:110,32:32,34:34,67:67,7:7}],202:[function(t){var n=t(32),r=t(70).f,e=t(7);n(n.S,"Reflect",{deleteProperty:function(t,n){var i=r(e(t),n);return!(i&&!i.configurable)&&delete t[n]}})},{32:32,7:7,70:70}],203:[function(t){"use strict";var n=t(32),r=t(7),e=function(t){this._t=r(t),this._i=0;var n,e=this._k=[];for(n in t)e.push(n)};t(52)(e,"Object",function(){var t,n=this,r=n._k;do if(n._i>=r.length)return{value:void 0,done:!0};while(!((t=r[n._i++])in n._t));return{value:t,done:!1}}),n(n.S,"Reflect",{enumerate:function(t){return new e(t)}})},{32:32,52:52,7:7}],204:[function(t){var n=t(70),r=t(32),e=t(7);r(r.S,"Reflect",{getOwnPropertyDescriptor:function(t,r){return n.f(e(t),r)}})},{32:32,7:7,70:70}],205:[function(t){var n=t(32),r=t(74),e=t(7);n(n.S,"Reflect",{getPrototypeOf:function(t){return r(e(t))}})},{32:32,7:7,74:74}],206:[function(t){function n(t,o){var a,f,s=arguments.length<3?t:arguments[2];return c(t)===s?t[o]:(a=r.f(t,o))?i(a,"value")?a.value:void 0!==a.get?a.get.call(s):void 0:u(f=e(t))?n(f,o,s):void 0}var r=t(70),e=t(74),i=t(39),o=t(32),u=t(49),c=t(7);o(o.S,"Reflect",{get:n})},{32:32,39:39,49:49,7:7,70:70,74:74}],207:[function(t){var n=t(32);n(n.S,"Reflect",{has:function(t,n){return n in t}})},{32:32}],208:[function(t){var n=t(32),r=t(7),e=Object.isExtensible;n(n.S,"Reflect",{isExtensible:function(t){return r(t),!e||e(t)}})},{32:32,7:7}],209:[function(t){var n=t(32);n(n.S,"Reflect",{ownKeys:t(80)})},{32:32,80:80}],210:[function(t){var n=t(32),r=t(7),e=Object.preventExtensions;n(n.S,"Reflect",{preventExtensions:function(t){r(t);try{return e&&e(t),!0}catch(t){return!1}}})},{32:32,7:7}],211:[function(t){var n=t(32),r=t(90);r&&n(n.S,"Reflect",{setPrototypeOf:function(t,n){r.check(t,n);try{return r.set(t,n),!0}catch(t){return!1}}})},{32:32,90:90}],212:[function(t){function n(t,u,s){var l,h,v=arguments.length<4?t:arguments[3],p=e.f(a(t),u);if(!p){if(f(h=i(t)))return n(h,u,s,v);p=c(0)}return o(p,"value")?!(p.writable===!1||!f(v)||(l=e.f(v,u)||c(0),l.value=s,r.f(v,u,l),0)):void 0!==p.set&&(p.set.call(v,s),!0)}var r=t(67),e=t(70),i=t(74),o=t(39),u=t(32),c=t(85),a=t(7),f=t(49);u(u.S,"Reflect",{set:n})},{32:32,39:39,49:49,67:67,7:7,70:70,74:74,85:85}],213:[function(t){var n=t(38),r=t(43),e=t(67).f,i=t(72).f,o=t(50),u=t(36),c=n.RegExp,a=c,f=c.prototype,s=/a/g,l=/a/g,h=new c(s)!==s;if(t(28)&&(!h||t(34)(function(){return l[t(117)("match")]=!1,c(s)!=s||c(l)==l||"/a/i"!=c(s,"i")}))){c=function(t,n){var e=this instanceof c,i=o(t),s=void 0===n;return!e&&i&&t.constructor===c&&s?t:r(h?new a(i&&!s?t.source:t,n):a((i=t instanceof c)?t.source:t,i&&s?u.call(t):n),e?this:f,c)};for(var v=(function(t){t in c||e(c,t,{configurable:!0,get:function(){return a[t]},set:function(n){a[t]=n}})}),p=i(a),g=0;p.length>g;)v(p[g++]);f.constructor=c,c.prototype=f,t(87)(n,"RegExp",c)}t(91)("RegExp")},{117:117,28:28,34:34,36:36,38:38,43:43,50:50,67:67,72:72,87:87,91:91}],214:[function(t){t(28)&&"g"!=/./g.flags&&t(67).f(RegExp.prototype,"flags",{configurable:!0,get:t(36)})},{28:28,36:36,67:67}],215:[function(t){t(35)("match",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):RegExp(r)[n](e+"")},r]})},{35:35}],216:[function(t){t(35)("replace",2,function(t,n,r){return[function(e,i){"use strict";
var o=t(this),u=void 0==e?void 0:e[n];return void 0!==u?u.call(e,o,i):r.call(o+"",e,i)},r]})},{35:35}],217:[function(t){t(35)("search",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):RegExp(r)[n](e+"")},r]})},{35:35}],218:[function(t){t(35)("split",2,function(n,r,e){"use strict";var i=t(50),o=e,u=[].push,c="split",a="length",f="lastIndex";if("c"=="abbc"[c](/(b)*/)[1]||4!="test"[c](/(?:)/,-1)[a]||2!="ab"[c](/(?:ab)*/)[a]||4!="."[c](/(.?)(.?)/)[a]||"."[c](/()()/)[a]>1||""[c](/.?/)[a]){var s=void 0===/()??/.exec("")[1];e=function(t,n){var r=this+"";if(void 0===t&&0===n)return[];if(!i(t))return o.call(r,t,n);var e,c,l,h,v,p=[],g=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),d=0,y=void 0===n?4294967295:n>>>0,m=RegExp(t.source,g+"g");for(s||(e=RegExp("^"+m.source+"$(?!\\s)",g));(c=m.exec(r))&&(l=c.index+c[0][a],!(l>d&&(p.push(r.slice(d,c.index)),!s&&c[a]>1&&c[0].replace(e,function(){for(v=1;v<arguments[a]-2;v++)void 0===arguments[v]&&(c[v]=void 0)}),c[a]>1&&c.index<r[a]&&u.apply(p,c.slice(1)),h=c[0][a],d=l,p[a]>=y)));)m[f]===c.index&&m[f]++;return d===r[a]?!h&&m.test("")||p.push(""):p.push(r.slice(d)),p[a]>y?p.slice(0,y):p}}else"0"[c](void 0,0)[a]&&(e=function(t,n){return void 0===t&&0===n?[]:o.call(this,t,n)});return[function(t,i){var o=n(this),u=void 0==t?void 0:t[r];return void 0!==u?u.call(t,o,i):e.call(o+"",t,i)},e]})},{35:35,50:50}],219:[function(t){"use strict";t(214);var n=t(7),r=t(36),e=t(28),i="toString",o=/./[i],u=function(n){t(87)(RegExp.prototype,i,n,!0)};t(34)(function(){return"/a/b"!=o.call({source:"a",flags:"b"})})?u(function(){var t=n(this);return"/".concat(t.source,"/","flags"in t?t.flags:!e&&t instanceof RegExp?r.call(t):void 0)}):o.name!=i&&u(function(){return o.call(this)})},{214:214,28:28,34:34,36:36,7:7,87:87}],220:[function(t,n){"use strict";var r=t(19);n.exports=t(22)("Set",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return r.def(this,t=0===t?0:t,t)}},r)},{19:19,22:22}],221:[function(t){"use strict";t(99)("anchor",function(t){return function(n){return t(this,"a","name",n)}})},{99:99}],222:[function(t){"use strict";t(99)("big",function(t){return function(){return t(this,"big","","")}})},{99:99}],223:[function(t){"use strict";t(99)("blink",function(t){return function(){return t(this,"blink","","")}})},{99:99}],224:[function(t){"use strict";t(99)("bold",function(t){return function(){return t(this,"b","","")}})},{99:99}],225:[function(t){"use strict";var n=t(32),r=t(97)(!1);n(n.P,"String",{codePointAt:function(t){return r(this,t)}})},{32:32,97:97}],226:[function(t){"use strict";var n=t(32),r=t(108),e=t(98),i="endsWith",o=""[i];n(n.P+n.F*t(33)(i),"String",{endsWith:function(t){var n=e(this,t,i),u=arguments.length>1?arguments[1]:void 0,c=r(n.length),a=void 0===u?c:Math.min(r(u),c),f=t+"";return o?o.call(n,f,a):n.slice(a-f.length,a)===f}})},{108:108,32:32,33:33,98:98}],227:[function(t){"use strict";t(99)("fixed",function(t){return function(){return t(this,"tt","","")}})},{99:99}],228:[function(t){"use strict";t(99)("fontcolor",function(t){return function(n){return t(this,"font","color",n)}})},{99:99}],229:[function(t){"use strict";t(99)("fontsize",function(t){return function(n){return t(this,"font","size",n)}})},{99:99}],230:[function(t){var n=t(32),r=t(105),e=String.fromCharCode,i=String.fromCodePoint;n(n.S+n.F*(!!i&&1!=i.length),"String",{fromCodePoint:function(){for(var t,n=[],i=arguments.length,o=0;i>o;){if(t=+arguments[o++],r(t,1114111)!==t)throw RangeError(t+" is not a valid code point");n.push(65536>t?e(t):e(((t-=65536)>>10)+55296,t%1024+56320))}return n.join("")}})},{105:105,32:32}],231:[function(t){"use strict";var n=t(32),r=t(98),e="includes";n(n.P+n.F*t(33)(e),"String",{includes:function(t){return!!~r(this,t,e).indexOf(t,arguments.length>1?arguments[1]:void 0)}})},{32:32,33:33,98:98}],232:[function(t){"use strict";t(99)("italics",function(t){return function(){return t(this,"i","","")}})},{99:99}],233:[function(t){"use strict";var n=t(97)(!0);t(53)(String,"String",function(t){this._t=t+"",this._i=0},function(){var t,r=this._t,e=this._i;return e<r.length?(t=n(r,e),this._i+=t.length,{value:t,done:!1}):{value:void 0,done:!0}})},{53:53,97:97}],234:[function(t){"use strict";t(99)("link",function(t){return function(n){return t(this,"a","href",n)}})},{99:99}],235:[function(t){var n=t(32),r=t(107),e=t(108);n(n.S,"String",{raw:function(t){for(var n=r(t.raw),i=e(n.length),o=arguments.length,u=[],c=0;i>c;)u.push(n[c++]+""),o>c&&u.push(arguments[c]+"");return u.join("")}})},{107:107,108:108,32:32}],236:[function(t){var n=t(32);n(n.P,"String",{repeat:t(101)})},{101:101,32:32}],237:[function(t){"use strict";t(99)("small",function(t){return function(){return t(this,"small","","")}})},{99:99}],238:[function(t){"use strict";var n=t(32),r=t(108),e=t(98),i="startsWith",o=""[i];n(n.P+n.F*t(33)(i),"String",{startsWith:function(t){var n=e(this,t,i),u=r(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),c=t+"";return o?o.call(n,c,u):n.slice(u,u+c.length)===c}})},{108:108,32:32,33:33,98:98}],239:[function(t){"use strict";t(99)("strike",function(t){return function(){return t(this,"strike","","")}})},{99:99}],240:[function(t){"use strict";t(99)("sub",function(t){return function(){return t(this,"sub","","")}})},{99:99}],241:[function(t){"use strict";t(99)("sup",function(t){return function(){return t(this,"sup","","")}})},{99:99}],242:[function(t){"use strict";t(102)("trim",function(t){return function(){return t(this,3)}})},{102:102}],243:[function(t){"use strict";var n=t(38),r=t(39),e=t(28),i=t(32),o=t(87),u=t(62).KEY,c=t(34),a=t(94),f=t(92),s=t(114),l=t(117),h=t(116),v=t(115),p=t(57),g=t(31),d=t(47),y=t(7),m=t(107),b=t(110),x=t(85),w=t(66),_=t(71),S=t(70),E=t(67),O=t(76),F=S.f,M=E.f,P=_.f,A=n.Symbol,j=n.JSON,I=j&&j.stringify,N="prototype",R=l("_hidden"),T=l("toPrimitive"),L={}.propertyIsEnumerable,k=a("symbol-registry"),C=a("symbols"),D=a("op-symbols"),U=Object[N],G="function"==typeof A,W=n.QObject,B=!W||!W[N]||!W[N].findChild,V=e&&c(function(){return 7!=w(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(U,n);e&&delete U[n],M(t,n,r),e&&t!==U&&M(U,n,e)}:M,z=function(t){var n=C[t]=w(A[N]);return n._k=t,n},q=G&&"symbol"==typeof A.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof A},H=function(t,n,e){return t===U&&H(D,n,e),y(t),n=b(n,!0),y(e),r(C,n)?(e.enumerable?(r(t,R)&&t[R][n]&&(t[R][n]=!1),e=w(e,{enumerable:x(0,!1)})):(r(t,R)||M(t,R,x(1,{})),t[R][n]=!0),V(t,n,e)):M(t,n,e)},Y=function(t,n){y(t);for(var r,e=g(n=m(n)),i=0,o=e.length;o>i;)H(t,r=e[i++],n[r]);return t},J=function(t,n){return void 0===n?w(t):Y(w(t),n)},K=function(t){var n=L.call(this,t=b(t,!0));return!(this===U&&r(C,t)&&!r(D,t)||(n||!r(this,t)||!r(C,t)||r(this,R)&&this[R][t])&&!n)},X=function(t,n){if(t=m(t),n=b(n,!0),t!==U||!r(C,n)||r(D,n)){var e=F(t,n);return!e||!r(C,n)||r(t,R)&&t[R][n]||(e.enumerable=!0),e}},$=function(t){for(var n,e=P(m(t)),i=[],o=0;e.length>o;)r(C,n=e[o++])||n==R||n==u||i.push(n);return i},Z=function(t){for(var n,e=t===U,i=P(e?D:m(t)),o=[],u=0;i.length>u;)!r(C,n=i[u++])||e&&!r(U,n)||o.push(C[n]);return o};G||(A=function(){if(this instanceof A)throw TypeError("Symbol is not a constructor!");var t=s(arguments.length>0?arguments[0]:void 0),n=function(e){this===U&&n.call(D,e),r(this,R)&&r(this[R],t)&&(this[R][t]=!1),V(this,t,x(1,e))};return e&&B&&V(U,t,{configurable:!0,set:n}),z(t)},o(A[N],"toString",function(){return this._k}),S.f=X,E.f=H,t(72).f=_.f=$,t(77).f=K,t(73).f=Z,e&&!t(58)&&o(U,"propertyIsEnumerable",K,!0),h.f=function(t){return z(l(t))}),i(i.G+i.W+i.F*!G,{Symbol:A});for(var Q="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),tn=0;Q.length>tn;)l(Q[tn++]);for(var Q=O(l.store),tn=0;Q.length>tn;)v(Q[tn++]);i(i.S+i.F*!G,"Symbol",{"for":function(t){return r(k,t+="")?k[t]:k[t]=A(t)},keyFor:function(t){if(q(t))return p(k,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){B=!0},useSimple:function(){B=!1}}),i(i.S+i.F*!G,"Object",{create:J,defineProperty:H,defineProperties:Y,getOwnPropertyDescriptor:X,getOwnPropertyNames:$,getOwnPropertySymbols:Z}),j&&i(i.S+i.F*(!G||c(function(){var t=A();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!q(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&d(n)||(n=function(t,n){return r&&(n=r.call(this,t,n)),q(n)?void 0:n}),e[1]=n,I.apply(j,e)}}}),A[N][T]||t(40)(A[N],T,A[N].valueOf),f(A,"Symbol"),f(Math,"Math",!0),f(n.JSON,"JSON",!0)},{107:107,110:110,114:114,115:115,116:116,117:117,28:28,31:31,32:32,34:34,38:38,39:39,40:40,47:47,57:57,58:58,62:62,66:66,67:67,7:7,70:70,71:71,72:72,73:73,76:76,77:77,85:85,87:87,92:92,94:94}],244:[function(t){"use strict";var n=t(32),r=t(113),e=t(112),i=t(7),o=t(105),u=t(108),c=t(49),a=t(38).ArrayBuffer,f=t(95),s=e.ArrayBuffer,l=e.DataView,h=r.ABV&&a.isView,v=s.prototype.slice,p=r.VIEW,g="ArrayBuffer";n(n.G+n.W+n.F*(a!==s),{ArrayBuffer:s}),n(n.S+n.F*!r.CONSTR,g,{isView:function(t){return h&&h(t)||c(t)&&p in t}}),n(n.P+n.U+n.F*t(34)(function(){return!new s(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==v&&void 0===n)return v.call(i(this),t);for(var r=i(this).byteLength,e=o(t,r),c=o(void 0===n?r:n,r),a=new(f(this,s))(u(c-e)),h=new l(this),p=new l(a),g=0;c>e;)p.setUint8(g++,h.getUint8(e++));return a}}),t(91)(g)},{105:105,108:108,112:112,113:113,32:32,34:34,38:38,49:49,7:7,91:91,95:95}],245:[function(t){var n=t(32);n(n.G+n.W+n.F*!t(113).ABV,{DataView:t(112).DataView})},{112:112,113:113,32:32}],246:[function(t){t(111)("Float32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},{111:111}],247:[function(t){t(111)("Float64",8,function(t){return function(n,r,e){return t(this,n,r,e)}})},{111:111}],248:[function(t){t(111)("Int16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},{111:111}],249:[function(t){t(111)("Int32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},{111:111}],250:[function(t){t(111)("Int8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},{111:111}],251:[function(t){t(111)("Uint16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},{111:111}],252:[function(t){t(111)("Uint32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},{111:111}],253:[function(t){t(111)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},{111:111}],254:[function(t){t(111)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}},!0)},{111:111}],255:[function(t,n){"use strict";var r,e=t(12)(0),i=t(87),o=t(62),u=t(65),c=t(21),a=t(49),f=o.getWeak,s=Object.isExtensible,l=c.ufstore,h={},v=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},p={get:function(t){if(a(t)){var n=f(t);return n===!0?l(this).get(t):n?n[this._i]:void 0}},set:function(t,n){return c.def(this,t,n)}},g=n.exports=t(22)("WeakMap",v,p,c,!0,!0);7!=(new g).set((Object.freeze||Object)(h),7).get(h)&&(r=c.getConstructor(v),u(r.prototype,p),o.NEED=!0,e(["delete","has","get","set"],function(t){var n=g.prototype,e=n[t];i(n,t,function(n,i){if(a(n)&&!s(n)){this._f||(this._f=new r);var o=this._f[t](n,i);return"set"==t?this:o}return e.call(this,n,i)})}))},{12:12,21:21,22:22,49:49,62:62,65:65,87:87}],256:[function(t){"use strict";var n=t(21);t(22)("WeakSet",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return n.def(this,t,!0)}},n,!1,!0)},{21:21,22:22}],257:[function(t){"use strict";var n=t(32),r=t(11)(!0);n(n.P,"Array",{includes:function(t){return r(this,t,arguments.length>1?arguments[1]:void 0)}}),t(5)("includes")},{11:11,32:32,5:5}],258:[function(t){var n=t(32),r=t(64)(),e=t(38).process,i="process"==t(18)(e);n(n.G,{asap:function(t){var n=i&&e.domain;r(n?n.bind(t):t)}})},{18:18,32:32,38:38,64:64}],259:[function(t){var n=t(32),r=t(18);n(n.S,"Error",{isError:function(t){return"Error"===r(t)}})},{18:18,32:32}],260:[function(t){var n=t(32);n(n.P+n.R,"Map",{toJSON:t(20)("Map")})},{20:20,32:32}],261:[function(t){var n=t(32);n(n.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o+(e>>>0)+((i&u|(i|u)&~(i+u>>>0))>>>31)|0}})},{32:32}],262:[function(t){var n=t(32);n(n.S,"Math",{imulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>16,a=i>>16,f=(c*u>>>0)+(o*u>>>16);return c*a+(f>>16)+((o*a>>>0)+(f&r)>>16)}})},{32:32}],263:[function(t){var n=t(32);n(n.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o-(e>>>0)-((~i&u|~(i^u)&i-u>>>0)>>>31)|0}})},{32:32}],264:[function(t){var n=t(32);n(n.S,"Math",{umulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>>16,a=i>>>16,f=(c*u>>>0)+(o*u>>>16);return c*a+(f>>>16)+((o*a>>>0)+(f&r)>>>16)}})},{32:32}],265:[function(t){"use strict";var n=t(32),r=t(109),e=t(3),i=t(67);t(28)&&n(n.P+t(69),"Object",{__defineGetter__:function(t,n){i.f(r(this),t,{get:e(n),enumerable:!0,configurable:!0})}})},{109:109,28:28,3:3,32:32,67:67,69:69}],266:[function(t){"use strict";var n=t(32),r=t(109),e=t(3),i=t(67);t(28)&&n(n.P+t(69),"Object",{__defineSetter__:function(t,n){i.f(r(this),t,{set:e(n),enumerable:!0,configurable:!0})}})},{109:109,28:28,3:3,32:32,67:67,69:69}],267:[function(t){var n=t(32),r=t(79)(!0);n(n.S,"Object",{entries:function(t){return r(t)}})},{32:32,79:79}],268:[function(t){var n=t(32),r=t(80),e=t(107),i=t(70),o=t(24);n(n.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,u=e(t),c=i.f,a=r(u),f={},s=0;a.length>s;)o(f,n=a[s++],c(u,n));return f}})},{107:107,24:24,32:32,70:70,80:80}],269:[function(t){"use strict";var n=t(32),r=t(109),e=t(110),i=t(74),o=t(70).f;t(28)&&n(n.P+t(69),"Object",{__lookupGetter__:function(t){var n,u=r(this),c=e(t,!0);do if(n=o(u,c))return n.get;while(u=i(u))}})},{109:109,110:110,28:28,32:32,69:69,70:70,74:74}],270:[function(t){"use strict";var n=t(32),r=t(109),e=t(110),i=t(74),o=t(70).f;t(28)&&n(n.P+t(69),"Object",{__lookupSetter__:function(t){var n,u=r(this),c=e(t,!0);do if(n=o(u,c))return n.set;while(u=i(u))}})},{109:109,110:110,28:28,32:32,69:69,70:70,74:74}],271:[function(t){var n=t(32),r=t(79)(!1);n(n.S,"Object",{values:function(t){return r(t)}})},{32:32,79:79}],272:[function(t){"use strict";var n=t(32),r=t(38),e=t(23),i=t(64)(),o=t(117)("observable"),u=t(3),c=t(7),a=t(6),f=t(86),s=t(40),l=t(37),h=l.RETURN,v=function(t){return null==t?void 0:u(t)},p=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},d=function(t){g(t)||(t._o=void 0,p(t))},y=function(t,n){c(t),this._c=void 0,this._o=t,t=new m(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:u(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&p(this)};y.prototype=f({},{unsubscribe:function(){d(this)}});var m=function(t){this._s=t};m.prototype=f({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=v(r.next);if(e)return e.call(r,t)}catch(t){try{d(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=v(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{p(n)}finally{throw t}}return p(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=v(r.complete);t=e?e.call(r,t):void 0}catch(t){try{p(n)}finally{throw t}}return p(n),t}}});var b=function(t){a(this,b,"Observable","_f")._f=u(t)};f(b.prototype,{subscribe:function(t){return new y(t,this._f)},forEach:function(t){var n=this;return new(e.Promise||r.Promise)(function(r,e){u(t);var i=n.subscribe({next:function(t){try{return n(t)}catch(n){e(n),i.unsubscribe()}},error:e,complete:r})})}}),f(b,{from:function(t){var n="function"==typeof this?this:b,r=v(c(t)[o]);if(r){var e=c(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(t){var n=!1;return i(function(){if(!n){try{if(l(r,!1,function(r){return t.next(r),n?h:void 0})===h)return}catch(r){if(n)throw r;return void t.error(r)}t.complete()}}),function(){n=!0}})},of:function(){for(var t=0,n=arguments.length,r=Array(n);n>t;)r[t]=arguments[t++];return new("function"==typeof this?this:b)(function(t){var n=!1;return i(function(){if(!n){for(var e=0;e<r.length;++e)if(t.next(r[e]),n)return;t.complete()}}),function(){n=!0}})}}),s(b.prototype,o,function(){return this}),n(n.G,{Observable:b}),t(91)("Observable")},{117:117,23:23,3:3,32:32,37:37,38:38,40:40,6:6,64:64,7:7,86:86,91:91}],273:[function(t){var n=t(63),r=t(7),e=n.key,i=n.set;n.exp({defineMetadata:function(t,n,o,u){i(t,n,r(o),e(u))}})},{63:63,7:7}],274:[function(t){var n=t(63),r=t(7),e=n.key,i=n.map,o=n.store;n.exp({deleteMetadata:function(t,n){var u=arguments.length<3?void 0:e(arguments[2]),c=i(r(n),u,!1);if(void 0===c||!c.delete(t))return!1;if(c.size)return!0;var a=o.get(n);return a.delete(u),!!a.size||o.delete(n)}})},{63:63,7:7}],275:[function(t){var n=t(220),r=t(10),e=t(63),i=t(7),o=t(74),u=e.keys,c=e.key,a=function(t,e){var i=u(t,e),c=o(t);if(null===c)return i;var f=a(c,e);return f.length?i.length?r(new n(i.concat(f))):f:i};e.exp({getMetadataKeys:function(t){return a(i(t),arguments.length<2?void 0:c(arguments[1]))}})},{10:10,220:220,63:63,7:7,74:74}],276:[function(t){var n=t(63),r=t(7),e=t(74),i=n.has,o=n.get,u=n.key,c=function(t,n,r){var u=i(t,n,r);if(u)return o(t,n,r);var a=e(n);return null!==a?c(t,a,r):void 0};n.exp({getMetadata:function(t,n){return c(t,r(n),arguments.length<3?void 0:u(arguments[2]))}})},{63:63,7:7,74:74}],277:[function(t){var n=t(63),r=t(7),e=n.keys,i=n.key;n.exp({getOwnMetadataKeys:function(t){return e(r(t),arguments.length<2?void 0:i(arguments[1]))}})},{63:63,7:7}],278:[function(t){var n=t(63),r=t(7),e=n.get,i=n.key;n.exp({getOwnMetadata:function(t,n){return e(t,r(n),arguments.length<3?void 0:i(arguments[2]))}})},{63:63,7:7}],279:[function(t){var n=t(63),r=t(7),e=t(74),i=n.has,o=n.key,u=function(t,n,r){var o=i(t,n,r);if(o)return!0;var c=e(n);return null!==c&&u(t,c,r)};n.exp({hasMetadata:function(t,n){return u(t,r(n),arguments.length<3?void 0:o(arguments[2]))}})},{63:63,7:7,74:74}],280:[function(t){var n=t(63),r=t(7),e=n.has,i=n.key;n.exp({hasOwnMetadata:function(t,n){return e(t,r(n),arguments.length<3?void 0:i(arguments[2]))}})},{63:63,7:7}],281:[function(t){var n=t(63),r=t(7),e=t(3),i=n.key,o=n.set;n.exp({metadata:function(t,n){return function(u,c){o(t,n,(void 0!==c?r:e)(u),i(c))}}})},{3:3,63:63,7:7}],282:[function(t){var n=t(32);n(n.P+n.R,"Set",{toJSON:t(20)("Set")})},{20:20,32:32}],283:[function(t){"use strict";var n=t(32),r=t(97)(!0);n(n.P,"String",{at:function(t){return r(this,t)}})},{32:32,97:97}],284:[function(t){"use strict";var n=t(32),r=t(27),e=t(108),i=t(50),o=t(36),u=RegExp.prototype,c=function(t,n){this._r=t,this._s=n};t(52)(c,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),n(n.P,"String",{matchAll:function(t){if(r(this),!i(t))throw TypeError(t+" is not a regexp!");var n=this+"",a="flags"in u?t.flags+"":o.call(t),f=RegExp(t.source,~a.indexOf("g")?a:"g"+a);return f.lastIndex=e(t.lastIndex),new c(f,n)}})},{108:108,27:27,32:32,36:36,50:50,52:52}],285:[function(t){"use strict";var n=t(32),r=t(100);n(n.P,"String",{padEnd:function(t){return r(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},{100:100,32:32}],286:[function(t){"use strict";var n=t(32),r=t(100);n(n.P,"String",{padStart:function(t){return r(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},{100:100,32:32}],287:[function(t){"use strict";t(102)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},{102:102}],288:[function(t){"use strict";t(102)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},{102:102}],289:[function(t){t(115)("asyncIterator")},{115:115}],290:[function(t){t(115)("observable")},{115:115}],291:[function(t){var n=t(32);n(n.S,"System",{global:t(38)})},{32:32,38:38}],292:[function(t){for(var n=t(130),r=t(87),e=t(38),i=t(40),o=t(56),u=t(117),c=u("iterator"),a=u("toStringTag"),f=o.Array,s=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],l=0;5>l;l++){var h,v=s[l],p=e[v],g=p&&p.prototype;if(g){g[c]||i(g,c,f),g[a]||i(g,a,v),o[v]=f;for(h in n)g[h]||r(g,h,n[h],!0)}}},{117:117,130:130,38:38,40:40,56:56,87:87}],293:[function(t){var n=t(32),r=t(104);n(n.G+n.B,{setImmediate:r.set,clearImmediate:r.clear})},{104:104,32:32}],294:[function(t){var n=t(38),r=t(32),e=t(44),i=t(83),o=n.navigator,u=!!o&&/MSIE .\./.test(o.userAgent),c=function(t){return u?function(n,r){return t(e(i,[].slice.call(arguments,2),"function"==typeof n?n:Function(n)),r)}:t};r(r.G+r.B+r.F*u,{setTimeout:c(n.setTimeout),setInterval:c(n.setInterval)})},{32:32,38:38,44:44,83:83}],295:[function(t,n){t(243),t(180),t(182),t(181),t(184),t(186),t(191),t(185),t(183),t(193),t(192),t(188),t(189),t(187),t(179),t(190),t(194),t(195),t(146),t(148),t(147),t(197),t(196),t(167),t(177),t(178),t(168),t(169),t(170),t(171),t(172),t(173),t(174),t(175),t(176),t(150),t(151),t(152),t(153),t(154),t(155),t(156),t(157),t(158),t(159),t(160),t(161),t(162),t(163),t(164),t(165),t(166),t(230),t(235),t(242),t(233),t(225),t(226),t(231),t(236),t(238),t(221),t(222),t(223),t(224),t(227),t(228),t(229),t(232),t(234),t(237),t(239),t(240),t(241),t(141),t(143),t(142),t(145),t(144),t(129),t(127),t(134),t(131),t(137),t(139),t(126),t(133),t(123),t(138),t(121),t(136),t(135),t(128),t(132),t(120),t(122),t(125),t(124),t(140),t(130),t(213),t(219),t(214),t(215),t(216),t(217),t(218),t(198),t(149),t(220),t(255),t(256),t(244),t(245),t(250),t(253),t(254),t(248),t(251),t(249),t(252),t(246),t(247),t(199),t(200),t(201),t(202),t(203),t(206),t(204),t(205),t(207),t(208),t(209),t(210),t(212),t(211),t(257),t(283),t(286),t(285),t(287),t(288),t(284),t(289),t(290),t(268),t(271),t(267),t(265),t(266),t(269),t(270),t(260),t(282),t(291),t(259),t(261),t(263),t(262),t(264),t(273),t(274),t(276),t(275),t(278),t(277),t(279),t(280),t(281),t(258),t(272),t(294),t(293),t(292),n.exports=t(23)},{120:120,121:121,122:122,123:123,124:124,125:125,126:126,127:127,128:128,129:129,130:130,131:131,132:132,133:133,134:134,135:135,136:136,137:137,138:138,139:139,140:140,141:141,142:142,143:143,144:144,145:145,146:146,147:147,148:148,149:149,150:150,151:151,152:152,153:153,154:154,155:155,156:156,157:157,158:158,159:159,160:160,161:161,162:162,163:163,164:164,165:165,166:166,167:167,168:168,169:169,170:170,171:171,172:172,173:173,174:174,175:175,176:176,177:177,178:178,179:179,180:180,181:181,182:182,183:183,184:184,185:185,186:186,187:187,188:188,189:189,190:190,191:191,192:192,193:193,194:194,195:195,196:196,197:197,198:198,199:199,200:200,201:201,202:202,203:203,204:204,205:205,206:206,207:207,208:208,209:209,210:210,211:211,212:212,213:213,214:214,215:215,216:216,217:217,218:218,219:219,220:220,221:221,222:222,223:223,224:224,225:225,226:226,227:227,228:228,229:229,23:23,230:230,231:231,232:232,233:233,234:234,235:235,236:236,237:237,238:238,239:239,240:240,241:241,242:242,243:243,244:244,245:245,246:246,247:247,248:248,249:249,250:250,251:251,252:252,253:253,254:254,255:255,256:256,257:257,258:258,259:259,260:260,261:261,262:262,263:263,264:264,265:265,266:266,267:267,268:268,269:269,270:270,271:271,272:272,273:273,274:274,275:275,276:276,277:277,278:278,279:279,280:280,281:281,282:282,283:283,284:284,285:285,286:286,287:287,288:288,289:289,290:290,291:291,292:292,293:293,294:294}],296:[function(t,n){(function(t){!function(t){"use strict";function r(t,n,r,e){var o=n&&n.prototype instanceof i?n:i,u=Object.create(o.prototype),c=new h(e||[]);return u._invoke=f(t,r,c),u}function e(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function i(){}function o(){}function u(){}function c(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function a(t){function n(r,i,o,u){var c=e(t[r],t,i);if("throw"!==c.type){var a=c.arg,f=a.value;return f&&"object"==typeof f&&y.call(f,"__await")?Promise.resolve(f.__await).then(function(t){n("next",t,o,u)},function(t){n("throw",t,o,u)}):Promise.resolve(f).then(function(t){a.value=t,o(a)},u)}u(c.arg)}function r(t,r){function e(){return new Promise(function(e,i){n(t,r,e,i)})}return i=i?i.then(e,e):e()}"object"==typeof process&&process.domain&&(n=process.domain.bind(n));var i;this._invoke=r}function f(t,n,r){var i=S;return function(o,u){if(i===O)throw Error("Generator is already running");if(i===F){if("throw"===o)throw u;return p()}for(;;){var c=r.delegate;if(c){if("return"===o||"throw"===o&&c.iterator[o]===g){r.delegate=null;var a=c.iterator.return;if(a){var f=e(a,c.iterator,u);if("throw"===f.type){o="throw",u=f.arg;continue}}if("return"===o)continue}var f=e(c.iterator[o],c.iterator,u);if("throw"===f.type){r.delegate=null,o="throw",u=f.arg;continue}o="next",u=g;var s=f.arg;if(!s.done)return i=E,s;r[c.resultName]=s.value,r.next=c.nextLoc,r.delegate=null}if("next"===o)r.sent=r._sent=u;else if("throw"===o){if(i===S)throw i=F,u;r.dispatchException(u)&&(o="next",u=g)}else"return"===o&&r.abrupt("return",u);i=O;var f=e(t,n,r);if("normal"===f.type){i=r.done?F:E;var s={value:f.arg,done:r.done};if(f.arg!==M)return s;r.delegate&&"next"===o&&(u=g)}else"throw"===f.type&&(i=F,o="throw",u=f.arg)}}}function s(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function l(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function h(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(s,this),this.reset(!0)}function v(t){if(t){var n=t[b];if(n)return n.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,e=function i(){for(;++r<t.length;)if(y.call(t,r))return i.value=t[r],i.done=!1,i;return i.value=g,i.done=!0,i};return e.next=e}}return{next:p}}function p(){return{value:g,done:!0}}var g,d=Object.prototype,y=d.hasOwnProperty,m="function"==typeof Symbol?Symbol:{},b=m.iterator||"@@iterator",x=m.toStringTag||"@@toStringTag",w="object"==typeof n,_=t.regeneratorRuntime;if(_)return void(w&&(n.exports=_));_=t.regeneratorRuntime=w?n.exports:{},_.wrap=r;var S="suspendedStart",E="suspendedYield",O="executing",F="completed",M={},P={};P[b]=function(){return this};var A=Object.getPrototypeOf,j=A&&A(A(v([])));j&&j!==d&&y.call(j,b)&&(P=j);var I=u.prototype=i.prototype=Object.create(P);o.prototype=I.constructor=u,u.constructor=o,u[x]=o.displayName="GeneratorFunction",_.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===o||"GeneratorFunction"===(n.displayName||n.name))},_.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,u):(t.__proto__=u,x in t||(t[x]="GeneratorFunction")),t.prototype=Object.create(I),t},_.awrap=function(t){return{__await:t}},c(a.prototype),_.AsyncIterator=a,_.async=function(t,n,e,i){var o=new a(r(t,n,e,i));return _.isGeneratorFunction(n)?o:o.next().then(function(t){return t.done?t.value:o.next()})},c(I),I[x]="Generator",I.toString=function(){return"[object Generator]"},_.keys=function(t){var n=[];for(var r in t)n.push(r);return n.reverse(),function e(){for(;n.length;){var r=n.pop();if(r in t)return e.value=r,e.done=!1,e}return e.done=!0,e}},_.values=v,h.prototype={constructor:h,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=g,this.done=!1,this.delegate=null,this.tryEntries.forEach(l),!t)for(var n in this)"t"===n.charAt(0)&&y.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=g)},stop:function(){this.done=!0;var t=this.tryEntries[0],n=t.completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(t){function n(n,e){return o.type="throw",o.arg=t,r.next=n,!!e}if(this.done)throw t;for(var r=this,e=this.tryEntries.length-1;e>=0;--e){var i=this.tryEntries[e],o=i.completion;if("root"===i.tryLoc)return n("end");if(i.tryLoc<=this.prev){var u=y.call(i,"catchLoc"),c=y.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return n(i.catchLoc,!0);if(this.prev<i.finallyLoc)return n(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return n(i.catchLoc,!0)}else{if(!c)throw Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return n(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&y.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?this.next=i.finallyLoc:this.complete(o),M},complete:function(t,n){if("throw"===t.type)throw t.arg;"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=t.arg,this.next="end"):"normal"===t.type&&n&&(this.next=n)},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),l(r),M}},"catch":function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;l(r)}return i}}throw Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:v(t),resultName:n,nextLoc:r},M}}}("object"==typeof t?t:"object"==typeof window?window:"object"==typeof self?self:this)}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}]},{},[1]),Element.prototype.matches||(Element.prototype.matches=Element.prototype.matchesSelector||Element.prototype.mozMatchesSelector||Element.prototype.msMatchesSelector||Element.prototype.oMatchesSelector||Element.prototype.webkitMatchesSelector||function(t){for(var n=(this.document||this.ownerDocument).querySelectorAll(t),r=n.length;--r>=0&&n.item(r)!==this;);return r>-1}),function(t){if(!("EventSource"in t)){var n=/^(\s|\u00A0)+|(\s|\u00A0)+$/g,r=function(t){function r(t){o._pollTimer=setTimeout(function(){i.call(o)},t)}function i(){try{if(o.readyState==o.CLOSED)return;var t=new XMLHttpRequest;t.open("GET",o.URL,!0),t.setRequestHeader("Accept","text/event-stream"),t.setRequestHeader("Cache-Control","no-cache"),t.setRequestHeader("X-Requested-With","XMLHttpRequest"),null!=c&&t.setRequestHeader("Last-Event-ID",c),a="",t.timeout=5e4,t.onreadystatechange=function(){if(3==this.readyState||4==this.readyState&&200==this.status){o.readyState==o.CONNECTING&&(o.readyState=o.OPEN,o.dispatchEvent("open",{type:"open"}));var t="";try{t=this.responseText||""}catch(i){}var f=t.substr(a.length).split("\n"),s="message",l=[],h=0,v="";for(a=t;h<f.length;h++)if(v=f[h].replace(n,""),0==v.indexOf("event"))s=v.replace(/event:?\s*/,"");else if(0==v.indexOf("retry"))retry=parseInt(v.replace(/retry:?\s*/,"")),isNaN(retry)||(u=retry);else if(0==v.indexOf("data"))l.push(v.replace(/data:?\s*/,""));else if(0==v.indexOf("id:"))c=v.replace(/id:?\s*/,"");else if(0==v.indexOf("id"))c=null;else if(""==v&&l.length){var p=new e(l.join("\n"),o.url,c);o.dispatchEvent(s,p),l=[],s="message"}4==this.readyState&&r(u)}else o.readyState!==o.CLOSED&&(4==this.readyState?(o.readyState=o.CONNECTING,o.dispatchEvent("error",{type:"error"}),r(u)):0==this.readyState&&r(u))},t.send(),setTimeout(function(){t.abort()},t.timeout),o._xhr=t}catch(i){o.dispatchEvent("error",{type:"error",data:i.message})}}var o=this,u=500,c=null,a="";if(!t||"string"!=typeof t)throw new SyntaxError("Not enough arguments");this.URL=t,this.readyState=this.CONNECTING,this._pollTimer=null,this._xhr=null,i()};r.prototype={close:function(){this.readyState=this.CLOSED,clearInterval(this._pollTimer),this._xhr.abort()},CONNECTING:0,OPEN:1,CLOSED:2,dispatchEvent:function(t,n){var r=this["_"+t+"Handlers"];if(r)for(var e=0;e<r.length;e++)r[e].call(this,n);this["on"+t]&&this["on"+t].call(this,n)},addEventListener:function(t,n){this["_"+t+"Handlers"]||(this["_"+t+"Handlers"]=[]),this["_"+t+"Handlers"].push(n)},removeEventListener:function(t,n){var r=this["_"+t+"Handlers"];if(r)for(var e=r.length-1;e>=0;--e)if(r[e]===n){r.splice(e,1);break}},onerror:null,onmessage:null,onopen:null,readyState:0,URL:""};
var e=function(t,n,r){this.data=t,this.origin=n,this.lastEventId=r||""};e.prototype={data:null,type:"message",lastEventId:"",origin:""},"module"in t&&(module.exports=r),t.EventSource=r}}(this),window.NodeList&&!NodeList.prototype.forEach&&(NodeList.prototype.forEach=function(t,n){n=n||window;for(var r=0;r<this.length;r++)t.call(n,this[r],r,this)});
define("organizator/Polyfill/polyfill-extended.min", function(){});

(function(){
	if(typeof Element !== 'undefined' && !('parents' in Element.prototype)){
		Element.prototype.parents = function(selector){
			let current = this,
				parents = [],
				test = (undefined || null) === selector ? false : true;

			while(current.parentNode !== null && current.parentNode !== document.documentElement){
				if(test && !(current.parentNode.matches(selector))){
     				current = current.parentNode;
					continue;
				}

				parents.push(current.parentNode);
     			current = current.parentNode;
			}

			return parents;
		}
	}

	return;
})();
define("organizator/Polyfill/parents", function(){});

/* eslint no-extend-native: 0 */

(function () {
  // Defining locale
  Date.shortMonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
  Date.longMonths = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
  Date.shortDays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
  Date.longDays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
  // Defining patterns
  var replaceChars = {
    // Day
    d: function () { var d = this.getDate(); return (d < 10 ? '0' : '') + d },
    D: function () { return Date.shortDays[this.getDay()] },
    j: function () { return this.getDate() },
    l: function () { return Date.longDays[this.getDay()] },
    N: function () { var N = this.getDay(); return (N === 0 ? 7 : N) },
    S: function () { var S = this.getDate(); return (S % 10 === 1 && S !== 11 ? 'st' : (S % 10 === 2 && S !== 12 ? 'nd' : (S % 10 === 3 && S !== 13 ? 'rd' : 'th'))) },
    w: function () { return this.getDay() },
    z: function () { var d = new Date(this.getFullYear(), 0, 1); return Math.ceil((this - d) / 86400000) },
    // Week
    W: function () {
      var target = new Date(this.valueOf())
      var dayNr = (this.getDay() + 6) % 7
      target.setDate(target.getDate() - dayNr + 3)
      var firstThursday = target.valueOf()
      target.setMonth(0, 1)
      if (target.getDay() !== 4) {
        target.setMonth(0, 1 + ((4 - target.getDay()) + 7) % 7)
      }
      var retVal = 1 + Math.ceil((firstThursday - target) / 604800000)

      return (retVal < 10 ? '0' + retVal : retVal)
    },
    // Month
    F: function () { return Date.longMonths[this.getMonth()] },
    m: function () { var m = this.getMonth(); return (m < 9 ? '0' : '') + (m + 1) },
    M: function () { return Date.shortMonths[this.getMonth()] },
    n: function () { return this.getMonth() + 1 },
    t: function () {
      var year = this.getFullYear()
      var nextMonth = this.getMonth() + 1
      if (nextMonth === 12) {
        year = year++
        nextMonth = 0
      }
      return new Date(year, nextMonth, 0).getDate()
    },
    // Year
    L: function () { var L = this.getFullYear(); return (L % 400 === 0 || (L % 100 !== 0 && L % 4 === 0)) },
    o: function () { var d = new Date(this.valueOf()); d.setDate(d.getDate() - ((this.getDay() + 6) % 7) + 3); return d.getFullYear() },
    Y: function () { return this.getFullYear() },
    y: function () { return ('' + this.getFullYear()).substr(2) },
    // Time
    a: function () { return this.getHours() < 12 ? 'am' : 'pm' },
    A: function () { return this.getHours() < 12 ? 'AM' : 'PM' },
    B: function () { return Math.floor((((this.getUTCHours() + 1) % 24) + this.getUTCMinutes() / 60 + this.getUTCSeconds() / 3600) * 1000 / 24) },
    g: function () { return this.getHours() % 12 || 12 },
    G: function () { return this.getHours() },
    h: function () { var h = this.getHours(); return ((h % 12 || 12) < 10 ? '0' : '') + (h % 12 || 12) },
    H: function () { var H = this.getHours(); return (H < 10 ? '0' : '') + H },
    i: function () { var i = this.getMinutes(); return (i < 10 ? '0' : '') + i },
    s: function () { var s = this.getSeconds(); return (s < 10 ? '0' : '') + s },
    v: function () { var v = this.getMilliseconds(); return (v < 10 ? '00' : (v < 100 ? '0' : '')) + v },
    // Timezone
    e: function () { return Intl.DateTimeFormat().resolvedOptions().timeZone },
    I: function () {
      var DST = null
      for (var i = 0; i < 12; ++i) {
        var d = new Date(this.getFullYear(), i, 1)
        var offset = d.getTimezoneOffset()

        if (DST === null) DST = offset
        else if (offset < DST) { DST = offset; break } else if (offset > DST) break
      }
      return (this.getTimezoneOffset() === DST) | 0
    },
    O: function () { var O = this.getTimezoneOffset(); return (-O < 0 ? '-' : '+') + (Math.abs(O / 60) < 10 ? '0' : '') + Math.floor(Math.abs(O / 60)) + (Math.abs(O % 60) === 0 ? '00' : ((Math.abs(O % 60) < 10 ? '0' : '')) + (Math.abs(O % 60))) },
    P: function () { var P = this.getTimezoneOffset(); return (-P < 0 ? '-' : '+') + (Math.abs(P / 60) < 10 ? '0' : '') + Math.floor(Math.abs(P / 60)) + ':' + (Math.abs(P % 60) === 0 ? '00' : ((Math.abs(P % 60) < 10 ? '0' : '')) + (Math.abs(P % 60))) },
    T: function () { var tz = this.toLocaleTimeString(navigator.language, {timeZoneName: 'short'}).split(' '); return tz[tz.length - 1] },
    Z: function () { return -this.getTimezoneOffset() * 60 },
    // Full Date/Time
    c: function () { return this.format('Y-m-d\\TH:i:sP') },
    r: function () { return this.toString() },
    U: function () { return this.getTime() / 1000 }
  }

  // Simulates PHP's date function
  Date.prototype.format = function (format) {
    var date = this
    return format.replace(/(\\?)(.)/g, function (_, esc, chr) {
      return (esc === '' && replaceChars[chr]) ? replaceChars[chr].call(date) : chr
    })
  }
}).call(this);
define("organizator/Polyfill/date.format", function(){});

define('organizator/Util/NumberFormat',[],function(){
	return function number_format (number, decimals, decPoint, thousandsSep) { // eslint-disable-line camelcase
		//  discuss at: http://locutus.io/php/number_format/
		// original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
		// improved by: Kevin van Zonneveld (http://kvz.io)
		// improved by: davook
		// improved by: Brett Zamir (http://brett-zamir.me)
		// improved by: Brett Zamir (http://brett-zamir.me)
		// improved by: Theriault (https://github.com/Theriault)
		// improved by: Kevin van Zonneveld (http://kvz.io)
		// bugfixed by: Michael White (http://getsprink.com)
		// bugfixed by: Benjamin Lupton
		// bugfixed by: Allan Jensen (http://www.winternet.no)
		// bugfixed by: Howard Yeend
		// bugfixed by: Diogo Resende
		// bugfixed by: Rival
		// bugfixed by: Brett Zamir (http://brett-zamir.me)
		//  revised by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)
		//  revised by: Luke Smith (http://lucassmith.name)
		//    input by: Kheang Hok Chin (http://www.distantia.ca/)
		//    input by: Jay Klehr
		//    input by: Amir Habibi (http://www.residence-mixte.com/)
		//    input by: Amirouche
		//   example 1: number_format(1234.56)
		//   returns 1: '1,235'
		//   example 2: number_format(1234.56, 2, ',', ' ')
		//   returns 2: '1 234,56'
		//   example 3: number_format(1234.5678, 2, '.', '')
		//   returns 3: '1234.57'
		//   example 4: number_format(67, 2, ',', '.')
		//   returns 4: '67,00'
		//   example 5: number_format(1000)
		//   returns 5: '1,000'
		//   example 6: number_format(67.311, 2)
		//   returns 6: '67.31'
		//   example 7: number_format(1000.55, 1)
		//   returns 7: '1,000.6'
		//   example 8: number_format(67000, 5, ',', '.')
		//   returns 8: '67.000,00000'
		//   example 9: number_format(0.9, 0)
		//   returns 9: '1'
		//  example 10: number_format('1.20', 2)
		//  returns 10: '1.20'
		//  example 11: number_format('1.20', 4)
		//  returns 11: '1.2000'
		//  example 12: number_format('1.2000', 3)
		//  returns 12: '1.200'
		//  example 13: number_format('1 000,50', 2, '.', ' ')
		//  returns 13: '100 050.00'
		//  example 14: number_format(1e-8, 8, '.', '')
		//  returns 14: '0.00000001'
		number = (number + '').replace(/[^0-9+\-Ee.]/g, '')
		var n = !isFinite(+number) ? 0 : +number
		var prec = !isFinite(+decimals) ? 0 : Math.abs(decimals)
		var sep = (typeof thousandsSep === 'undefined') ? ',' : thousandsSep
		var dec = (typeof decPoint === 'undefined') ? '.' : decPoint
		var s = ''
		var toFixedFix = function (n, prec) {
		var k = Math.pow(10, prec)
		return '' + (Math.round(n * k) / k)
		  .toFixed(prec)
		}
		// @todo: for IE parseFloat(0.55).toFixed(0) = 0;
		s = (prec ? toFixedFix(n, prec) : '' + Math.round(n)).split('.')
		if (s[0].length > 3) {
		s[0] = s[0].replace(/\B(?=(?:\d{3})+(?!\d))/g, sep)
		}
		if ((s[1] || '').length < prec) {
		s[1] = s[1] || ''
		s[1] += new Array(prec - s[1].length + 1).join('0')
		}
		return s.join(dec)
	}
});
define('organizator/Util/ArrayIntersect',[],function(){
	return function array_intersect (args) { // eslint-disable-line camelcase
	  //  discuss at: http://locutus.io/php/array_intersect/
	  // original by: Brett Zamir (http://brett-zamir.me)
	  //      note 1: These only output associative arrays (would need to be
	  //      note 1: all numeric and counting from zero to be numeric)
	  //   example 1: var $array1 = {'a' : 'green', 0:'red', 1: 'blue'}
	  //   example 1: var $array2 = {'b' : 'green', 0:'yellow', 1:'red'}
	  //   example 1: var $array3 = ['green', 'red']
	  //   example 1: var $result = array_intersect($array1, $array2, $array3)
	  //   returns 1: {0: 'red', a: 'green'}

	  var retArr = []
	  var argl = args.length
	  var arglm1 = argl - 1
	  var k1 = ''
	  var arr = []
	  var i = 0
	  var k = ''
	  var arr1 = args[0]

	  arr1keys: for (k1 in arr1) { // eslint-disable-line no-labels
	    arrs: for (i = 1; i < argl; i++) { // eslint-disable-line no-labels
	      arr = args[i]
	      for (k in arr) {
	        if (arr[k] === arr1[k1]) {
	          if (i === arglm1) {
	            retArr[k1] = arr1[k1]
	          }
	          // If the innermost loop always leads at least once to an equal value,
	          // continue the loop until done
	          continue arrs// eslint-disable-line no-labels
	        }
	      }
	      // If it reaches here, it wasn't found in at least one array, so try next value
	      continue arr1keys// eslint-disable-line no-labels
	    }
	  }

	  return retArr
	}
});
define(
    'organizator/Organizator',[
        'organizator/config',
        'organizator/Component/Globals/Globals',
        'organizator/Component/Routing/Routing',
        'organizator/Component/Validation/Validator',
        'organizator/Component/Nunjucks/Nunjucks',
        'organizator/Component/Translator/Translator',
        'lokijs/build/lokijs.min',
        'organizator/Util/FormSerializer',
        'organizator/Polyfill/polyfill-extended.min',
        'organizator/Polyfill/parents',
        'organizator/Polyfill/date.format'
    ],
    function(
        config,
        Organizator_Globals,
        Organizator_Routing,
        Organizator_Validation_Validator,
        Organizator_Nunjucks,
        Organizator_Translator,
        Loki,
        Organizator_Util_FormSerializer
    ){
        class Organizator {
            constructor(configuration = {}){
                var self = this;

                this.configuration = Object.assign(config, configuration);
                this.configuration.localization.locale = document.querySelector('html').getAttribute('lang');

                this.Globals = new Organizator_Globals();

                let basePath = '';
                this.Routing = new Organizator_Routing({
                    base: basePath ? basePath : location.protocol + '//' + location.host,
                    mode: 'history'
                });
                
                this.Validator = new Organizator_Validation_Validator();
                
                this.Db = new Loki('organizator_database.json');
                this.PersistentDb = new Loki("organizator_peristent_database.db", { 
                  autoload: true,
                  // autoloadCallback : databaseInitialize,
                  autosave: false
                });
                
                this._Nunjucks = Organizator_Nunjucks;
                this.Nunjucks = new this._Nunjucks.Environment(new this._Nunjucks.WebLoader(''));

                this.Nunjucks.addGlobal('path', function(route, parameters, options) {
                    return self.Routing.Generator.generateUrl(route, parameters, options);
                });

                require(['organizator/Util/NumberFormat'], function(number_format){
                    self.Nunjucks.addFilter('number_format', function(number, decimals, decPoint, thousandsSep) {
                        return number_format(number, decimals, decPoint, thousandsSep);
                    });
                });

                require(['organizator/Util/ArrayIntersect'], function(array_intersect){
                    self.Nunjucks.addFilter('array_intersect', function() {
                        return array_intersect(arguments);
                    });
                });

                self.Nunjucks.addFilter('date', function(date, format) {
                    return new Date(date * 1000).format(format);
                });

                self.Nunjucks.addFilter('hex2dec', function(hex) {
                    return parseInt(hex, 16);
                });

                self.Nunjucks.addFilter('truncate', function(str) {
                    return str;
                });

                /*
                self.Nunjucks.addFilter('trans', function(id, params, domain) {
                    return bazinga.trans(id, params, domain);
                });*/

                this.FormSerializer = new Organizator_Util_FormSerializer();
                this.Translator = new Organizator_Translator({
                    defaultLocale: this.configuration.localization.defaultLocale,
                    availableLocales: this.configuration.localization.availableLocales,
                    locale: this.configuration.localization.locale
                });

                
                this.applications = {};
                this.globals = {};
            }
        }
        
        if(window.Organizator === undefined){
            window.Organizator = new Organizator();
        }

        return window.Organizator;
    }
);
define('route',[],function(){
    return {
        load: function(name, parentRequire, onload, config) {
            parentRequire(
                [
                    name
                ], function(
                    value
                ){
                    if(config.isBuild){
                        onload(null); //avoid errors on the optimizer
                    }else{
                        let routes = value;
                        let routesKeys = Object.keys(routes);

                        if(routesKeys.length){
                            let routeCompiler = Organizator.Routing.RouteCompiler;

                            for(let i = 0; i < routesKeys.length; i++){
                                let route = routes[routesKeys[i]];
                                Organizator.Routing.addRoute(routesKeys[i], routeCompiler.compile(route));
                            }
                        }

                        onload(value);
                    }
                }
            );
        }
    };
});
define('organizator/Resources/routes',{
	/* main */
    listen: {
        path: '/api/listen/',
    },
    accept: {
        path: '/api/accept/',
    },
});

define('controller',[],function(){
    return {
        load: function(name, parentRequire, onload, config) {
            parentRequire(
                [
                    name
                ], function(
                    value
                ){
                    if(config.isBuild){
                        onload(null); //avoid errors on the optimizer
                    }else{
                        let controllers = value;
                        let controllerKeys = Object.keys(controllers);
                        if(controllerKeys.length){
                            for(let i = 0; i < controllerKeys.length; i++){
                                Organizator.Routing.addController(controllerKeys[i], controllers[controllerKeys[i]]);
                            }
                        }
                        
                        onload(value);
                    }
                }
            );
        }
    };
});
define('organizator/Resources/controllers',{
	helloAction: function(request){
		document.querySelector('body').innerHTML = 'Hello world';
	}
});

define(
    'organizator/Organizator/Application',[],function(){
    class Organizator_Application{
        constructor(name = undefined){
//            options = Object.assign({
//                routes: {},
//                controllers: {}
//            }, options);
            
            this.name = name;
//            this.routes = options.routes;
//            this.controllers = options.controllers;
//            this.entities = options.entities;
            
              this.registerApplication();
//            this.registerRoutes();
//            this.registerControllers();
//            this.registerTranslations(options.translations || []);

        }
        
        registerApplication(){
            if(typeof Organizator.applications[this.name] === 'undefined'){
                Organizator.applications[this.name] = this;

                document.body.dispatchEvent(new Event(this.name + '_registered'));
            }
        }
        
//        registerRoutes(){
//            let routesKeys = Object.keys(this.routes);
//            if(!routesKeys.length){return;}
//            
//            let routeCompiler = new RouteCompiler();
//            
//            for(let i = 0; i < routesKeys.length; i++){
//                let route = this.routes[routesKeys[i]];
//                Organizator.Routing.addRoute(routesKeys[i], routeCompiler.compile(route));
//            }
//        }
//        
//        registerControllers(){
//            let controllerKeys = Object.keys(this.controllers);
//            if(!controllerKeys.length){return;}
//            
//            for(let i = 0; i < controllerKeys.length; i++){
//                Organizator.Routing.addController(controllerKeys[i], this.controllers[controllerKeys[i]]);
//            }
//        }
//        
//        registerEntities(){
//            let entities = this.entities;
//            if(!controllerKeys.length){return;}
//            
//            for(let i = 0; i < controllerKeys.length; i++){
//                Organizator.Routing.addController(controllerKeys[i], this.controllers[controllerKeys[i]]);
//            }
//        }
//        
//        registerTranslations(translations){
//            if(!translations.length){return;}
//            
//            let parser = new DOMParser();
//            
//            for(let i = 0; i < translations.length; i++){
//                let translation = translations[i];
//                let document = parser.parseFromString(translation, 'application/xml');
//                
//                Organizator.Translator.addDocument(document, 'xliff');
//            }
//        }
    }
    
    return Organizator_Application;
});
/**
 * @license RequireJS text 2.0.5 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/text for details
 */
/*jslint regexp: true */
/*global require: false, XMLHttpRequest: false, ActiveXObject: false,
  define: false, window: false, process: false, Packages: false,
  java: false, location: false */

define('text',['module'], function (module) {
    'use strict';

    var text, fs,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = [],
        masterConfig = (module.config && module.config()) || {};

    text = {
        version: '2.0.5',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var modName, ext, temp,
                strip = false,
                index = name.indexOf("."),
                isRelative = name.indexOf('./') === 0 ||
                             name.indexOf('../') === 0;

            if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1, name.length);
            } else {
                modName = name;
            }

            temp = ext || modName;
            index = temp.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                    ext = temp;
                } else {
                    modName = temp;
                }
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                   ((!uPort && !uHostName) || uPort === port);
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName +
                    (parsed.ext ? '.' + parsed.ext : ''),
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                                    parsed.strip, content, onLoad);
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                               "define(function () { return '" +
                                   content +
                               "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                extPart = parsed.ext ? '.' + parsed.ext : '',
                nonStripName = parsed.moduleName + extPart,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node)) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback) {
            var file = fs.readFileSync(url, 'utf8');
            //Remove BOM (Byte Mark Order) from utf8 files if it is there.
            if (file.indexOf('\uFEFF') === 0) {
                file = file.substring(1);
            }
            callback(file);
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function (url, callback, errback, headers) {
            var xhr = text.createXhr(), header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers
            if (headers) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                    }
                }
            }

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        errback(err);
                    } else {
                        callback(xhr.responseText);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                stringBuffer.append(line);

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    }

    return text;
});


define('text!organizator/Apps/MyApp/view/message-unit-invite.html.njk',[],function () { return '<div class="messageunit {{ mode }} invite">\r\n    <div class="h">\r\n        <div class="sender">From: {{ sender_pubkey }}</div>\r\n        <div class="recipient">To: {{ recipient_pubkey }}</div>\r\n        <div class="tx">Txid: <a target="_blank" href="https://whatsonchain.com/tx/{{ txid }}">{{ txid }}</a></div>\r\n    </div>\r\n    <div class="c">\r\n        *** On-chain invitation {% if mode == \'sent\' %}sent. Waiting answer..{% else %}received{% endif %} ***\r\n    </div>\r\n</div>';});


define('text!organizator/Apps/MyApp/view/message-unit-accept.html.njk',[],function () { return '<div class="messageunit {{ mode }} accept">\r\n    <div class="h">\r\n        <div class="sender">From: {{ sender_pubkey }}</div>\r\n        <div class="recipient">To: {{ recipient_pubkey }}</div>\r\n        <div class="tx">Replyto: <a target="_blank" href="https://whatsonchain.com/tx/{{ replyto }}">{{ replyto }}</a></div>\r\n        <div class="tx">Txid: <a target="_blank" href="https://whatsonchain.com/tx/{{ txid }}">{{ txid }}</a></div>\r\n    </div>\r\n    <div class="c">\r\n        *** On-chain acceptation {% if mode == \'sent\' %}sent. Waiting answer..{% else %}received{% endif %} ***\r\n    </div>\r\n</div>';});

define(
    'organizator/Apps/MyApp/MyApp',[
        'organizator/Organizator/Application',
        'text!./view/message-unit-invite.html.njk',
        'text!./view/message-unit-accept.html.njk'
    ],
    function(
        Organizator_Application,
        tpl_messageUnitInvite,
        tpl_messageUnitAccept
    ){
        class MyApp extends Organizator_Application {
            constructor(){
                super('MyApp');

                this.eventSource = null;
                this.peer_host = undefined;
                this.peer_port = undefined;
                this.peer_pubkey = undefined;

                this.messageCollectionElement = document.querySelector('.messages .collection');
                this.statusElement = document.querySelector('.status .b');
                this.userPubkeyElement = document.querySelector('.user .b');
                this.peerPubkeyElement = document.querySelector('.peer .b');

                this.user_pubkey = this.userPubkeyElement.innerText;

                this.inviteCollection = Organizator.PersistentDb.addCollection('invite');
                this.listen();
            }

            setPeerPubkey(pubkey){
                this.peer_pubkey = pubkey;
                this.statusElement.innerHTML = 'waiting answer..';
                this.peerPubkeyElement.innerHTML = pubkey;
            }

            listen(){
                var self = this;

                this.eventSource = new EventSource(Organizator.Routing.Generator.generateUrl('listen'));

                this.eventSource.onmessage = function(event) {
                    let response = JSON.parse(event.data);

                    if(typeof response !== 'undefined'){
                        if(response.type == 'invite' && !self.inviteCollection.find({txid: response.txid}).length){
                            self.inviteCollection.insert({
                                txid: response.txid
                            });
                            Organizator.PersistentDb.saveDatabase();

                            if(!self.messageCollectionElement.querySelectorAll('.messageunit').length){
                                self.messageCollectionElement.innerHTML = '';
                            }

                            self.messageCollectionElement.insertAdjacentHTML('afterbegin', Organizator.Nunjucks.renderString(tpl_messageUnitInvite, {
                                mode: 'received',
                                txid: response.txid,
                                recipient_pubkey: Organizator.applications.MyApp.user_pubkey,
                                sender_pubkey: response.from
                            }));

                            setTimeout(function(){
                                if(confirm("Someone with following details invites you to off-chain communication. Do you confirm to share your details?\n" + JSON.stringify(response, null, 4))){
                                    self.accept(response);
                                }
                            }, 200);
                        }

                        if(response.type == 'accept' && !self.inviteCollection.find({txid: response.txid}).length){
                            self.inviteCollection.insert({
                                txid: response.txid
                            });
                            Organizator.PersistentDb.saveDatabase();

                            if(!self.messageCollectionElement.querySelectorAll('.messageunit').length){
                                self.messageCollectionElement.innerHTML = '';
                            }

                            self.messageCollectionElement.insertAdjacentHTML('afterbegin', Organizator.Nunjucks.renderString(tpl_messageUnitAccept, {
                                mode: 'received',
                                txid: response.txid,
                                replyto: response.replyto,
                                recipient_pubkey: Organizator.applications.MyApp.user_pubkey,
                                sender_pubkey: response.from
                            }));

                            self.peer_host = response.ip;
                            self.peer_port = response.port;
                            self.setPeerPubkey(response.from);
                            Organizator.applications.MessageServer.set(response.ip, response.port);
                            Organizator.applications.MessageServer.start();
                        }
                    }
                }
            }

            accept(invite){
                this.setPeerPubkey(invite.from);
                this.peer_host = invite.ip;
                this.peer_port = invite.port;

                let formData = new FormData();
                formData.append('recipient', invite.from);
                formData.append('host', invite.ipt);
                formData.append('port', invite.port);
                formData.append('txid', invite.txid);

                let self = this;

                let xhr = new XMLHttpRequest();
                xhr.open('POST', Organizator.Routing.Generator.generateUrl('accept'));
                xhr.addEventListener('load', function(){
                    self.serverResponse = JSON.parse(this.responseText);

                    if(self.serverResponse.form.isValid){
                        if(!self.messageCollectionElement.querySelectorAll('.messageunit').length){
                            self.messageCollectionElement.innerHTML = '';
                        }

                        self.messageCollectionElement.insertAdjacentHTML('afterbegin', Organizator.Nunjucks.renderString(tpl_messageUnitAccept, {
                            mode: 'sent',
                            txid: invite.txid,
                            replyto: invite.txid,
                            sender_pubkey: Organizator.applications.MyApp.user_pubkey,
                            recipient_pubkey: invite.from
                        }))

                        Organizator.applications.MessageServer.set(invite.ip, invite.port);
                        Organizator.applications.MessageServer.start();
                    }else{
                       console.log('error');
                    }
                });
                xhr.send(formData);
                xhr = undefined;
            }
        }
        
        return MyApp;
    }
);

define('text!organizator/Apps/FormStd/Resources/view/advice-row.html.njk',[],function () { return '<div class="row adviceRow">\r\n\t{% if errors|length %}\r\n\t\t<div class="right advice advice--red">\r\n\t\t\t<ul class="adviceList">\r\n\t\t\t\t{% for error in errors %}\r\n\t\t\t\t\t<li>{{ error }}</li>\r\n\t\t\t\t{% endfor %}\r\n\t\t\t</ul>\r\n\t\t</div>\r\n\t{% endif %}\r\n</div>';});

define(
    'organizator/Apps/FormStd/FormStd',[
        'organizator/Organizator/Application',
        'text!./Resources/view/advice-row.html.njk'
    ],
    function(
        Organizator_Application,
        tpl_adviceRow
    ){
        class FormStd extends Organizator_Application {
            constructor(form, identifier, options){
                super('FormStd_' + identifier);

                this.form = form;
                this.formName = this.form.getAttribute('name');
                this.formFields = this.form.querySelectorAll('input, textarea, select, button');
                this.formFieldsToBeValidated = this.form.querySelectorAll('.js__input[org-validate]');
                this.submitButtons = this.form.querySelectorAll('[type="submit"]');
                this.formGroups = this.form.querySelectorAll('.js__formGroup');
                this.serverResponse = undefined;
                this.inProgress = false;
                this.isRequest = true;
                this.isXMLHttpRequest = false;
                this.validationMode = 'onInputChange';
                this.validateOnSubmit = true;
                this.hideBlankFieldErrors = true;
                this.onFormSuccess = false;
                this.onFormError = false;
                this.adviceTemplate = tpl_adviceRow;

                Object.assign(this, options);

                this.onInputChange = this.onInputChange.bind(this);
                this.formSubmitted = this.formSubmitted.bind(this);
                this.onSubmitValidate = this.onSubmitValidate.bind(this);
                this.noRequestValidate = this.noRequestValidate.bind(this);

                this.bindEvents();
                this.normalizeForm();
            }

            refreshElements(){
                this.formFields = this.form.querySelectorAll('input, textarea, select, button');
                this.formFieldsToBeValidated = this.form.querySelectorAll('.js__input[org-validate]');
                this.submitButtons = this.form.querySelectorAll('[type="submit"]');
                this.formGroups = this.form.querySelectorAll('.js__formGroup');
            }

            /*
             * Event listeners should be removed before added because preventing double-fired events
             * after rebinding events when new form elements added to form (and form controller).
             * 
             * We can rebind events unlimited time safely since we remove event listeners before adding them. 
             */
            bindEvents(){
                var self = this;

                if(this.isRequest){
                    if(this.isXMLHttpRequest){
                        this.form.removeEventListener('submit', this.formSubmitted);
                        this.form.addEventListener('submit', this.formSubmitted);
                    }else{
                        if(this.validateOnSubmit){
                            this.form.removeEventListener('submit', this.onSubmitValidate);
                            this.form.addEventListener('submit', this.onSubmitValidate);
                        }
                    }
                }else{
                    this.form.removeEventListener('submit', this.noRequestValidate);
                    this.form.addEventListener('submit', this.noRequestValidate);
                }

                switch(typeof this.validationMode){
                    case 'string':
                        switch(this.validationMode){
                            case 'onInputBlur':
                                this.formFieldsToBeValidated.forEach(function(element){
                                    element.removeEventListener('blur', self.onInputChange);
                                    element.addEventListener('blur', self.onInputChange);
                                });
                                break;
                            case 'onInputChange':
                                this.formFieldsToBeValidated.forEach(function(element){
                                    element.removeEventListener('input', self.onInputChange);
                                    element.addEventListener('input', self.onInputChange);
                                });
                                break;
                            case 'onFormSubmit':
                                this.form.addEventListener('submit', this.validateForm);
                                break;
                        }
                        break;
                    case 'object':
                        for(let item of this.validationMode){
                            switch(item){
                                case 'onInputBlur':
                                    this.formFieldsToBeValidated.forEach(function(element){
                                        element.removeEventListener('blur', self.onInputChange);
                                        element.addEventListener('blur', self.onInputChange);
                                    });
                                    break;
                                case 'onInputChange':
                                    this.formFieldsToBeValidated.forEach(function(element){
                                        element.removeEventListener('input', self.onInputChange);
                                        element.addEventListener('input', self.onInputChange);
                                        element.removeEventListener('change', self.onInputChange);
                                        element.addEventListener('change', self.onInputChange);
                                    });
                                    break;
                                case 'onFormSubmit':
                                    this.form.addEventListener('submit', this.validateForm);
                                    break;
                            }
                        }
                        break;
                }
            }

            normalizeForm(){
                this.form.setAttribute('novalidate', 'novalidate');
            }

            formSubmitted(event){
                event.preventDefault();

                this.lockForm();
                if(this.validateOnSubmit && this.onSubmitValidate(event) === false){
                    event.preventDefault();

                    this.unlockForm();
                    return false;
                }

                let self = this;
                let action = this.form.getAttribute('action');
                let method = this.form.getAttribute('method');
                let formData = new FormData(this.form);

                let xhr = new XMLHttpRequest();
                xhr.open(method, action);

                xhr.addEventListener('loadstart', function(){
                    this.inProgress = true;
                });

                xhr.addEventListener('load', function(){
                    try{
                        self.serverResponse = JSON.parse(this.responseText);
                    }catch(e){
                        self.unlockForm();
                    }

                    if(self.serverResponse.form.isValid){
                        if(typeof self.onFormSuccess === 'function'){
                            self.onFormSuccess(self.serverResponse);
                        }
                    }else{
                        self.renderErrors(self.serverResponse.form.errors);

                        if(typeof self.onFormError === 'function'){
                            self.onFormError(self.serverResponse);
                        }
                    }

                    self.unlockForm();
                });
                xhr.addEventListener('onerror abort timeout', function(){
                    self.unlockForm();
                });
                xhr.send(formData);
                xhr = undefined;
            }

            onInputChange(event){
                let element = event.currentTarget;
                let formGroupElement = element.parents('.js__formGroup')[0];

                /*
                 * If value is empty, remove all messages including exception messages for NotBlank constraint.
                 * NotBlank errors has negative effect on UX when real-time form usage. 
                 * It's better to show NotBlank errors for only server-side responses.
                 */
                if(this.hideBlankFieldErrors && element.value.length == 0){
                    formGroupElement.classList.remove('error');
                    let adviceRowElement = formGroupElement.querySelector('.adviceRow');
                    let newAdviceRow = Organizator.Nunjucks.renderString(this.adviceTemplate, {
                            errors: []
                        });
                    if(adviceRowElement === undefined || adviceRowElement === null){
                        formGroupElement.insertAdjacentHTML('beforeend', newAdviceRow);
                    }else{
                        adviceRowElement.outerHTML = newAdviceRow;
                    }

                    return;
                }

                let itemValidationResult = Organizator.Validator.validateHTMLElement(element);
                let fieldErrors = [];

                for(let fieldConstraintsKey in itemValidationResult.constraints){
                    let fieldConstraints = itemValidationResult.constraints[fieldConstraintsKey];
                    if(fieldConstraints.errorCount == 0){
                        formGroupElement.classList.remove('error');
                        continue;
                    }

                    formGroupElement.classList.add('error');

                    for(let error of fieldConstraints.errors){
                        fieldErrors.push(error);
                    }

                    let adviceRowElement = formGroupElement.querySelector('.adviceRow');
                    let newAdviceRow = Organizator.Nunjucks.renderString(this.adviceTemplate, {
                            errors: fieldErrors
                        });
                    if(adviceRowElement === undefined || adviceRowElement === null){
                        formGroupElement.insertAdjacentHTML('beforeend', newAdviceRow);
                    }else{
                        adviceRowElement.outerHTML = newAdviceRow;
                    }
                } 
            }

            onSubmitValidate(event){
                let formValidationResult = Organizator.Validator.validateForm(this.form);
                
                if(formValidationResult.errorCount > 0){
                    
                    for(let itemValidationResult of formValidationResult.results){
                        let formGroupElement = itemValidationResult.item.parents('.js__formGroup')[0];
                        let fieldErrors = [];

                        for(let fieldConstraintsKey in itemValidationResult.constraints){
                            let fieldConstraints = itemValidationResult.constraints[fieldConstraintsKey];
                            if(fieldConstraints.errorCount == 0){
                                formGroupElement.classList.remove('error');
                                continue;
                            }

                            formGroupElement.classList.add('error');

                            for(let error of fieldConstraints.errors){
                                fieldErrors.push(error);
                            }

                            let adviceRowElement = formGroupElement.querySelector('.adviceRow');
                            let newAdviceRow = Organizator.Nunjucks.renderString(this.adviceTemplate, {
                                    errors: fieldErrors
                                });
                            if(adviceRowElement === undefined || adviceRowElement === null){
                                formGroupElement.insertAdjacentHTML('beforeend', newAdviceRow);
                            }else{
                                adviceRowElement.outerHTML = newAdviceRow;
                            }
                        } 
                    }

                    event.preventDefault();
                }

                return formValidationResult.isValid;
            }

            noRequestValidate(event){
                event.preventDefault();

                let isValid =  this.onSubmitValidate(event);

                if(isValid){
                    if(typeof this.onFormSuccess === 'function'){
                        this.onFormSuccess();
                    }
                }else{
                    if(typeof this.onFormError === 'function'){
                        this.onFormError();
                    }
                }
            }

            clearErrors(){
                let adviceRows = this.form.querySelectorAll('.adviceRow');
                
                for(let row of adviceRows){
                    row.innerHTML = '';
                }
            }

            renderErrors(errors){
                for(let formGroupElement of this.formGroups){
                    let fieldName = formGroupElement.getAttribute('for').replace(this.formName + '_', '');
                    let fieldErrors = errors[fieldName];
                    
                    if(typeof fieldErrors === 'undefined' || fieldErrors.length == 0){continue;}

                    let adviceRowElement = formGroupElement.querySelector('.adviceRow');
                    let newAdviceRow = Organizator.Nunjucks.renderString(this.adviceTemplate, {
                            errors: fieldErrors
                        });
                    if(adviceRowElement === undefined || adviceRowElement === null){
                        formGroupElement.insertAdjacentHTML('beforeend', newAdviceRow);
                    }else{
                        adviceRowElement.outerHTML = newAdviceRow;
                    }
                }
            }

            lockForm(){
                this.inProgress = true;

                for(let button of this.submitButtons){
                    if(!button.hasAttribute('disabled')){
                        button.classList.add('js__disabledByFormStd');
                        button.setAttribute('data-initialhtml', button.innerHTML);
                        button.innerHTML = 'Please wait..';
                        button.setAttribute('disabled', '');
                    }
                }

                for(let element of this.formFields){
                    if(!element.hasAttribute('readonly')){
                        element.classList.add('js__readonlyByFormStd');
                        element.setAttribute('readonly', '');
                    }
                }
            }

            unlockForm(){
                this.inProgress = false;

                for(let button of this.submitButtons){
                    if(button.classList.contains('js__disabledByFormStd')){
                        button.classList.remove('js__disabledByFormStd');
                        button.innerHTML = button.getAttribute('data-initialhtml');
                        button.removeAttribute('disabled');
                    }
                }

                for(let element of this.formFields){
                    if(element.classList.contains('js__readonlyByFormStd')){
                        element.classList.remove('js__readonlyByFormStd');
                        element.removeAttribute('readonly');
                    }
                }
            }
        }
        
        return FormStd;
    }
);
define(
    'organizator/Apps/InviteForm/InviteForm',[
        'organizator/Organizator/Application',
        'organizator/Apps/FormStd/FormStd',
        'text!organizator/Apps/MyApp/view/message-unit-invite.html.njk'
    ],
    function(
        Organizator_Application,
        FormStd,
        tpl_messageUnitInvite
    ){
        class InviteForm extends Organizator_Application {
            constructor(){
                super('InviteForm');

                this.formName = 'inviteform';
                this.form = document.querySelector('form[name="' + this.formName + '"]');
                this.formController = new FormStd(this.form, this.formName, {
                    validationMode: 'onInputChange',
                    isXMLHttpRequest: true,
                    hideBlankFieldErrors: true,
                    onFormSuccess: this.onFormSuccess
                });
            }

            onFormSuccess(response){
                this.form.reset();

                Organizator.applications.MyApp.setPeerPubkey(response.peer_pubkey);
                Organizator.applications.MyApp.messageCollectionElement.innerHTML = Organizator.Nunjucks.renderString(tpl_messageUnitInvite, {
                    mode: 'sent',
                    txid: response.txid,
                    sender_pubkey: Organizator.applications.MyApp.user_pubkey,
                    recipient_pubkey: response.peer_pubkey
                });
            }
        }
        
        return InviteForm;
    }
);
define(
    'organizator/Apps/MessageForm/MessageForm',[
        'organizator/Organizator/Application',
        'organizator/Apps/FormStd/FormStd',
        'text!organizator/Apps/MyApp/view/message-unit-invite.html.njk'
    ],
    function(
        Organizator_Application,
        FormStd,
        tpl_messageUnitInvite
    ){
        class MessageForm extends Organizator_Application {
            constructor(){
                super('MessageForm');

                this.formName = 'messageform';
                this.form = document.querySelector('form[name="' + this.formName + '"]');
                this.field__message = this.form.querySelector('[name="message"]');

                this.bindEvents();
            }

            bindEvents(){
                this.form.addEventListener('submit', this.formSubmitted.bind(this));
            }

            formSubmitted(event){
                event.preventDefault();
                
                let message = this.field__message.value;
                Organizator.applications.MessageServer.send(message);
                this.form.reset();
            }

            onFormSuccess(response){
            }

            unlock(){
                for(let element of this.form.querySelectorAll('textarea, input, button')){
                    element.removeAttribute('disabled');
                }
            }

            lock(){
                for(let element of this.form.querySelectorAll('textarea, input, button')){
                    element.setAttribute('disabled', true);
                }
            }
        }
        
        return MessageForm;
    }
);

define('text!organizator/Apps/MyApp/view/message-unit.html.njk',[],function () { return '<div class="messageunit {{ mode }}">\r\n    <div class="h">\r\n        <div class="sender">From: {{ sender }}</div>\r\n        <div class="recipient">To: {{ recipient }}</div>\r\n        \r\n    </div>\r\n    <div class="c">\r\n        {{ message }}\r\n    </div>\r\n</div>';});

define(
    'organizator/Apps/MessageServer/MessageServer',[
        'organizator/Organizator/Application',
        'text!organizator/Apps/MyApp/view/message-unit.html.njk',
        'text!organizator/Apps/MyApp/view/message-unit-invite.html.njk',
        'text!organizator/Apps/MyApp/view/message-unit-accept.html.njk'
    ],
    function(
        Organizator_Application,
        tpl_messageUnit,
        tpl_messageUnitInvite,
        tpl_messageUnitAccept
    ){
        class MessageServer extends Organizator_Application {
            constructor(){
                super('MessageServer');

                this.local_host = document.location.hostname;
                this.local_port = 8080;
                this.local_server = new WebSocket('ws://' + this.local_host + ':' + this.local_port);

                this.local_server.onmessage = this.onmessage;
                this.local_server.onopen = this.onopen;
                this.local_server.onerror = this.onerror;

                this.host = null;
                this.port = null;
                this.server = null;
            }

            set(ip, port){
                Organizator.applications.MessageServer.host = ip;
                Organizator.applications.MessageServer.port = port;
                Organizator.applications.MessageServer.start();
            }

            onmessage(event) {
                let message = event.data;

                let message_html = Organizator.Nunjucks.renderString(tpl_messageUnit, {
                    mode: 'received',
                    sender: Organizator.applications.MyApp.peer_pubkey,
                    recipient: Organizator.applications.MyApp.user_pubkey,
                    message: message
                });
                if(!Organizator.applications.MyApp.messageCollectionElement.querySelectorAll('.messageunit').length){
                    Organizator.applications.MyApp.messageCollectionElement.innerHTML = '';
                }
                Organizator.applications.MyApp.messageCollectionElement.insertAdjacentHTML('afterbegin', message_html);                

            }

            onopen() {
            }

            onerror(error) {
            }

            send(message){
                this.server.send(message);

                let message_html = Organizator.Nunjucks.renderString(tpl_messageUnit, {
                    mode: 'sent',
                    sender: Organizator.applications.MyApp.user_pubkey,
                    recipient: Organizator.applications.MyApp.peer_pubkey,
                    message: message
                });
                if(!Organizator.applications.MyApp.messageCollectionElement.querySelectorAll('.messageunit').length){
                    Organizator.applications.MyApp.messageCollectionElement.innerHTML = '';
                }
                Organizator.applications.MyApp.messageCollectionElement.insertAdjacentHTML('afterbegin', message_html);                
            }

            start(){
                this.server = new WebSocket('ws://' + this.host + ':' + this.port);

                Organizator.applications.MessageForm.unlock();
                Organizator.applications.MyApp.statusElement.innerHTML = 'connected: ' + this.host + ':' + this.port;
                Organizator.applications.InviteForm.form.classList.add('hide');
                Organizator.applications.MyApp.eventSource = null;
            }

            stop(){
                Organizator.applications.MyApp.statusElement.innerHTML = 'disconnected: ' + this.host + ':' + this.port;
                Organizator.applications.MessageForm.lock();
                Organizator.applications.InviteForm.form.classList.remove('hide');
            }
        }
        
        return MessageServer;
    }
);
require(
	[
		'organizator/Organizator'
	],
	function(
		Organizator
	){
		require(
			[
			    'route!organizator/Resources/routes',
			    'controller!organizator/Resources/controllers'
			],
			function(
				routes,
				controllers
			){
				require(
					[
						'organizator/Apps/MyApp/MyApp',
						'organizator/Apps/InviteForm/InviteForm',
						'organizator/Apps/MessageForm/MessageForm',
						'organizator/Apps/MessageServer/MessageServer'
					],
					function(
						MyApp,
						InviteForm,
						MessageForm,
						MessageServer
					){
						new MyApp();
						new InviteForm();
						new MessageForm();
						new MessageServer();
					}
				);
			}
		);
	}
);
define("../app", function(){});

